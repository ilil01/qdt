---
title: |
  Пример
author:
- Автор
tags: []
abstract: |
  **Аннотация**

  *ТУДУ*

  **Ключевые слова**:
  ТУДУ,
  ТУДУ.
...

# Введение

При разработке новой виртуальной вычислительной машины (VM) программист
неизбежно сталкивается с ситуацией, когда VM ведёт себя не так, как он ожидает.
Причины этого бывают самые разные:
ошибка в реализации модели какого-то устройства,
неправильное соединение устройств между собой,
некорректная реализация гостевого программного обеспечения (ПО), используемого
для тестирования,
и т.д.
Часто это выглядит как отсутствие какой-либо реакции со стороны VM,
отказ (аварийное завершение процесса),
сообщение о сбое от гостевого ПО,
сообщение о неожиданном поведении гостевого ПО от модели устройства
и т.п.
В большинстве случаев для понимания неисправности от программиста требуется
сбор дополнительной информации.
При этом используется совокупность методов.

- Отладка процесса эмулятора.
При этом отслеживаются инициализация VM и её реакция на действия гостевого ПО.
- Отладка гостевого ПО средствами эмулятора.
Тут наоборот, отслеживается реакция гостевого ПО на действия компонентов VM.
- Использование отладочных возможностей инфраструктуры эмулятора, таких как
вывод схемы адресных пространств,
вывод дерева устройств и шин,
вывод трассы работы процессора и динамического двоичного транслятора TCG,
доступ к гостевой памяти и регистрам гостевого процессора,
и мн. др.

Доступных методов достаточно для обнаружения неисправности.
Самый полезный из них --- отладка процесса эмулятора.
Но при этом он слишком общий.
GDB --- универсальный отладчик: он ориентирован на отладку
произвольного приложения.
Поэтому он не имеет какой-то специальных средств для отладки именно QEmu.
Эта особенность отчасти компенсируется встроенным интерпретатором Python.
В исходном коде эмулятора присутствуют скрипты, добавляющие отладочные
команды, выводящие дерево памяти и информацию о сопрограммах ввода-вывода
блочных устройств.
В ходе данной работы таким способом был добавлен вывод таблицы TLB.
При разработке скрипта была выявлена существенная проблема в этом методе:
отсутствие возможности отладки самого скрипта.
Для обнаружения проблемной строки приходилось использовать метод двоичного
поиска.
Информацию об интересующих переменных скрипта также приходилось получать
с помощью трассировки значений.
Таким образом разработка сложного отладочного скрипта может оказаться
чрезвычайно трудозатратной.
Подобная ситуация справедлива и при использовании интегрированных сред
разработки (IDE): они реализуют графический интерфейс к отладчику, но не делают
его специализированным.

Другие методы сбора информации о VM часто или недостаточно подробные
(карта памяти, дерево устройств), или слишком узкоспециализированные
(трассировка TCG, отладка гостевого ПО).
Поэтому их часто оказывается недостаточно, и всё-равно приходится прибегать к
отладке эмулятора.

Главной проблемой отладки является её трудоёмкость.
Для решения этой проблемы предлагается использовать автоматизацию.
Ранее были проведены работы по автоматизации начального этапа разработки VM
[[$](#ref.QDTCommon),[$](#ref.QDTRegisters)].
Побочным продуктом разработанной в течение тех работ инфраструктуры
(QEmu Development Toolkit --- QDT) является расширенная информация о VM,
которую можно использовать при отладке этой VM.
То есть разработанное в данной работе средство является расширением для QDT.

Таким образом, целью данной работы является автоматизация отладки
виртуальной вычислительной машины в эмуляторе QEmu.

Несмотря на доступность дополнительной информации о VM из QDT, главным
приоритетом разрабатываемого инструмента является независимость от этой
информации.
Максимум информации, необходимой для работы инструмента, будет браться из
исходного кода главной ветки QEmu.
Таким образом, инструмент можно будет применить и к VM, разработанной
классическим способом, хотя и с ограниченной функциональностью.

# $. Программно управляемая отладка

Автоматизация отладки невозможна без предоставления отладчиком API,
реализующего основные отладочные примитивы:

- постановка точек останова по управлению (breakpoint) и по доступу к памяти
(watchpoint);
- доступ к регистрам процессора и памяти отлаживаемого процесса.

Кроме этого процессы часто создают параллельно работающие нити (в том
числе и QEmu).
При этом к каждой нити данные отладочные примитивы применяются независимо.
В то время как одна нить остановлена на точке останова, другие продолжают
выполняться.
Этот режим работы называется неблокирующим.
Главным образом он позволяет снизить вносимое отладчиком замедление.
API, в свою очередь, должен поддерживать индивидуальное управление нитями.

Однако этих примитивов не достаточно для отладки программы в символах исходного
кода, т.к. они оперируют низкоуровневыми сущностями: адрес, байт, регистр,
нить и т.д.

То есть, от API отладчика требуются дополнительные возможности:

- получение адреса машинной инструкции для точки останова
по файлу и номеру строки
или
по имени функции (а иногда бывает удобно по относительному номеру строки
в функции),
- идентификация номера строки или функции по адресу (в частности, по текущему
значению указателя команд);
- доступ к глобальным и локальным переменным по строковому имени (в разные
моменты они могут находиться как в памяти, так и на регистре);
- использование информации о типах для доступа
к полям структур (и прочих контейнеров) по имени или
к элементам массивов по индексу;
- раскрутка стека вызовов функций.

Реализация этих возможностей требует от отладчика анализа отладочной
информации, генерируемой компилятором.

GDB Python API предоставляет все требуемые возможности, но как уже отмечалось,
написание отладочных скриптов для него затруднено отсутствием возможности
отладки самих скриптов.
Данным недостатком не будет обладать реализация отладочного API в формате
модуля Python для обычного интерпретатора.
В открытых источниках было обнаружено несколько проектов с похожим назначением.

## $.$ pygdb и API поверх GDB Machine Interface

Проект "pygdb" [[$](#ref.pygdb)] является реализаций отладчика, основанной на
системном вызове "ptrace".
Целью проекта является реализация возможностей, аналогичных GDB.
Однако в настоящее время проект является скорее тестовым прототипом, чем
готовым к использованию модулем.
Кроме этого он не поддерживает 64-битный режим.

Проекты "Python GDB MI Parser" [[$](#ref.python-gdb-mi)] и
"pygdbmi" [[$](#ref.pygdbmi)] реализуют API для работы с интерфейсом
"Machine Interface" (MI) GDB.
Данный интерфейс основывается на обмене сообщениями между клиентом
(GDB/MI frontend) и сервером (GDB).
Клиент отправляет команды, а сервер --- ответы на команды и уведомления.
Уведомления асинхронны, их появление может быть как косвенным следствием
выполнения команд (например, сообщение об остановке процесса на точке
останова), так и иметь независимые от клиента причины (например, содержать
данные, записанные процессом в стандартный поток вывода).
Обычно машинный интерфейс используется IDE для реализации графического
интерфейса для отладчика.

Несмотря на название, MI является достаточно высокоуровневым.
С одной стороны MI даёт полный доступ к возможностям GDB, что делает его
пригодным для программно управляемой отладки.
Однако есть две существенные особенности.

- Сообщения записываются в сложной грамматике, местами использующей
текстовой формат JSON.
Это удобно для анализа человеком, но в то же время делает обмен
данными избыточным, а разбор сообщений --- долгим.
- В сообщения от сервера часто включается информация, которая не
требуется клиенту в данный момент.
Например, вместе с номером сработавшей точки останова отсылается имя файла
(полное и относительное) и номер строки, имя функции.
В то же время, при задании точки останова клиент уже имеет информацию о том,
куда им была поставлена данная точка останова.
Таким образом, сервер тратит лишнее время на определение позиции и отправку
её клиенту, а тот, в свою очередь, --- за анализ информации, которая ему всё
равно не нужна.

При пользовании MI из графического интерфейса во время ручной отладки эти
особенности не важны, т.к. сообщений пересылается мало и пользователь не
заметит потерь производительности.
Но при программно управляемой отладке, когда в секунду отрабатывается
десятки-сотни
точек останова, и для каждой происходит получение информации времени
выполнения об отлаживаемом процессе, эти издержки заметно ограничивают
теоретический максимум быстродействия.

## $.$ API поверх GDB Remote Serial Protocol

Кроме MI, GDB поддерживает так называемый Remote Serial Protocol (RSP).
Данный протокол используется для отладки удалённых процессов по сети или при
отладке ПО для встраиваемых платформ.
Заметим, что QEmu реализует именно этот протокол для отладки гостевого ПО.

RSP --- расширяемый протокол, но он также определяет необходимый минимум,
который должен поддерживать сервер.
Этот минимум включает уже описанные выше постановку точек останова,
доступ к памяти и регистрам,
и управление нитями.
Он, аналогично MI, оперирует сообщениями, в которых пересылаются команды,
ответы и уведомления.
Формат этих сообщений по большей части текстовой.
Но команды часто идентифицируются всего 3 байтами, а аргументы плотно
упакованы.
Значения регистров и байтов преобразуются в строки в системе счисления с
основанием 16.
При этом предусмотрен контроль целостности, опционально отключаемый для
надёжных соединений на подобие сокетов, использующих TCP, или межпроцессных
каналов (pipe).
Выполнение данных преобразований избыточно, но накладных вычислений всё-равно
меньше, чем в случае MI.
Содержимое сообщений, отправляемых сервером лишено избыточной информации.
Для сравнения, уведомление о точке останова сопровождается идентификатором
нити и значениями указателей команд и стека.
Последний всегда необходим для доступа к локальным переменным функции.
У минимализма RSP есть и обратная сторона.
Поддержка отладочной информации и связанной с ней функциональности --- задача
клиента.

Модуль "pyrsp" [[$](#ref.pyrsp)] реализует API как для взаимодействия по
протоколу RSP, так и для работы с отладочной информацией в формате DWARF.
Последнее опирается на модуль "pyelftools" [[$](#ref.pyelftools)].
Эти два модуля были взяты за основу для разработки инструмента автоматизации
отладки QEmu.

В процессе работы выяснилось, что реализации обоих модулей не достаточно
полноценны, чтобы использовать их как есть.
"pyrsp" не поддерживал работу с несколькими нитями (неблокирующий режим).
Анализ отладочной информации был слишком примитивным и имел много допущений.
В частности корректно работать можно было только с исполняемыми файлами,
полученными из одного модуля компиляции.
Полностью отсутствовала работа с типами и значениями из отлаживаемого процесса,
как в GDB Python API.
"pyelftools" поддерживал большую часть базовых возможностей по разбору
отладочной информации из исполняемого ELF-файла.
Однако разбор всего файла QEmu занимал у него слишком много времени (порядка
нескольких минут).
Это обусловлено тем, что "pyelftools" спроектирован для анализа всего
содержимого ELF-файла разом.
Но для работы программно управляемого отладчика,
во-первых, не требуется вся информация,
во-вторых, она требуется не сразу, а по мере достижения определённого
состояния.

## $.$ Расширение возможностей pyrsp и pyelftools

Для решения обнаруженных проблем указанные модули были модифицированы следующим
образом.

В "pyelftools" были реализованы ленивый анализ и кэширование.
Суть ленивого анализа заключается в том, что он выполняется по запросу
извне для конкретных фрагментов отладочной информации.
Кроме этого реализация API pyelftools была изменена так, чтобы избежать
лишнего анализа в процессе поиска запрашиваемой информации.
В добавок к этому кэширование помогает избежать повторных поиска и анализа
ранее запрашиваемых данных.

# Заключение

# Использованные источники

$. <a name="ref.QDTCommon"></a>QDT Common

$. <a name="ref.QDTRegisters"></a>QDT Device Registers

$. <a name="ref.pygdb"></a>Minimal C Debugger in Python.
   https://github.com/theicfire/pygdb

$. <a name="ref.pyrsp"></a>pyrsp.
   https://github.com/stef/pyrsp

$. <a name="ref.python-gdb-mi"></a>Python GDB MI Parser.
   https://github.com/hydra-dbg/python-gdb-mi

$. <a name="ref.pygdbmi"></a>pygdbmi - Get Structured Output from GDB's
   Machine Interface.
   https://github.com/cs01/pygdbmi

$. <a name="ref.pyelftools"></a>pyelftools.
   https://github.com/eliben/pyelftools

