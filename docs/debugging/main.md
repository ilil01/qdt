---
title: |
  Пример
author:
- Автор
tags: []
abstract: |
  **Аннотация**

  *ТУДУ*

  **Ключевые слова**:
  ТУДУ,
  ТУДУ.
...

# Введение

При разработке новой виртуальной вычислительной машины программист
неизбежно сталкивается с ситуацией, когда она ведёт себя не так, как он ожидает.
Причины этого бывают самые разные:
ошибка в реализации модели какого-то устройства,
неправильное соединение устройств между собой,
некорректная реализация гостевого программного обеспечения (ПО), используемого
для тестирования,
и т.д.
Часто это выглядит как
отсутствие каких-либо сообщений на устройствах ввода-вывода,
отказ (аварийное завершение процесса),
сообщение о сбое от гостевого ПО,
сообщение о неожиданном поведении гостевого ПО от модели устройства
и т.п.
В большинстве случаев для понимания неисправности от программиста требуется
сбор дополнительной информации.
При этом используется совокупность методов.

- Отладка процесса эмулятора.
В данном случае отслеживаются инициализация машины и её реакция на действия
гостевого ПО.
- Отладка гостевого ПО средствами эмулятора.
Тут наоборот, отслеживается реакция гостевого ПО на действия компонентов
машины.
- Использование отладочных возможностей инфраструктуры эмулятора, таких как
вывод схемы адресных пространств,
вывод дерева устройств и шин,
вывод трассы работы процессора и динамического двоичного транслятора TCG,
доступ к гостевой памяти и регистрам гостевого процессора,
и мн. др.

Доступных методов достаточно для обнаружения неисправности.
Самый полезный из них --- отладка процесса эмулятора.
Но при этом он слишком общий, универсальный.
Самым популярным отладчиком в данном случае является GNU Debugger (GDB).
GDB --- универсальный отладчик: он ориентирован на отладку
произвольного приложения.
Поэтому он не имеет какой-то специальных средств для отладки именно QEmu.
Специализированных отладчиков не обнаружено.
Ситуация отчасти компенсируется встроенным интерпретатором Python.
В исходном коде эмулятора присутствуют скрипты, добавляющие отладочные
команды, выводящие дерево памяти и информацию о сопрограммах ввода-вывода
блочных устройств.
В ходе данной работы таким способом был добавлен вывод таблицы TLB.
При разработке скрипта была выявлена существенная проблема в этом методе:
отсутствие возможности отладки самого скрипта.
Для обнаружения проблемной строки приходилось использовать метод двоичного
поиска.
Информацию об интересующих переменных скрипта приходилось получать
с помощью трассировки значений.
Таким образом, разработка сложного отладочного скрипта может оказаться
чрезвычайно трудозатратной.
Подобная ситуация справедлива и при использовании интегрированных сред
разработки (IDE): они реализуют графический интерфейс к отладчику, но не делают
его специализированным.

Другие методы сбора информации о машине или недостаточно подробные
(карта памяти, дерево устройств), или слишком узкоспециализированные
(трассировка TCG, отладка гостевого ПО).
Поэтому их часто оказывается недостаточно, и всё-равно приходится прибегать к
отладке эмулятора.

Всё это приводит к трудоёмкости отладки.
Ввиду этого предлагается использовать автоматизацию.
Ранее были проведены работы по автоматизации начального этапа разработки
виртуальной машины
[[$](#ref.QDTCommon), [$](#ref.QDTRegisters)].
Побочным продуктом разработанной в течение тех работ инфраструктуры
(QEmu Development Toolkit --- QDT) является расширенная информация о
сгенерированном автоматически коде
машины,
которую можно использовать во время отладки машины.
То есть разработанное в данной работе средство является расширением для QDT.

Таким образом, целью данной работы является автоматизация отладки
виртуальной вычислительной машины в эмуляторе QEmu.

Несмотря на доступность дополнительной информации о коде машины из QDT, главным
приоритетом разрабатываемого инструмента является независимость от этой
информации.
Максимум информации, необходимой для работы инструмента, будет браться из
исходного кода главной ветки QEmu.
Таким образом, инструмент можно будет применить даже к машине, разработанной
классическим способом, хотя и с ограниченной функциональностью.

# $. Программно управляемая отладка

Программно управляемая отладка заключается в расстановке точек останова на
интересующих разработчика позициях и выполнении определённых действий
программным способом.
Для этого скрипт назначает для точек останова функции обратного вызова.
Это требует от отладчика API, реализующего основные отладочные примитивы:

- постановка точек останова по управлению (breakpoint) и по доступу к памяти
(watchpoint);
- доступ к регистрам процессора и памяти отлаживаемого процесса.

Процессы (в том числе и QEmu) часто создают параллельно работающие нити.
К каждой нити данные отладочные примитивы применяются независимо.
В то время как одна нить остановлена на точке останова, другие продолжают
выполняться.
Этот режим работы называется неблокирующим.
Главным образом он позволяет снизить вносимое отладчиком замедление.
API, в свою очередь, должен поддерживать индивидуальное управление нитями.

Однако этих примитивов не достаточно для отладки программы в символах исходного
кода, т.к. они оперируют низкоуровневыми сущностями: адрес, байт, регистр,
нить и т.д.

То есть, от API отладчика требуются дополнительные возможности:

- получение адреса машинной инструкции для точки останова
по файлу и номеру строки
или
по имени функции (а иногда бывает удобно по относительному номеру строки
в функции),
- идентификация номера строки или функции по адресу (в частности, по текущему
значению указателя команд);
- доступ к глобальным и локальным переменным по строковому имени (в разные
моменты они могут находиться как в памяти, так и на регистре);
- использование информации о типах для доступа
к полям структур (и прочих контейнеров) по имени или
к элементам массивов по индексу;
- восстановление стека вызовов функций.

Реализация этих возможностей требует от отладчика анализа отладочной
информации, генерируемой компилятором.

GDB Python API предоставляет все требуемые возможности, но как уже отмечалось,
написание отладочных скриптов для него затруднено отсутствием возможности
отладки самих скриптов.
Данным недостатком не будет обладать реализация отладочного API в формате
модуля Python для обычного интерпретатора.
В открытых источниках было обнаружено несколько проектов с похожим назначением.

## $.$ pygdb и API поверх GDB Machine Interface

Проект "pygdb" [[$](#ref.pygdb)] является реализаций отладчика, основанной на
системном вызове "ptrace".
Целью проекта является реализация возможностей, аналогичных GDB.
Однако в настоящее время проект является скорее тестовым прототипом, чем
готовым к использованию модулем.
Кроме этого, он не поддерживает 64-битный режим, в котором обычно работает
эмулятор.

Проекты "Python GDB MI Parser" [[$](#ref.python-gdb-mi)] и
"pygdbmi" [[$](#ref.pygdbmi)] реализуют API для работы с интерфейсом
"Machine Interface" (MI) GDB.
Данный интерфейс основывается на обмене сообщениями между клиентом
(GDB/MI frontend) и сервером (GDB).
Клиент отправляет команды, а сервер --- ответы на команды и уведомления.
Уведомления асинхронны, их появление может быть как косвенным следствием
выполнения команд (например, сообщение об остановке процесса на точке
останова), так и иметь независимые от клиента причины (например, содержать
данные, записанные процессом в стандартный поток вывода).
Обычно машинный интерфейс используется IDE для реализации графического
интерфейса для отладчика.

Несмотря на название, MI является достаточно высокоуровневым.
Он даёт полный доступ к возможностям GDB, что делает его
пригодным для программно управляемой отладки.
Однако есть две существенные особенности.

- Сообщения записываются в сложной грамматике, местами использующей
текстовой формат JSON.
Это удобно для анализа человеком, но, в то же время, это делает обмен
данными избыточным, а разбор сообщений --- долгим.
- В сообщения от сервера часто включается информация, которая не
требуется клиенту в данный момент.
Например, вместе с номером сработавшей точки останова отсылаются имена файла
(с путём и без) и номер строки, а также имя функции.
В то же время, при задании точки останова клиент уже имеет информацию о том,
куда им была поставлена данная точка останова.
Таким образом, сервер тратит лишнее время на определение позиции и отправку
её клиенту, а тот, в свою очередь, --- за анализ информации, которая ему всё
равно не нужна.

При пользовании MI из графического интерфейса во время ручной отладки эти
особенности не важны, т.к. сообщений пересылается мало и пользователь не
заметит потерь производительности.
Но при программно управляемой отладке, когда в секунду отрабатывается
десятки-сотни
точек останова, и для каждой происходит получение информации времени
выполнения об отлаживаемом процессе, эти издержки заметно ограничивают
теоретический максимум быстродействия.

## $.$ API поверх GDB Remote Serial Protocol

Кроме MI, GDB поддерживает так называемый Remote Serial Protocol (RSP).
Данный протокол используется для отладки удалённых процессов по сети или при
отладке ПО для встраиваемых платформ.
Заметим, что QEmu реализует именно этот протокол для отладки гостевого ПО.

RSP --- расширяемый протокол, но он также определяет необходимый минимум,
который должен поддерживать сервер.
Этот минимум включает уже описанные выше постановку точек останова,
доступ к памяти и регистрам,
и управление нитями.
Он, аналогично MI, оперирует сообщениями, в которых пересылаются команды,
ответы и уведомления.
Формат этих сообщений по большей части текстовой.
Но команды часто идентифицируются всего 3 байтами, а аргументы плотно
упакованы.
Значения регистров и байтов преобразуются в строки в системе счисления с
основанием 16.
При этом предусмотрен контроль целостности, опционально отключаемый для
надёжных соединений на подобие сокетов, использующих TCP.
Выполнение данных преобразований избыточно, но накладных вычислений всё равно
меньше, чем в случае MI.
Содержимое сообщений, отправляемых сервером лишено избыточной информации.
Для сравнения, уведомление о точке останова сопровождается идентификатором
нити и значениями указателей команд и стека.
Последний всегда необходим для доступа к локальным переменным функции.
У минимализма RSP есть и обратная сторона.
Поддержка отладочной информации и связанной с ней функциональности --- задача
клиента.

Модуль "pyrsp" [[$](#ref.pyrsp)] реализует API как для взаимодействия по
протоколу RSP, так и для работы с отладочной информацией в формате DWARF.
Последнее опирается на модуль "pyelftools" [[$](#ref.pyelftools)].
Эти два модуля были взяты за основу для разработки инструмента автоматизации
отладки QEmu.

В процессе работы выяснилось, что реализации обоих модулей не достаточно
полноценны, чтобы использовать их как есть.
"pyrsp" не поддерживал работу с несколькими нитями (неблокирующий режим).
Анализ отладочной информации был слишком примитивным и имел много допущений.
В частности корректно работать можно было только с исполняемыми файлами,
полученными из одного модуля компиляции.
Полностью отсутствовала работа с типами и значениями из отлаживаемого процесса,
как в GDB Python API.
"pyelftools" поддерживал большую часть базовых возможностей по разбору
отладочной информации из исполняемого ELF-файла.
Однако разбор всего файла QEmu занимал у него слишком много времени (порядка
нескольких минут).
Это обусловлено тем, что "pyelftools" спроектирован для анализа всего
содержимого ELF-файла разом.
Но для работы программно управляемого отладчика,
во-первых, не требуется вся информация,
во-вторых, она требуется не сразу, а по мере достижения определённого
состояния.

## $.$ Расширение возможностей pyrsp и pyelftools

Для решения обнаруженных проблем указанные модули были модифицированы следующим
образом.

В "pyelftools" были реализованы ленивый анализ и кэширование.
Суть ленивого анализа заключается в том, что он выполняется по запросу
извне для конкретных фрагментов отладочной информации.
Кроме этого, реализация API pyelftools была изменена так, чтобы избежать
лишнего анализа в процессе поиска запрашиваемой информации.
Вдобавок, кэширование помогает избежать повторных поиска и анализа
ранее запрашиваемых данных.
Ещё была добавлена поддержка форматов таблиц быстрого поиска имён
и типов ".debug_pubnames" и ".debug_pubtypes".

Модуль "pyrsp" был сильно переработан.
Ниже приводятся основные изменения.

- Реализовано независимое управления нитями удалённого процесса.
- Поддержан неблокирующий режим.
Без него независимое управление нитям не имеет смысла.
- Добавлена поддержка уведомлений.
В неблокирующем режиме посредством уведомлений клиенту передаётся информация об
остановках нитей.
Проясним, что в блокирующем режиме клиент уведомляется об остановках
посредством ответа на команду продолжения выполнения.
То есть, ответ ожидается клиентом до тех пор, пока не будет достигнута
какая-либо точка останова.
В неблокирующем режиме посредством ответа клиент только уведомляется о факте
возобновления выполнения конкретной нити.
Это обычно происходит сразу.
- Реализована поддержка установки нескольких обратных вызовов на одну точку
останова.
Данная возможность особенно важна, когда с отлаживаемым процессом работают
несколько скриптов, не знающих друг про друга, но наблюдающих за одним и тем же
кодом.

Поверх модифицированных модулей "pyelftools" и "pyrsp" было реализовано
API для работы со значениями из отлаживаемого процесса на уровне символов
исходного кода.
Это API условно можно разделить на статическую часть, работающую поверх только
"pyelftools", и динамическую, использующую активную сессию отладки через
"pyrsp".
Статическая часть реализует работу с типами, получение точек останова по
позиции в файле, идентификация позиции в функции по адресу и др.
Динамическая часть отвечает за получение данных из отлаживаемого процесса.
При этом данные обрабатываются в терминах исходного кода (переменная,
поле структуры, функция, строка), для чего активно используется статическая
часть.

Стоит заметить, что реализованное API создаётся похожим на GDB Python API
(насколько это возможно).
В идеале это дало бы возможность переиспользовать код скриптов для GDB.
В настоящее время эта возможность не доступна в полной мере.
Кроме этого остаются нереализованными многие другие возможности, такие как
изменение значений отлаживаемого процесса, вызов функций и др.
Тем не менее, проект продолжает развиваться, и данные возможности будут
добавляться по мере надобности.

## $.$ Поддержка изменений исходного кода

В условиях непрерывного развития проекта позиции точек останова,
зафиксированные в отладочных скриптах, быстро становятся недействительными.
Даже небольшое изменение не относящегося к некоторой позиции кода, но
расположенного выше неё, приводит к смещению номера строки.
Это часто даже не приводит к сообщению об ошибке, т.к. смещённая позиция всё
равно соответствует какому-то коду.
То есть, некоторая часть скрипта начинает работать неадекватно, и разработчик
даже может это не сразу заметить.

Эта особенность была учтена в разработанном API.
Реализация автоматически контролирует актуальность позиций точек останова с
использованием информации из системы контроля версий Git.
Позиция в файле может быть сопровождена SHA1
идентификатором версии, для которой она актуальна.
Для каждой позиции инструмент сравнивает текущую версию кода с версией,
указанной для этой позиции.
Если изменения произошли ниже интересующей позиции, то они игнорируются.
Если --- выше, то корректируется номер строки.
Заметим, что Git оперирует изменениями с точностью до строки: для каждого
изменения указано, сколько строк было удалено, а сколько --- добавлено.
Изменение в строке описывается как удаление старой строки и добавление новой.
Таким образом, нетрудно вычислить разницу в номере интересующей позиции.

Важным параметром является окрестность позиции.
Дело в том, что не только изменение самой строки может сделать позицию не
адекватной.
Многие строки взаимосвязаны по смыслу.
Поиск метода доказательной проверки адекватности позиции с учётом изменений во
всём коде выходит за рамки данной работы.
Но принято допущение, что изменения в некоторой небольшой окрестности
следует считать стоящими внимания разработчика.
Окрестность выбирается в несколько строк.
Разработчик имеет возможность указать интервал, изменениям строк в котором
следует уделить особое внимание в будущем.
Очевидно, что чем больше интервал, тем больше будет ложноположительных
срабатываний.
При обнаружении важных изменений от разработчика скрипта требуется указать
новую позицию или подтвердить старую.
Это делается путём указания SHA1 идентификатора версии, соответствующей
изменению.

# $. Автоматизированная отладка QEmu

Рассмотрим применение программного управления к отладке QEmu.

## $.$ Восстановление дерева типов QOM

Для описание различных сущностей в QEmu применяется реализованная на Си
объектно-ориентированная модель с динамической типизацией ---
QEMU Object Model (QOM).
С точки зрения отладки, сложность заключается в том, что дерево типов строится
динамически, путём выполнения кода при старте эмулятора.
Теоретически, дерево можно было бы восстановить с помощью статического анализа
кода, но это --- тема отдельного исследования.
Высокоуровневым скриптам необходима информация о дереве QOM для различения
объектов (специальная обработка для шин, устройств, прерываний и т.д.),
выбора правильного определения структуры для интерпретации данных в памяти и
т.д.

Восстановление дерева QOM осуществляется путём расстановки точек останова в
местах регистрации и инициализации типов, а также соответствующих им классов
(это --- разные вещи в QOM).
При этом,
сохраняются адреса структур в куче,
запоминаются строковые идентификаторы,
по указателям на родительские типы восстанавливается дерево типов
и т.д.

Особое внимание уделено восстановлению способа интерпретации данных.
Дело в том, что наследование в QOM осуществляется путём добавление в начало
структуры дочернего класса структуры родительского.
Так объект дочернего класса содержит в себе поля всех предков.
В зависимости от желания разработчика, один объект может быть удобно
интерпретировать с использованием разных определений структур.
Автоматическое установления перечня структур, пригодных для интерпретации
объектов какого-либо типа, может быть сделано по-разному.
В QEmu принято писать код, работающий с разными интерпретациями объекта так,
чтобы для каждой интерпретации создавалась отдельная переменная
соответствующего типа.
Поэтому, в данной работе применена следующая эвристика.
Ставится точка останова на выход из функции, для которой известно, что
некоторый аргумент указывает на интересующий объект.
В момент остановки проверяются все локальные переменные, и у тех из них,
которые указывают на данный объект, запоминаются типы.

Данное действие можно было бы выполнить и с помощью статического анализа, но
не стоит забывать, что при приведении типов может быть использован макрос и/или
вызвана проверочная функция.
Т.е. статический подход тоже не тривиален.

## $.$ Восстановление состава машины

# Заключение

# Использованные источники

$. <a name="ref.QDTCommon"></a>QDT Common

$. <a name="ref.QDTRegisters"></a>QDT Device Registers

$. <a name="ref.pygdb"></a>Minimal C Debugger in Python.
   https://github.com/theicfire/pygdb

$. <a name="ref.pyrsp"></a>pyrsp.
   https://github.com/stef/pyrsp

$. <a name="ref.python-gdb-mi"></a>Python GDB MI Parser.
   https://github.com/hydra-dbg/python-gdb-mi

$. <a name="ref.pygdbmi"></a>pygdbmi - Get Structured Output from GDB's
   Machine Interface.
   https://github.com/cs01/pygdbmi

$. <a name="ref.pyelftools"></a>pyelftools.
   https://github.com/eliben/pyelftools

