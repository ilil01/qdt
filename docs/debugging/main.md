---
title: |
  Пример
author:
- Автор
tags: []
abstract: |
  **Аннотация**

  *ТУДУ*

  **Ключевые слова**:
  ТУДУ,
  ТУДУ.
...

# Введение

При разработке новой виртуальной вычислительной машины (VM) программист
неизбежно сталкивается с ситуацией, когда VM ведёт себя не так, как он ожидает.
Причины этого бывают самые разные:
ошибка в реализации модели какого-то устройства,
неправильное соединение устройств между собой,
некорректная реализация гостевого программного обеспечения (ПО), используемого
для тестирования,
и т.д.
Часто это выглядит как отсутствие какой-либо реакции со стороны VM,
отказ (аварийное завершение процесса),
сообщение о сбое от гостевого ПО,
сообщение о неожиданном поведении гостевого ПО от модели устройства
и т.п.
В большинстве случаев для понимания неисправности от программиста требуется
сбор дополнительной информации.
При этом используется совокупность методов.

- Отладка процесса эмулятора.
При этом отслеживаются инициализация VM и её реакция на действия гостевого ПО.
- Отладка гостевого ПО средствами эмулятора.
Тут наоборот, отслеживается реакция гостевого ПО на действия компонентов VM.
- Использование отладочных возможностей инфраструктуры эмулятора, таких как
вывод схемы адресных пространств,
вывод дерева устройств и шин,
вывод трассы работы процессора и динамического двоичного транслятора TCG,
доступ к гостевой памяти и регистрам гостевого процессора,
и мн. др.

Доступных методов достаточно для обнаружения неисправности.
Самый полезный из них --- отладка процесса эмулятора.
Но при этом он слишком общий.
GDB --- универсальный отладчик: он ориентирован на отладку
произвольного приложения.
Поэтому он не имеет какой-то специальных средств для отладки именно QEmu.
Эта особенность отчасти компенсируется встроенным интерпретатором Python.
В исходном коде эмулятора присутствуют скрипты, добавляющие отладочные
команды, выводящие дерево памяти и информацию о сопрограммах ввода-вывода
блочных устройств.
В ходе данной работы таким способом был добавлен вывод таблицы TLB.
При разработке скрипта была выявлена существенная проблема в этом методе:
отсутствие возможности отладки самого скрипта.
Для обнаружения проблемной строки приходилось использовать метод двоичного
поиска.
Информацию об интересующих переменных скрипта также приходилось получать
с помощью трассировки значений.
Таким образом разработка сложного отладочного скрипта может оказаться
чрезвычайно трудозатратной.
Подобная ситуация справедлива и при использовании интегрированных сред
разработки (IDE): они реализуют графический интерфейс к отладчику, но не делают
его специализированным.

Другие методы сбора информации о VM часто или недостаточно подробные
(карта памяти, дерево устройств), или слишком узкоспециализированные
(трассировка TCG, отладка гостевого ПО).
Поэтому их часто оказывается недостаточно, и всё-равно приходится прибегать к
отладке эмулятора.

Главной проблемой отладки является её трудоёмкость.
Для решения этой проблемы предлагается использовать автоматизацию.
Ранее были проведены работы по автоматизации начального этапа разработки VM
[[$](#ref.QDTCommon),[$](#ref.QDTRegisters)].
Побочным продуктом разработанной в течение тех работ инфраструктуры
(QEmu Development Toolkit --- QDT) является расширенная информация о VM,
которую можно использовать при отладке этой VM.
То есть разработанное в данной работе средство является расширением для QDT.

Таким образом, целью данной работы является автоматизация отладки
виртуальной вычислительной машины в эмуляторе QEmu.

Несмотря на доступность дополнительной информации о VM из QDT, главным
приоритетом разрабатываемого инструмента является независимость от этой
информации.
Максимум информации, необходимой для работы инструмента, будет браться из
исходного кода главной ветки QEmu.
Таким образом, инструмент можно будет применить и к VM, разработанной
классическим способом, хотя и с ограниченной функциональностью.

# $. Программная отладка

Автоматизация отладки невозможна без предоставления отладчиком API,
реализующего основные отладочные примитивы:

- постановка точек останова по управлению (breakpoint) и по доступу к памяти
(watchpoint);
- доступ к регистрам процессора и памяти отлаживаемого процесса.

Кроме этого процессы часто создают параллельно работающие нити (в том
числе и QEmu).
При этом к каждой нити данные отладочные примитивы применяются независимо.
В то время, как одна нить остановлена на точке останова, другие продолжают
выполняться.
Этот режим работы называется неблокирующим.
Главным образом он позволяет снизить вносимое отладчиком замедление.
API, в свою очередь, должен поддерживать индивидуальное управление нитями.

Однако этих примитивов не достаточно для отладки программы в символах исходного
кода, т.к. они оперируют низкоуровневыми сущностями: адрес, байт, регистр,
нить и т.д.

То есть, от API отладчика требуются дополнительные возможности:

- получение адреса машинной инструкции для точки останова
по файлу и номеру строки
или
по имени функции (и, иногда бывает удобно, по относительному номеру строки
в функции),
- идентификация номера строки или функции по адресу (в частности, по текущему
значению счётчика команд);
- доступ к глобальным и локальным переменным по строковому имени (в разные
моменты они могут находиться как в памяти, так и на регистре);
- использование информации о типах для доступа
к полям структур (и прочих контейнеров) по имени или
к элементам массивов по индексу;
- раскрутка стека вызовов функций.

Реализация этих возможностей требует от отладчика анализа отладочной
информации, генерируемой компилятором.

# Заключение

# Использованные источники

$. <a name="ref.QDTCommon"></a>QDT Common

$. <a name="ref.QDTRegisters"></a>QDT Device Registers

