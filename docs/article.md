[//]: # (pandoc article.md --standalone --smart -o article.docx -o article.html)

# Автоматизация разработки моделей устройств и вычислительных машин для QEMU

## Обозначения и сокращения

* API Application programming interface
* BAR Base address registers
* CD Compact disc
* CLI Command line interface
* IRQ Interrupt request
* MMIO Memory mapped input/output
* MSI Message signalled interrupt
* PCI Peripheral component interconnect
* QOM QEMU object model
* ROM Read-only memory
* SHA1 Secure Hash Algorithm 1
* TAP ?
* UDP User datagram protocol
* USB Universal serial bus
* АСД абстрактное синтаксическое дерево
* ВМ вычислительная машина
* ГИ графический интерфейс
* НЖМД накопитель на жестком магнитном диске
* ООП объектно-ориентированное программирования
* ОС операционная система
* ПЗУ постоянное запоминающее устройство
* УАПП универсальный асинхронный приёмо-передатчик

## Аннотация
## Введение

### Ручной подход

Используемый в настоящее время подход к реализации моделей для QEMU
заключается в поиске похожей функциональности в существующих моделях и
реализации требуемой по образу и подобию. При этом применяется обычное
копирование кода, с последующими его правками и дополнениями. С опытом
всё большую часть кода можно писать по памяти, но нужно следить за
изменениями в QEMU.

### Определение типа QOM
<a name=QOM_type_definition></a>

Минимальный код, который должен быт написан, чтобы встроить
новую модель в инфраструктуру QEMU включает в себя:

* инициализацию структуры `TypeInfo`, где должны быть указаны
строковые имена родительского класса и класса добавляемой модели;

* функцию-конструктор `register_types` модуля, вызывающую
`type_register_static` для всех `TypeInfo` в модуле;

* макроподстановку `type_init`, указывающую компилятору, что
`register_types` является конструктором модуля: её следует вызвать
неявно;

* правило в `Makefile`, регистрирующее модуль в системе сборки.

Добавленная таким образом модель не будет обладать никакой
функциональностью. Если класс родителя _абстрактный_, то модель даже
нельзя будет создать.

Реальный код чаще всего реализует, среди прочего, следующее.

* Структура, описывающая объекты своего класса (далее
_структура объекта_). В ней _первым_ полем обязательно присутствует
структура объекта родительского класса.

* Информация о размере структуры объекта.

* Функция инициализации структуры объекта.
При создании объекта класса модели выделяется область памяти,
указанного размера. Затем к ней в порядке наследования применяются
функции инициализации. В ООП такие функции (_методы_) называются
_конструкторами_.

* Структура, описывающая класс в целом (далее _структура класса_).
Она, аналогично, содержит _первым_ полем структуру класса родителя,
сопровождается информацией о её размере и функцией инициализации
(_конструктором класса_ в ООП).

Таким образом QEMU, на языке Си реализует объектно-ориентированную
парадигму программирования для моделирования платформ, устройств и
сопряжённых _сущностей_. Предназначение описанных контейнеров данных
и функций аналогично принятому в ООП.

Согласно принятым в QEMU правилам написания кода, все описанные выше
структуры, функции, строковые константы и т.д. имеют в своём названии
имя типа объекта. Оно принимает различные формы, в том числе, чтобы
быть синтаксически корректным. Далее по тексту, для ссылок на типы
будут использоваться имена структур классов.
<!-- Если тип не имеет собственной структуры, то будет выбран любой
доступный способ однозначной ссылки на тип. -->

### Определение модели устройства

Тип модели устройства должен быть потомком типа `DeviceClass`.
Этот тип предусматривает, что код устройства может реализовывать
следующее:

* объявление _свойств устройства_;

* объявление функции _реализации_ устройства;

* объявление _состояния устройства_.

Свойство устройства --- это поле
структуры объекта, доступное по строковому имени путём вызова
специальных функций. Свойство является константным начальным значением,
т.е. оно задается во время создания устройства и не может быть изменено
впоследствии.
Объявление свойств осуществляется следующим образом.

*  Определение массива структур типа `Property` при помощи
макросов вида `DEFINE_PROP_*`, указывающих строковое имя,
тип, поле структуры объекта и, в некоторых случаях, значение
по умолчанию (в остальных случаях значение по умолчанию
фиксировано API QEMU.

* Определение в заголовочном файле устройства макросов со
строковыми именами свойств (требование стиля программирования).

* Инициализация поля `props` структуры класса указателем на
массив свойств (т.е. на первый элемент). Данное поле предусмотрено
в типе `DeviceClass` (т.е. осуществляется его _перегрузка_).
Инициализация производится в конструкторе класса.

Функция реализации устройства выполняет "второй этап" инициализации
структуры объекта.
Наиболее яркий пример применения второго этапа --- свойства.
Причина этому следующая. Свойства не могут быть назначены, пока
не создано устройство. Устройство не может быть создано _до
конца_ пока не определены его свойства. Функция реализации
_доинициализирует_ устройство после определения его свойств.
Она регистрируется по указателю в поле `realize`, предусмотренным
в типе `DeviceClass`, конструктором класса.

Оболочка полей структуры устройства в свойства усложняет привычный
для Си способ определения начальных значений структуры, но
предоставляет следующие возможности:

* Прозрачное преобразование инвариантных строковых идентификаторов
объектов в указатели. Идентификаторы удобно использовать при
создании устройства. При написании кода ВМ это снимает с
программиста необходимость писать код, получающий указатели.
Код получается короче и понятнее.
Кроме того, только таким способом можно определить значение
свойства через CLI. Указатели же оптимизируют доступ к памяти
внутри реализации устройства.

* Контроль корректности значений.

В QEMU реализована возможность сохранения состояния ВМ в файл.
Сохранённое состояние называется _снимком_ (англ. _snapshot_).
Снимок ВМ включает в себя снимки её устройств. Поддержка данной
возможности требует, чтобы поведение модели устройства полностью
определялось значениями свойств и _состоянием_. Для объявления
своего состояния тип устройства определяет переменную типа
`VMStateDescription`, где указывает:

* перечень своих полей и их типов, которые влияют на поведение
модели (исключая свойства);

* строковое имя своего состояния;

* версию своего состояния.

Тип поля состояния определяет способ его сохранения и загрузки.
Версия используется для контроля использования сохранений,
сделанных прежними версиями модели устройства.

Для хранения указателя на описание состояния устройства в
в структуре класса типа `DeviceClass` предусмотрено поле
`vmsd`, инициализируемое конструктором класса.

### Определение модели вычислительной машины

Новая модель вычислительной машины должна быть потомком _абстрактного_
класса `MachineClass`, который наследован от `ObjectClass`. Минимальный
код, определяющий ВМ должен содержат следующее.

* Функцию инициализации ВМ. Её не следует путать с конструктором объекта.
Основная задача функции инициализации ВМ --- создание элементов ВМ.
Она может быть пустой.

* Конструктор класса, регистрирующий функцию инициализации и определяющий
строковое имя ВМ, без которого инициализировать ВМ будет проблематично.

* Регистрацию нового типа QOM, как описано [выше](#QOM_type_definition).
Важной особенностью является то, что имя QOM типа ВМ должно иметь суффикс
`-machine`.

Основную часть кода ВМ составляет функция инициализации ВМ. В ней
инициализируются процессор, память, основные мосты, периферийные
устройства и т.д.

В отличие от устройств, для ВМ не предусмотрено удобное объявление
свойств. Однако свойства являются частью базового типа `ObjectClass`.
Чтобы добавит свойства в ВМ необходимо определить конструктор объекта,
которой объявит требуемые свойства. Конструктор в типе `MachineClass`
уже имеет ряд свойств, которых достаточно для большинства ВМ:

* `kernel`, `initrd` и `append`: используются если в функции
инициализации ВМ предусмотрена загрузка ядра ОС Linux;

* `firmware`: предусматривает загрузку микропрограммного обеспечения;

* `usb`: даёт возможность включить/выключить поддержку USB в ВМ; и др.

Реальная работоспособность этих свойств зависит от реализации функции
инициализации.

Кроме того, структура объекта ВМ, `MachineState`, содержит следующие
важные поля, не оформленные как свойства:

* `cpu_model`: имя QOM типа процессора;

* `ram_size`: объём установленной оперативной памяти.

Однако, функция инициализации может игнорировать и их: реальная
ВМ может существовать с фиксированной моделью процессора и объёмом
памяти.

## Подход к автоматизации

Условно код модели можно разделить на две части _индивидуальную_ и
_интерфейсную_.
Индивидуальная часть воплощает суть устройство в его программной реализации.
Именно эта часть определяет то как именно будет эмулироваться присутствие
конкретно этого устройства в системе; делает его модель особенной,
относительно других устройств, уникальной. При этом модель устройство является
частью инфраструктуры QEMU, и индивидуальная часть должна эмулировать
поведение устройства, используя
предоставленные посредством API QEMU возможности. В модели всегда можно
выделить часть кода
взаимодействующую с этим API, она и называется _интерфейсной_. То есть,
интерфейсная часть кода
служит связкой между кодом индивидуальной части модели и окружающей средой.

Индивидуальная часть обычно сформулирована на естественном языке в документации
на устройство. При этом отсутствует единый формат _формального_ описания,
которого бы придерживались производители.
Ввиду этого автоматизация разработки этой части весьма затруднительна и
выходит за рамки этой работы.

С другой стороны, интерфейсная часть всех устройств очень похожа. Отличия
заключаются, в основном, в перечне и количестве используемых моделью внешних
интерфейсов, а также в именах собственных, которые часто формируются из
названия модели устройства путём применения к нему формализованных правил,
сформулированных или _де-факто_ (в коде существующих устройств), или в
тексте из файла `CODING_STYLE`, описывающим принятый в проекте стиль
программирования.

Опираясь на формализуемость правил написания интерфейсной части можно
разработать программу, принимающую небольшое количество понятных параметров
и возвращающую компилируемый код-шаблон, реализующий минимальный функционал
и готовый к внесению в него индивидуальной логики вручную. Таким образом,
программист, ознакомившись с техническим описанием устройства, может
формально сформулировать перечень требуемых модели устройства интерфейсов
и, применив разработанный инструмент, приступить непосредственно к
реализации индивидуальной части.

Отдельно нужно сказать о вычислительных машинах. Хотя описания вычислительных
машин, аналогично устройствам, лишены формализма и единообразия, в QEMU
присутствует развитое API для интеграции устройств в единое целое (то есть в
ВМ).
Состав ВМ определяется функцией её инициализации, которая последовательно
создаёт все устройства и соединяет их воедино. В данной работе реализован
программный интерфейс, позволяющий описать состав ВМ и сгенерировать её
функцию инициализации. Интерфейс реализован на языке Python, поэтому описание
получается несколько короче, чем соответствующий ему генерированный код. Но
основное преимущество заключается в возможности написания графического
интерфейса, значительно повышающего наглядность и скорость описания ВМ. Таким
образом, отсутствие формализованного описания ВМ смягчается удобством
компоновки ВМ по этому описанию.

С помощью этого API можно формально описать полноценную ВМ. При этом
имеются следующие ограничения.

1. Устройства, входящие в ВМ, должны иметь интерфейсную часть реализованную в
полном соответствии с текущим подходом к встраиванию устрйоств.

2. Сформулированная машина сильна ограничена в настройке.

В QEMU присутствует ряд устройств, которые были реализованы еще до того, как
был выработан текущий подход к встраиванию устройств. На данный момент
не все из них были переписаны в соответствии с этим подходом. То есть они
реализуют свою индивидуальную часть в обход новейших возможностей API для
интерфейсной части.

Первое ограничение не существенно,
если преобладающая часть устройств ВМ реализуется вместе с ней по формальному
описанию. Такие устройства будут иметь совместимую интерфейсную часть. Если
же нужно использовать существующую модель устройства, то возможны следующие
варианты.

* Скорректировать реализацию устройства.

* Вписать код, выполняющий его подключение в ВМ, в функцию инициализации после
её генерации. Этот вариант существенно ограничивает возможности инструмента:

    * устройство должно будет подключаться к шине вручную;

    * если устройство --- мост, то и его шины должны будут подключаться также
вручную;

    * подключение прерываний придётся выполнять вручную;

    * в общем случае, отсутствие возможности сослаться на устройство из API
при проектировании устройства приведёт к снижению количества автоматизированной
работы.

Второе ограничение заключается в следующем.
Сгенерированная ВМ зафиксирована на уровне исходного кода. То есть, в
неё будет проблематично добавить новое устройстве и невозможно удалить
имеющееся. CLI QEMU поддерживает ряд ключей, динамически создающих
дополнительные устройства (например, можно подключить к шине PCI новую
функцию). Также часть параметров машины заведомо требуется от пользователя,
например, файл-образ ПЗУ (НЖМД, микросхема flash-памяти, CD, и т.п.),
оконечную точку УАПП (виртуальный терминал, файл, и т.п.), способ подключения
сетевого порта (TAP-адаптер, Ethernet по UDP и т.п.) и т.д.

### Метод шаблонов

Как уже отмечалось, код интерфейсной части всех устройств достаточно
единообразен, чтобы его можно было получить из некоторого набора строковых
заготовок, путём подстановки параметров.

Часто для одного интерфейса необходимо сгенерировать несколько фрагментов кода.
При этом фрагменты должны следовать в правильном порядке как относительно
друг друга, так и фрагментов других интерфейсов. Это требование следует из
синтаксиса языка Си. Например, если один из аргументов функции является
указателем на структуру, то сама структура должна быть объявлена выше.

Часть параметров одних шаблонов может быть связана с параметрами других
шаблонов. Например, функция инициализации устройства, является частью шаблона,
встраивающего устройство в иерархию типов QOM. Если же устройство имеет
регистр MMIO, то для него применяется другой шаблон. Но регистр должен быть
зарегистрирован в функции инициализации. А значит, имя переменной, описывающей
регистр, является параметром шаблона функции инициализации.

Символы API QEMU должны быть доступны в сгенерированных файлах. Для этого
нужно включить (директивой `#include`) соответствующие заголовочные файлы.
Список этих файлов может быть автоматически вычислен по перечню использованных
символов. При этом, код будет выглядеть лучше, если минимизировать список
заголовочных файлов.

Эти и другие тонкости учтены в модели, используемой системой. При этом нельзя
сказать, что она закончена, так как периодически обнаруживаются случаи,
требующие её модификацию. Здесь представлено описание модели, используемой
в текущей версии.

### Программный интерфейс модели QEMU

Значительная часть сложной системы взаимосвязей шаблонов может быть создана
автоматически. От пользователя требуется небольшое количество интуитивно
понятных параметров. Это достигается разработанным API, скрывающим от него
сложность взаимосвязи шаблонов. Пользователь настраивает генерацию кода
посредством ниже перечисленных классов.

Видимая пользователю иерархии классов построена по тому-же принципу, что и
иерархия классов QOM. Таким образом, он легко сможет сопоставить
соответствующие классы.

Реализована следующая иерархия классов.

* `QOMDescription`
    * `SysBusDeviceDescription`
    * `PCIExpressDeviceDescription`
    * `MachineNode`

`QOMDescription` является базовым классом. Он не предназначенный для
использования.

`SysBusDeviceDescription` описывает устройство на системной шине.

`PCIExpressDeviceDescription` описывает PCI устройство. PCI _устройство_
в QEMU соответствует одной _функции_ реального устройства. QEMU не моделирует
физические взаимодействия по шине. Поддержка MSI (а именно реакция на
запись сообщения в память) реализуется главным мостом, обычно являющимся
устройством на системной шине. Как следствие, и PCI, и PCI Express устройство
может быть описано через этот класс.

`MachineNode` описывает ВМ и входящие в её устройства.

Перечисленные классы выполняют роль контейнеров для параметров. При генерации
кода на основе этих параметров создаются классы внутреннего API,
непосредственно участвующего в генерации.

В то время как для описания устройств системной шины или PCI достаточно базовых
типов, для описания устройств, входящих в ВМ, требуется ещё одно дерево
классов. Причём в это дерево включает классы, описывающие то же самое, что и
перечисленные выше классы. А именно: устройства системной шины и PCI. Тем не
менее, они описывают эти устройства с разных точек зрения:

* первые содержат перечень использованных в модели устройства элементов API
  QEMU;
* вторые же описывают способ подключения устройств.

Поскольку часть элементов API QEMU способствуют единообразию подключения
устройств в машину, то вторые могут быть вычислены из первых. Однако это
является одним из направлений дальнейших исследований.

Совместно объекты этих классов образуют _проект_ (`QProject`): контейнер с
данными для генератора кода.

### Модель вычислительной машины

Содержимое ВМ описывается с использованием следующей иерархии классов.

* `Node`
    * `BusNode`
        * `SystemBusNode`
        * `PCIExpressBusNode`
        * `ISABusNode`
        * `IDEBusNode`
        * `I2CBusNode`
    * `DeviceNode`
        * `SystemBusDeviceNode`
        * `PCIExpressDeviceNode`
    * `IRQLine`
    * `IRQHub`
    * `MemoryNode`
        * `MemoryLeafNode`
            * `MemoryAliasNode`
            * `MemoryRAMNode`
            * `MemoryROMNode`

`Node` содержит уникальный идентификатор узла ВМ.

`BusNode` содержит все данные, необходимые чтобы описать шину любого типа. Все
дочерние классы конкретизируют эти данные. Они были введены для сокращения
объёма кода, необходимого для добавления шины вручную. При использовании
графического интерфейса это не актуально.

Большинство параметров шины определяют генерацию кода для шины этого типа. И
только следующие параметры определяют место шины в ВМ:

* ссылка на устройство-мост (родительское), контролирующее эту шину;
* ссылки на устройства, подключённые к шине (дочерние).

`DeviceNode` описывает параметры, присущие любому устройству:

* модель устройства (листовой тип в дереве типов QOM);
* ссылку на шину, к которой подключено это устройство (родительскую);
* ссылки на контролируемые (дочерние) шины, если устройство является мостом;
* список значений свойств устройства, как объекта QOM.
* ссылки на привязанные прерывания с параметрами их привязки.

`IRQLine` (линия) и `IRQHub` (концентратор) описывают распространение
прерываний между устройствами (ту его часть, которая по какой-то причине не
спрятана в шину). Концентратор прерываний используется в случаях, когда одно
прерывание должно быть доставлено в несколько устройств и/или может быть
получено из нескольких устройств (так как линия прерывания соединяет строго
два узла). Линия содержит информацию об _источнике_ и _приёмнике_ прерывания.
Причём для каждого конце, являющегося устройством, определены:

* ссылка на устройство;
* индекс порта прерывания в группе прерываний;
* имя группы прерываний.

Если концом является концентратор, то достаточно только ссылки.

Большую часть адресного пространства ВМ определяют сами устройства. В адресное
пространство входят MMIO и BAR (PCI) регистры устройств, блоки памяти ROM
устройств и т.д. Однако, такие диапазоны как адресное пространство PCI, RAM
и т.п. должны быть определены отдельно. Причём в некоторых случаях адресное
пространство PCI создаётся главным мостом, а в некоторых создаётся
функцией инициализации машины и передаётся мосту как параметр.

`MemoryNode` описывает интервал-контейнер, содержащий в себе другие интервалы
со смещением, относительно своего начала.

`MemoryLeafNode` (лист) является служебным промежуточным классом, запрещающим
добавлять интервалы в интервалы, не являющимися контейнерами.

`MemoryAliasNode` (псевдоним) используется, чтобы обеспечить доступ к
интервалу (или его отрезку) из другого адреса.

`MemoryRAMNode` и `MemoryROMNode` описывают непрерывный интервал эмулируемой
физической памяти. Причём `MemoryROMNode` нельзя менять.

Каждый из перечисленных классов, описывающих интервал памяти, имеет следующие
параметры:

* отладочное строковое имя;
* размер;
* смещение в контейнере и ссылку на него;
* допустимость перекрытия в пределах одного контейнера и приоритет для его
  разрешения;

`MemoryNode` _может_ иметь непустой список ссылок на детей, а
`MemoryAliasNode` _должен_ содержать смещение в пределах интервала, на который
он перенаправляет запросы к себе, и ссылку на него.

Каждый из перечисленных классов (включая потомков `QOMDescription`)
является контейнером для параметров. Их основные функции:

* хранение настроек пользователя,
* сохранение настроек в файл и обратно,
* взаимодействие с графическим интерфейсом.

### Формат файлов

Настройки генерации устройств и ВМ собраны в единый _проект_. Проект
описывается классом `QProject` (QEMU project). При работе с ГИ используется
его подкласс `GUIProject` (GUI project), дополнительно хранящий настройки
отображения.

Проект сохраняется в файл в текстовом формате, совместимым с синтаксисом
языка Python. Сохранённый проект представляет собой _почти_ корректную
программу на языке Python, результатом выполнения которой является
определение переменой ссылающейся на объект класса `QProject` (или
`GUIProject`, в случае ГИ), _эквивалентный_ объекту, сохранённому в
файл. Программа используется имена из пользовательского API. Генератор
файлов сохранений изначально разрабатывался таким образом, чтобы файлы
выводились в удобном для человека формате. В сгенерированной
программе отсутствуют инструкции импорта необходимых имён (это
возложено на загрузчик файла), поэтому программа не является корректной.

Под _эквивалентностью_ сохранённого и восстановленного объекта понимается:

* равенство значений простых типов в соответствующих атрибутах;
* каждый ссылочный атрибут в восстановленном объекте указывает на
объект эквивалентный тому, на который этот атрибут указывал в
сохранённом объекте (ссылки на `None` восстанавливаются как ссылки на
`None`).

При сохранении не гарантируются:

* равенство _незначащих_ пробельных символов;
* синтаксически не значащий порядок фрагментов кода (порядок определения
аргументов конструкторов со значениями по умолчанию, порядок
восстановления несвязанных объектов, и т.п.);
* сохранность комментариев, если таковые были внесены вручную в файл
проекта.

Данные особенности создают сложности при ручной работе с файлами проекта,
а также при хранении файлов с использованием системы контроля версий.
Решение этой проблемы является одним из направлений дальнейших исследований.

## Графический интерфейс

Все возможности инструмента доступны пользователю посредством API. Для
описания устройств и ВМ достаточно произвольного текстового редактора.
Однако применение ГИ, спроектированного _специально_ для работы с API,
имеет следующие преимущества.

* Исключены лексические ошибки в именах элементов API и синтаксические
ошибки, т.к. пользователь водит только значения параметров.

* Для многих значений параметров в QEMU определены макросы,
использование которых предпочтительней, согласно _хорошему тону
программирования_. ГИ интерфейс, проанализировав код QEMU, может
предоставить пользователю список доступных макросов, обычно применяемых
с данным типом параметра. Например, идентификатор PCI, родительский
тип QOM, свойство QOM и т.п.

* Исключены некоторые семантические ошибки (например, в ГИ не
предусмотрена возможность соединения линией прерывания двух шин, в то
время как пользователь волен написать всё, что угодно в текстовом
редакторе). Имеется возможность дополнить ГИ средствами поиска менее
очевидных семантических ошибок.

* Все доступные параметры сосредоточены в _виджетах_ с названиями на
естественном языке. В большинстве случаев знания QEMU достаточно, чтобы
понять суть параметра, не обращаясь к справочной информации.

* Интерпретация ВМ в виде схемы.

### Обратимые операции

Современный редактор должен предоставлять средства по работе с изменениям.
Минимальный перечень возможностей: _отмена_ и _повторение_. В разработанном
ГИ контроль изменений пользователя реализован с использованием абстракции
_обратимых операций_.

Обратимая операция содержит следующую информацию:

* данные, необходимые для осуществления действия;
* данные, необходимые для возврата к состоянию до осуществления действия;
* флаг завершённости операции;
* ссылки на предшествующие и последующие операции, позволяющие перемещаться
вдоль истории изменений;
* описание действия, выполняемого операцией, на естественном языке для
пользователя.

ГИ построен таким способом, что любые изменения в проекте должны
быть осуществлены через абстракцию "_трекер истории_" (`HistoryTracker`).
То есть, для выполнения действия ГИ создаёт операцию, добавляет её в
историю и даёт команду на выполнение трекеру. Данный процесс скрыт от
пользователя реализацией кнопки "_Применить_".

В памяти всегда присутствует состояние проекта, соответствующее перечню
выполненных операций. Поддержание этого соответствия --- задача трекера.
Действия по отмене и повторению операций выполняются с использованием его
методов.

<!--
Часто сделанная в прошлом операция не связана с операциями сделанными после
неё. Такая операция может быть отменена без отмены последующих операций.
Формально, в будущем не должно быть операций, _зависящих_ от отменяемой
операции. Операция называется зависящей от _предшествующей_ операции, если
предшествующая операция:
1. изменяет то, что операция потом изменяет повторно;
2. создаёт то, что операция потом использует (для выполнения своего
действия), изменяет или удаляет;
3. удаляет то, что операция потом создаёт.

Операция, изменяющая что-то перед его удалением, здесь считается
независимой относительно удаляющей с тем условием, что при отмене
изменяющей операции будут обновлены данные в удаляющей, т.к., очевидно,
что удаляющая операция содержит в себе последнюю копию утрачиваемых
данных удаляемого объекта.
-->

### Обратная связь при изменениях

Текущие значения параметров проекта влияют не только на значения,
представленные в виджетах. Они также могут влиять на:

* выбор типа виджета (тип свойства QOM объекта определяет, какой виджет
должен быть использован для представления его значения);
* существование виджета (при удалении узла ВМ должны исчезать
виджеты его редактирующие);
* перечень допустимых значений (выпадающий список выбора дочерней
шины для устройства должен отображать список всех допустимых шин,
имеющихся в ВМ, и он должен корректироваться при добавлении или
удалении очередной шины);
* формулировка допустимых значений (если был изменён индекс шины
в мосте, все списковые виджеты должны скорректировать текст в
соответствующих строках).

Это не полный перечень зависимостей. При этом, любое значение
может быть изменено _минимум_ двумя способами:

* через соответствующий виджет;
* отменой или повторением правки пользователя.

Для учёта произвольных зависимостей в ГИ применяются _события_. Каждый
виджет добавляет свой метод обратного вызова в список
_наблюдателей_ трекера. При выполнении операции трекер уведомляет всех
наблюдателей о выполнении операции. Наблюдатель должен выбрать
операции, относящиеся к виджету и среагировать соответствующим образом.

### Сопрограммы и фоновые вычисления

Стандартом _де-факто_ при разработке ГИ является применение событийно-
ориентированного программирования, при котором непозволительно выполнять
длительные вычисления при обработке события. Так как это приводит к
"подтормаживанию" интерфейса и снижению удобства.

Встраивание длительных вычислений в ГИ принято производить следующими
способами:

* вынос вычислений в отдельный процесс или нить;
* фрагментация (вычисления разбиваются на малые фрагменты, которые
могут быть быстро выполнены при обработке события, и выполняются
в течение обработки специализированных событий).

Для реализации фрагментации удобно использовать "сопрограммы" --- функции
позволяющие передавать управление другой сопрограмме раньше
выхода, "замораживая" своё состояние, а затем получать его в
то же место, откуда оно было передано (при этом сохраняются все
локальные переменные).

Python, в свою очередь, имеет языковую поддержку т.н. _генераторов_ ---
сопрограмм способных дополнительно вернуть значение при очередной передаче
управления (инструкцией `yield`).

В ГИ длительные вычисления реализуются генераторами. Долго работающие
функции реализуются как сопрограммы, снабжаясь операторами `yield` через
каждый фрагмент вычислений. Управление между сопрограммами распределяется
_диспетчером_, встраиваясь между обработкой событий ГИ.

В ГИ в фоне выполняются следующие задачи:

* анализ исходного кода QEMU;
* предварительное вычисление эвристик о текущей версии QEMU;
* генерация кода;
* уведомления о событиях (т.н. _сигналы_), не требующих синхронной
обработки;
* динамическое размещение узлов ВМ на диаграмме (опция позволяющая
избегать взаимного прекрытия изображений узлов).

Выбор в пользу фрагментации, был сделан с целью упрощения разработки:

* исключено состояние гонки, не требуется синхронизация, нет параллельных
ошибок, легче отладка;
* в Python нити выполняются синхронно, причём встроенный
планировщик не различает приоритетных вычислений при обработке событий
ГИ в реальном времени от фоновых вычислений, что приводит к "подтормаживанию";
для реальной параллельности требуется использовать сторонние библиотеки;
* для реализации параллельности требуется больше кода;
* в инструменте отсутствуют _регулярные_ сложные вычисления: достаточно
одного процесса.

### Диаграмма вычислительной машины

ВМ состоит из множества элементов, которые связаны между собой
различными способами. Схема позволяет пользователю видеть основные
связи в ВМ, не прибегая к интерпретации текстового описания в воображении.

Полезной функцией является экспорт диаграммы в векторное изображение.
Это экономит значительное количество времени пользователя при
написании сопряжённых текстов. Например, иллюстрации, представленные
в этой статье, получены автоматизированно с использованием данной
функции.

### Динамический текст, интернационализация

В ряде случаев требуется удобный механизм, позволяющий обновлять текст
в уже созданных виджетах. Библиотека Tkinter[[Tkinter](#Tkinter)]
поддерживает изменение текстовой информации в виджетах, но способы
варьируются от класса к классу. Также требуется хранить ссылки
на все виджеты, где используется переменный текст. Наконец, нужен
механизм уведомления об изменениях. В библиотеке уже реализовано дерево
классов для реализации переменных, поддерживающих уведомления.
В частности, класс `StringVar` имеет методы `set` и `get`, для доступа
к значению, и метод `trace_variable`, назначающий функцию обратного
вызова по его изменению.

Для наиболее часто используемых классов виджетов были разработаны
классы-оболочки, принимающие переменные класса `StringVar` в качестве
значений текстовых параметров. Используя `trace_variable`, они
прозрачно для остального кода выполняют обновление соответствующих
полей обёртываемых объектов. Таким образом, для изменения текста во
время выполнения достаточно вызвать метод `set`. Это также унифицирует
механизм изменения текста в виджетах.

Особый интерес представляют динамические строки, являющиеся результатом
форматирования. Причём, как исходная строка форматирования, так и
использованные значения могут быть динамическими.
Когда меняется строка форматирования или любое из значений,
использованных в подстановке, требуется пересчитать производное
значение. В работе был реализован класс `FormatedStringVar` с этим
функционалом. Он используется в связке с классом `FormatVar`
реализующим оператор `%` для класса `StringVar`. Это даёт возможность
использовать динамические строки, как строки форматирования,
синтаксически так же как обычные строки Python. Данные классы совместимы
с виджетами-оболочками, так как наследованы от `StringVar`.

В проекте повсеместно используются виджеты классов-оболочек. Это
упрощает реализацию следующего функционала:

* динамическое изменение языка интерфейса, в том числе строк описания
операций редактирования проекта, полученных путём форматирования;
* обновление подсказок о клавишах быстрого доступа;
* обновления текстов, зависящих от значений параметров проекта.

Распространённым способом интернационализации интерфейса является
составление базы соответствия между текстом, использованным непосредственно,
и переводом этого текста на каждый поддерживаемый язык. Стандартом _де-факто_
является применение библиотеки `gettext` (или её аналога для соответствующего
языка). Она работает именно таким образом. Для перевода текстов в данном
инструменте используется её оболочка для языка Python. Многие приложения
используют функционал `gettext` для перевода текстов непосредственно при
создании виджетов. При этом изменение языка требует перезагрузки ГИ после
изменения выбранной локализации. Применение динамических строк в ГИ данного
инструмента исключает эту необходимость. В том числе и для случаев, когда
переведённая строка используется не непосредственно, а, например, как строка
форматирования.

## Шаблоны
### Классовая иерархия QEMU
### Свойства объектов
### Состояние времени выполнения
### Таймеры
### Символьные устройства
### Блочные устройства
### Входящие прерывания
### Устройства системной шины
#### MMIO и PMIO
#### Исходящие прерывания
### PCI
#### Идентификация
#### BAR
#### MSI
### Адаптация к изменениям QEMU

QEMU является развивающимся проектом. Это приводит к тому, что в нём
периодически происходят изменения, делающие генератор кода несовместимым с
новой версией.

Для решения этой проблемы используется эвристический подход. Все аспекты
поведения инструмента, зависящие от версии QEMU, называются _эвристиками_.
Т.к. один аспект работы может меняться многократно, то каждая эвристика
представлена одной или несколькими записями в базе данных.

Код инструмента получает доступ к требуемой эвристике по _строковому
ключу_ --- уникальному имени эвристики.
Значением эвристики может быть любая сущность языка Python: от целочисленной
константы до класса или модуля. Таким образом, при необходимости, можно
_подменить_ почти всю реализацию инструмента.

Каждая запись об эвристике имеет как минимум два значения: _новое_ и _старое_.
Запись привязывается к SHA1-идентификатору изменения в Git-графе [[Git](#Git)]
истории QEMU.

При обнаружении очередного несоответствия между инструментом и QEMU,
разработчик должен сделать следующие действия.

* Определить, что изменилось.
* Определить, SHA1 соответствующего изменения.
* Дополнить базу данных эвристик записью о новом и старом значениях, придумав
эвристике осмысленное название (_ключ_).
* Изменить код инструмента таким образом, чтобы он зависел от значения,
соответствующего _ключу_ в данный момент.

В инструменте реализован алгоритм, позволяющий для заданных SHA1,
базы эвристик и Git-истории вычислить значения для всех имеющихся в базе
ключей. Хранение обоих значений в каждой записи об эвристике избыточно. Но эта
избыточность используется для проверки непротиворечивости записей.

## Генерация кода

Первым подходом к генерации кода было использование строк форматирования
двух видов:

* `printf`-подобный, реализуемый оператором `%`, для простых подстановок;
* расширенный, поддерживаемый методом `format`, для форматирования с
большим количеством параметром.

С развитием инструмента стало ясно, что для генерации даже небольшого
шаблона требуется определить множество параметров. Многие из которых
являются производными как от настроек пользователя, так и от особенностей
кода QEMU (по большей части). В результате строки форматирования были
обёрнуты в специальные классы, упрощающие разработчику написание
шаблонов. В настоящее время строки используются только на самом низком
уровне инструмента. Разработчик, реализуя шаблоны, уже использует
специализированное API. Исключением является написание шаблонов тел
функций. Однако функционал API, упрощающий реализацию шаблонов тел
функций развивается, упрощая этот процесс. Со временем, ручное написание
строк форматирования при создании тел функции будет исключено.

Параллельно была предпринята попытка использовать для определения
шаблонов АСД языка Си. Библиотека PyCParser[[PyCParser](#PyCParser)],
реализует двустороннее преобразование. Однако у применения АСД имеются
следующие недостатки:

* не поддерживается препроцессор, макросы которого активно используются
в интерфейсной (и не только) части модели устройства;

* не учитываются незначащие символы (пробелы, переносы строк,
комментарии), что требует доработки генератора PyCParser, таким образом,
чтобы он генерировал код, не противоречащий стилю программирования,
принятому в QEMU.

Получаемые при генерации фрагменты кода не являются независимыми. Язык
Си требует, чтобы многие имена были объявлены до их использования.
В том числе с использованием директивы `include` препроцессора.
Аналогичное требование есть для препроцессора.
То есть генератор должен не только сгенерировать фрагменты кода, но
и расположить их в правильном порядке. Также требуется сгенерировать
включение требуемых заголовков, причём желательно, минимизировать
количество включений. Не стоит забывать, что порядок включения заголовков
иногда существенен.

В результате для генерации файла исходного кода были разработаны две
модели.

1. Модель синтаксиса языков Си и препроцессора. Она описывает, какие
синтаксические конструкции присутствуют в файле, как они связаны между
собой и с существующим кодом.

2. Модель файла с исходным кодом. Она оперирует неделимыми текстовыми
фрагментами, из которых состоит файл, и порядковыми связями между ними.
Она конструируется автоматически из первой модели.

### Модель языков Си и препроцессора

Реализованное API для написания шаблонов в представляет собой
модель _гибридного языка_, полученного путём слияния языка Си и языка
препроцессора. API работает на уровне файлов: с его помощью
разработчик описывает содержимое каждого генерируемого файла.
При этом API позволяет описать содержимое существующих файлов. Это
необходимо для встраивания генерируемого файла в QEMU. Существующие
файлы можно описывать не так подробно и не полностью, следуя
принципу минимально достаточной информации.

При описании содержимого файла используются следующие классы.

* `Type`
    * `TypeReference`
    * `Structure`
    * `Function`
    * `Pointer`
    * `Macro`
* `Initializer`
* `Variable`
* `Usage`

_Тип_ (класс `Type`), как можно заметить из перечня подклассов, тут
понимается как нечто большее, чем тип в языке Си.

Объект класса `Type` обладает следующими свойствами:

* `name` --- уникальное имя типа;
* `incomplete` --- незавершенный тип, нельзя создать _переменную_
такого типа;
* `definer` --- идентификатор файла, где этот тип _определён_;
* `base` --- базовый тип, который имеется в языке, для его использования
не нужно подключать заголовки.

Уникальность имени типа даёт возможность находить тип только по имени:
не требуется сначала искать файл, где этот тип определён. Это облегчает
работу разработчика шаблонов, но имеет _теоретический_ недостаток,
заключающийся в следующем.
Совместное хранение макросов вместе с типами языка Си, строго говоря, делает
требование уникальности имени невыполнимым в общем случае.
Однако данная проблема не возникает в QEMU благодаря принятому стилю
программирования.
Известно, что в QEMU реализации двоичного транслятора для разных
целевых архитектур имеют пересекающиеся множества имён символов языка Си
и препроцессора. Но устройства и ВМ реализуются архитектурно независимо,
и файлы определяющие одноимённые типы не используются вместе.

Класс `Type` не предусматривает шаблона для генерации кода. Это значит,
что нельзя сгенерировать файл, где есть хоть одна сущность, описываемая
этим классом. Фактически, этот класс применяется для ручного определения
списка типов, присутствующих в существующих файлах QEMU, в тех
случаях, когда достаточно только имени типа для подключения нужного
заголовка.

Одним из направлений дальнейших исследования является синтаксический
анализ файлов QEMU с целью автоматического создания объектов,
описывающих существующие типы. В настоящий момент такая функциональность
реализована только для макросов препроцессора и опирается на функционал
модифицированного препроцессора из библиотеки PyCParser.

Объект `TypeReference` (ссылка на тип) используется для ссылок на типы
из других файлов. Любой тип может присутствовать непосредственно только
в файле, где он объявлен. Такой подход даёт возможность при генерации кода
однозначно определить следует ли сгенерировать непосредственное
определение типа по шаблону, или сгенерировать включение заголовочного
файла, где он определён.

Если необходимо объявить переменную типа из другого файла, используется
`TypeReference`. То есть создаётся ещё один тип с тем же именем, но
особым способом обработки:

* имя такого типа не индексируется в API и, следовательно, требование
уникальности игнорируется;
* шаблоном для генерации кода `TypeReference` является директива
`include` препроцессора.

Тут важно заметить, что в отличие от Си, модель не делает разграничения
на _объявление_ и _определение_. То есть объявление функции (или
внешней переменной) в заголовке
и её определение в модуле --- два разных _определения_ в данной модели.
Синтаксическая необходимость обеспечить объявление функции до
её определения достигается добавлением в объект типа, представляющим
её определение, ссылки (`TypeReference`) на тип, представляющий её
объявление. Таким образом, будет сгенерирована директива `include`,
подключающая соответствующий заголовочный файл до определения функции.

Класс `Variable` (переменная) описывает пару: "тип, имя". В данной модели
_переменная_ нечто большее, чем переменная в языке Си. Суть этого
класса раскрывается при описании нижеизложенных классов API. Для случая,
когда этот класс используется для описания переменной языка Си,
предусмотрены следующие поля:

* `static` --- соответствует одноимённому слову языка Си;
* `initializer` --- инициализатор, начальное значение переменной;
* `array_size` --- используется для определения массивов, в т.ч. и
безразмерных (когда размер определяется компилятором по инициализатору,
или когда нужно определить переменную-указатель, используя `[]` вместо
`*`).

Класс `Structure` (структура) используется для объявления составного типа.
По представленному в нём описанию создаётся конструкция `struct` языка Си.
Объект класса содержит список полей (`fields`), определяемых объектами
класса `Variable`.
<!--
Иногда часть полей структуры в языке Си определяется
макроподстановкой. В данной модели такие поля описываются одной
_переменной_, тип которой является соответствующим макросом (`Macro`), а
имя игнорируется.
-->

Класс `Function` (функция) используется для описания конструкций языка
Си, связанных с функциями этого языка:

* объявление функции;
* определение функции, в том числе статических (`static`) и/или
встраиваемых (`inline`);
* определение типа указателя на функцию (применяется совместно с
классом `Pointer`);

Объект `Function` содержит следующие дополнительные поля:

* `ret_type` --- тип возвращаемый функцией;
* `args` --- список аргументов функции (аналогично полям структуры);
* `static` и `inline` --- фактически определяют наличие соответствующих
ключевых слов в генерированном коде;
* `body` --- текст тела функции;
* `used_types` и `used_globals` --- список, соответственно, типов и
глобальных переменных, использованных в теле функции; данная информация
необходима, так как на данный момент модель не поддерживает тела
функций.

При определении тела функции разработчик должен, используя
вспомогательные методы API, сконструировать тело функции, сохраняя
списки использованных в нём типов и глобальных переменных.
Затем он передаёт эти списки в объект функции.

Важно заметить, что под понятие "использованный тип" подпадают
также такие сущности как:

* вызванные функции;
* структуры, использованные при объявлении переменных;
* использованные макросы; и т.п.

Класс `Pointer` (указатель) применяется для создания указателей
различного вида:

* именованных типов указателей (например, `typedef int* intptr;`),
включая указатели на функции;
* определение переменных-указателей на другие типы (в том числе
полей структур и аргументов функций).

При определении переменной-указателя создаётся _безымянный_ тип
указателя. На самом деле имя ему формально генерируется путём
подстановки '`*`' к основному типу, согласно синтаксису языка
Си. Но имя такого типа не индексируется API и, следовательно,
может не быть уникальным. Кроме того, этот тип не привязывается
к какому-либо файлу, т.е. наличие где-нибудь переменной такого
типа не вызывает генерации директивы `include` само по себе.
Однако тип под указателем, если он не является базовым, должен быть
обеспечен либо директивой `include`, либо непосредственным
определением.

Класс `Macro` (макрос) соответствует директиве `define`
препроцессора. Поддерживаются как параметризованные макросы, так
и не параметризованные макросы. Однако поддержка параметров
ограничивается только генерацией вызова макроса: раскрытие же не
требуется для генерации файла (ровно как и выполнение
сгенерированного кода, чем, по сути, и является раскрытие макроса,
с точки зрения данной модели).

Класс `Initializer` (инициализатор) используется для определения
начальных значений
переменных или параметров вызова макроса. Поле `code` содержит
данные, используемые для генерации кода инициализатора, а поля
`used_types` и `used_variables` хранят ссылки на, соответственно,
типы и переменные, использованные в коде инициализатора. Модель
инициализатора схожа с моделью тела функции, и обе они пока не
развиты, являясь объектами дальнейших исследований.

Класс `Usage` (использование) применяется, когда при генерации
переменной некоторого
типа не достаточно использовать в шаблоне имя типа непосредственно.
Т.е. имя типа должно быть преобразовано некоторым образом перед
вставкой в шаблон. `Usage`
добавляет инициализатор (`Initializer`) к _типу_ переменной, на
основании которого и происходит видоизменение имени типа.
Единственным примером в настоящее время является макрос.
Инициализатор используется для расстановки
значений при генерации вызова макроса. Имя переменной и _её_
инициализатор при этом игнорируются.

Рассмотренная модель не является законченной. Но даже в таком варианте
она позволяет с достаточно гибкостью описывать шаблоны устройств и ВМ,
используемые при генерации интерфейсной части их кода. Развитие
этой модели является направлением дальнейших исследований.


### Модель файла с исходным кодом
#### Взаимосвязь с существующим кодом
#### Учёт зависимостей
### Встраивание в код QEMU
## Методика испытаний
### 1440FX
### Q35
### CISCO C2600 из Dynamips
## Результаты
## Заключение
## Использованные источники

* <a name="Git"></a>Система контроля версий Git. "https://git-scm.com/about",
09.03.2017.

* <a name="Tkinter"></a>Страница библиотеки для создания графического
интерфейса "Tkinter". "https://wiki.python.org/moin/TkInter", 2017.03.13.

* <a name="PyCParser"></a>Страница библиотека PyCParser на GitHub.
"https://github.com/eliben/pycparser", 20.03.2017.

