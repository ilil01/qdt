[//]: # (pandoc article.md --standalone --smart -o article.html)

# Автоматизация разработки моделей устройств и вычислительных машин для QEMU

## Обозначения и сокращения

* API Application programming interface
* BAR Base address registers
* CD Compact disc
* CLI Command line interface
* IRQ Interrupt request
* MMIO Memory mapped input/output
* MSI Message signalled interrupt
* PCI Peripheral component interconnect
* QOM QEMU object model
* ROM Read-only memory
* SHA1 Secure Hash Algorithm 1
* TAP ?
* UDP User datagram protocol
* ВМ вычислительная машина
* ГИ графический интерфейс
* НЖМД накопитель на жестком магнитном диске
* ПЗУ постоянное запоминающее устройство
* УАПП универсальный асинхронный приёмо-передатчик

## Аннотация
## Введение
## Ручной подход

Используемый в настоящее время подход к реализации моделей для QEMU
заключается в поиске похожей функциональности в существующих моделях и
реализации требуемой по образу и подобию. При этом применяется обычное
копирование кода, с последующими его правками и дополнениями.

### Разработка модели устройства
### Разработка модели вычислительной машины
## Подход к автоматизации

Условно код модели можно разделить на две части _индивидуальную_ и
_интерфейсную_.
Индивидуальная часть есть само устройство в своей программной реализации.
Именно эта часть определяет логику работы устройства, делает его особенным,
относительно других устройств. Так как устройство является
частью системы, оно должно предоставлять функционал, используя
предоставленные ему возможности посредством фиксированного API. Часть кода,
взаимодействующая с этим API и называется _интерфейсной_. То есть, она
служит связкой между внутренней логикой модели и окружающей средой.

Индивидуальная часть обычно сформулирована на естественном языке в техническом
описании. При этом отсутствует единый формат _формального_ описания логики
устройства, которого бы придерживались производители.
Ввиду этого автоматизация разработки этой часть весьма затруднительная и
выходит за рамки этой работы.

С другой стороны, интерфейсная часть всех устройств очень похожа. Отличия
заключаются, в основном, в перечне и количестве используемых моделью внешних
интерфейсов, а также в именах собственных, которые часто формируются из
названия модели устройства путём применения к нему формализованных правил,
сформулированных или _де-факто_ (в коде существующих устройств), или в
тексте из файла `CODING_STYLE`, описывающим принятый в проекте стиль
программирования.

Опираясь на формализуемость правил написания интерфейсной части можно
разработать программу, принимающую небольшое количество понятных параметров
и возвращающую компилируемый код-шаблон, реализующий минимальный функционал
и готовый к внесению в него индивидуальной логики вручную. Таким образом,
программист, ознакомившись с техническим описанием устройства, может
формально сформулировать перечень требуемых модели устройства интерфейсов
и, применив разработанный инструмент, приступить непосредственно к
реализации индивидуальной части.

Отдельно нужно сказать о вычислительных машинах. Хотя описания вычислительных
машин, аналогично устройствам, лишены формализма и единообразия, в QEMU
присутствует развитое API для интеграции устройств в единое целое (то есть в
ВМ). С помощью этого API можно формально описать полноценную ВМ. При этом
имеются следующие ограничения.
1. Устройства, входящие в ВМ, должны иметь интерфейсную часть реализованную в
полном соответствии с моделью.
2. Сформулированная машина сильна ограничена в настройке.

В QEMU присутствует ряд старых устройств, которые написаны по-старому. То есть,
они ещё не были переписаны на новую модель. Первое ограничение не существенно,
если преобладающая часть устройств ВМ реализуется вместе с ней по формальному
описанию. Такие устройства будут иметь совместимую интерфейсную часть.

Полученная таким образом ВМ зафиксирована на уровне исходного кода. То есть, в
неё будет проблематично добавить новое устройстве и невозможно удалить
имеющееся. CLI QEMU поддерживает ряд ключей, динамически создающих
дополнительные устройства (например, можно подключить к шине PCI новую
функцию). Также часть параметров машины заведомо требуется от пользователя,
например, файл-образ ПЗУ (НЖМД, микросхема flash-памяти, CD, и т.п.),
оконечную точку УАПП (виртуальный терминал, файл, и т.п.), способ подключения
сетевого порта (TAP-адаптер, Ethernet по UDP и т.п.) и т.д.

Состав ВМ определяется функцией её инициализации, которая последовательно
создаёт все устройства и соединяет их воедино. В данной работе реализован
программный интерфейс, позволяющий описать состав ВМ и сгенерировать её
функцию инициализации. Интерфейс реализован на языке Python, поэтому описание
получается несколько короче, чем соответствующий ему генерированный код. Но
основное преимущество заключается в возможности написания графического
интерфейса, значительно повышающего наглядность и скорость описания ВМ. Таким
образом, отсутствие формализованного описания ВМ смягчается удобством
компоновки ВМ по этому описанию.

### Метод шаблонов

Как уже отмечалось, код интерфейсной части всех устройств достаточно
единообразен, чтобы его можно было получить из некоторого набора строк,
путём подстановки параметров.

Часто для одного интерфейса необходимо сгенерировать несколько фрагментов кода.
При этом фрагменты должны следовать в правильном порядке как относительно
друг друга, так и фрагментов других интерфейсов. Это требование следует из
синтаксиса языка Си. Например, если один из аргументов функции является
указателем на структуру, то сама структура должна быть объявлена выше.

Часть параметров одних шаблонов может быть связана с параметрами других
шаблонов. Например, функция инициализации устройства, является частью шаблона,
встраивающего устройство в иерархию типов QOM. Если же устройство имеет
регистр MMIO, то для него применяется другой шаблон. Но регистр должен быть
зарегистрирован в функции инициализации. А значит, имя переменной, описывающей
регистр, является параметром шаблона функции инициализации.

Символы API QEMU должны быть доступны в сгенерированных файлах. Для этого
нужно включить (директивой `#include`) соответствующие заголовочные файлы.
Список этих файлов может быть автоматически вычислен по перечню использованных
символов. При этом, код будет выглядеть лучше, если минимизировать список
заголовочных файлов.

Эти и другие тонкости учтены в модели, используемой системой. При этом нельзя
сказать, что она закончена, так как периодически обнаруживаются случаи,
требующие её модификацию. Здесь представлено описание модели, используемой
в текущей версии.

### Программный интерфейс модели QEMU

Значительная часть сложной системы взаимосвязей шаблонов может быть создана
автоматически. От пользователя требуется небольшое количество интуитивно
понятных параметров. Это достигается разработанным API, скрывающим от него
сложность взаимосвязи шаблонов. Пользователь настраивает генерацию кода
посредством ниже перечисленных классов.

Видимая пользователю иерархии классов построена по тому-же принципу, что и
иерархия классов QOM. Таким образом, он легко сможет сопоставить
соответствующие классы.

Реализована следующая иерархия классов.

* `QOMDescription`
    * `SysBusDeviceDescription`
    * `PCIExpressDeviceDescription`
    * `MachineNode`

`QOMDescription` является базовым классом. Он не предназначенный для
использования.

`SysBusDeviceDescription` описывает устройство на системной шине.

`PCIExpressDeviceDescription` описывает PCI устройство. PCI _устройство_
в QEMU соответствует одной _функции_ реального устройства. QEMU не моделирует
физические взаимодействия по шине. Поддержка MSI (а именно реакция на
запись сообщения в память) реализуется главным мостом, обычно являющимся
устройством на системной шине. Как следствие, и PCI, и PCI Express устройство
может быть описано через этот класс.

`MachineNode` описывает ВМ и входящие в её устройства.

Перечисленные классы выполняют роль контейнеров для параметров. При генерации
кода на основе этих параметров создаются классы внутреннего API,
непосредственно участвующего в генерации.

В то время как для описания устройств системной шины или PCI достаточно базовых
типов, для описания устройств, входящих в ВМ, требуется ещё одно дерево
классов. Причём в это дерево включает классы, описывающие то же самое, что и
перечисленные выше классы. А именно: устройства системной шины и PCI. Тем не
менее, они описывают эти устройства с разных точек зрения:
* первые содержат перечень использованных в модели устройства элементов API
  QEMU;
* вторые же описывают способ подключения устройств.

Поскольку часть элементов API QEMU способствуют единообразию подключения
устройств в машину, то вторые могут быть вычислены из первых. Однако это
является одним из направлений дальнейших исследований.

Совместно объекты этих классов образуют _проект_ (`QProject`): контейнер с
данными для генератора кода.

### Модель вычислительной машины

Содержимое ВМ описывается с использованием следующей иерархии классов.

* `Node`
    * `BusNode`
        * `SystemBusNode`
        * `PCIExpressBusNode`
        * `ISABusNode`
        * `IDEBusNode`
        * `I2CBusNode`
    * `DeviceNode`
        * `SystemBusDeviceNode`
        * `PCIExpressDeviceNode`
    * `IRQLine`
    * `IRQHub`
    * `MemoryNode`
        * `MemoryLeafNode`
            * `MemoryAliasNode`
            * `MemoryRAMNode`
            * `MemoryROMNode`

`Node` содержит уникальный идентификатор узла ВМ.

`BusNode` содержит все данные, необходимые чтобы описать шину любого типа. Все
дочерние классы конкретизируют эти данные. Они были введены для сокращения
объёма кода, необходимого для добавления шины вручную. При использовании
графического интерфейса это не актуально.

Большинство параметров шины определяют генерацию кода, для шины этого типа. И
только следующие параметры определяют место шины в ВМ:
* ссылка на устройство-мост (родительское), контролирующее эту шину;
* ссылки на устройства, подключённые к шине (дочерние).

`DeviceNode` описывает параметры, присущие любому устройству:
* модель устройства (листовой тип в дереве типов QOM);
* ссылку на шину, к которой подключено это устройство (родительскую);
* ссылки на контролируемые (дочерние) шины, если устройство является мостом;
* список значений для свойств устройства, как объекта QOM.
* ссылки на привязанные прерывания с параметрами их привязки.

`IRQLine` (линия) и `IRQHub` (концентратор) описывают распространение
прерываний между устройствами (ту его часть, которая по како-то причине не
спрятана в шину). Концентратор прерываний используется в случаях, когда одно
прерывание должно быть доставлено в несколько устройств и/или может быть
получено из нескольких устройств (так как линия прерывания соединяет строго
два узла). Линия содержит информацию об _источнике_ и _приёмнике_ прерывания.
Причём для каждого конце, являющегося устройством, определены:
* ссылка на устройство;
* индекс порта прерывания в группе прерываний;
* имя группы прерываний.
Если концом является концентратор, то достаточно только ссылки.

Большую часть адресного пространства ВМ определяют сами устройства. В адресное
пространство входят MMIO и BAR (PCI) регистры устройств, блоки памяти ROM
устройств и т.д. Однако, такие диапазоны как адресное пространство PCI, RAM
и т.п. должны быть определены отдельно. Причём в некоторых случаях адресное
пространство PCI создаётся главным мостом, а в некоторых создаётся
функцией инициализации машины и передаётся мосту как параметр.

`MemoryNode` описывает интервал-контейнер, содержащий в себе другие интервалы
со смещением, относительно своего начала.

`MemoryLeafNode` (лист) является служебным промежуточным классом, запрещающим
добавлять интервалы в интервалы, не являющимися контейнерами.

`MemoryAliasNode` (псевдоним) используется, чтобы обеспечить доступ к
интервалу (или его отрезку) из другого адреса.

`MemoryRAMNode` и `MemoryROMNode` описывают непрерывный интервал эмулируемой
физической памяти. Причём `MemoryROMNode` нельзя менять.

Каждый из перечисленных классов, описывающих интервал памяти, имеет следующие
параметры:
* отладочное строковое имя;
* размер;
* смещение в контейнере и ссылку на него;
* допустимость перекрытия в пределах одного контейнера и приоритет для его
  разрешения;

`MemoryNode` _может_ иметь непустой список ссылок на детей, а
`MemoryAliasNode` _должен_ содержать смещение в пределах интервала, на который
он перенаправляет запросы к себе, и ссылку на него.

Каждый из перечисленных классов (включая потомков `QOMDescription`)
является контейнером для параметров. Их основные функции:
* хранение настроек пользователя,
* сохранение настроек в файл и обратно,
* взаимодействие с графическим интерфейсом.

### Формат файлов

Настройки генерации устройств и ВМ собраны в единый _проект_. Проект
описывается классом `QProject` (QEMU project). При работе с ГИ используется
его подкласс `GUIProject` (GUI project), дополнительно хранящий настройки
отображения.

Проект сохраняется в файл в текстовом формате, совместимым с синтаксисом
языка Python. Сохранённый проект представляет собой _почти_ корректную
программу на языке Python, результатом выполнения которой является
определение переменой ссылающейся на объект класса `QProject` (или
`GUIProject`, в случае ГИ), _эквивалентный_ объекту, сохранённому в
файл. Программа используется имена из пользовательского API. Генератор
файлов сохранений изначально разрабатывался таким образом, чтобы файлы
выводились в удобном для человека формате. В сгенерированной
программе отсутствуют инструкции импорта необходимых имён (это
возложено на загрузчик файла), поэтому программа не является корректной.

Под _эквивалентностью_ сохранённого и восстановленного объекта понимается:
* равенство значений простых типов в соответствующих атрибутах;
* каждый ссылочный атрибут в восстановленном объекте указывает на
объект эквивалентный тому, на который этот атрибут указывал в
сохранённом объекте (ссылки на `None` восстанавливаются как ссылки на
`None`).

При сохранении не гарантируются:
* равенство _незначащих_ пробельных символов;
* синтаксически не значащий порядок фрагментов кода (порядок определения
аргументов конструкторов со значениями по умолчанию, порядок
восстановления несвязанных объектов, и т.п.);
* сохранность комментариев, если таковые были внесены вручную в файл
проекта.

Данные особенности создают сложности при ручной работе с файлами проекта,
а также при хранении файлов с использованием системы контроля версий.
Решение этой проблемы является один им направлений дальнейшего развития
инструмента.

## Графический интерфейс

Все возможности инструмента доступны пользователю посредством API. Для
описания устройств и ВМ достаточно произвольного текстового редактора.
Однако применение ГИ, спроектированного _специально_ для работы с API,
имеет следующие преимущества.

* Исключены лексические ошибки в именах элементов API и синтаксические
ошибки, т.к. пользователь водит только значения параметров.

* Для многих значений параметров в QEMU определены макросы,
использование которых предпочтительней, согласно _хорошему тону
программирования_. ГИ интерфейс, проанализировав код QEMU, может
предоставить пользователю список доступных макросов, обычно применяемых
с данным типом параметра. Например, идентификатор PCI, родительский
тип QOM, свойство QOM и т.п.

* Исключены некоторые семантические ошибки (например, в ГИ не
предусмотрена возможность соединения линией прерывания двух шин, в то
время как пользователь волен написать всё, что угодно в текстовом
редакторе). Имеется возможность дополнить ГИ средствами поиска менее
очевидных семантических ошибок.

* Все доступные параметры сосредоточены в _виджетах_ с названиями на
естественном языке. В большинстве случаев знания QEMU достаточно, чтобы
понять суть параметра, не обращаясь к справочной информации.

* Интерпретация ВМ в виде схемы. ВМ состоит из множества элементов,
которые связаны между собой различными способами. Схема позволяет
пользователю видеть основные связи в ВМ, не прибегая к умственным
усилиям по интерпретации текстового описания в воображении.

### Обратимые операции
### Обратная связь при изменениях
### Сопрограммы
### Длительные фоновые вычисления
### Диаграмма ВМ
### Экспорт диаграммы ВМ
### Интернационализация

## Шаблоны
### Классовая иерархия QEMU
### Свойства объектов
### Состояние времени выполнения
### Таймеры
### Символьные устройства
### Блочные устройства
### Входящие прерывания
### Устройства системной шины
#### MMIO и PMIO
#### Исходящие прерывания
### PCI
#### Идентификация
#### BAR
#### MSI
### Адаптация к изменениям QEMU

QEMU является развивающимся проектом. Это приводит к тому, что в нём
периодически происходят изменения, делающие генератор кода несовместимым с
новой версией.

Для решения этой проблемы используется эвристический подход. Все _эвристики_
работы инструмента, зависящие от версии QEMU, собраны в единую базу данных.
Код инструмента получает к ним доступ по _строковому ключу_. Значением
эвристики может быть любая сущность языка Python: от целочисленной
константы до класса или модуля. Таким образом, при необходимости, можно
_подменить_ почти всю реализацию инструмента.

Каждая эвристика имеет как минимум два значения: _новое_ и _старое_.
Одна и та же эвристика может меняться многократно. Каждая пара значений
привязывается к SHA1 идентификатору изменения в Git-графе [[Git](#Git)]
истории QEMU.

При обнаружении очередного несоответствия между инструментом и QEMU,
разработчик должен сделать следующие действия.
* Определить, что изменилось.
* Определить, SHA1 соответствующего изменения.
* Дополнить базу данных эвристик новым и старым значением, придумав
эвристике осмысленное название (_ключ_).
* Изменить код инструмента таким образом, чтобы он зависел от значения,
соответствующего _ключу_ в данный момент.

В инструменте реализован алгоритм, позволяющий для заданных SHA1,
базы эвристик и Git-истории вычислить значения для всех имеющихся в базе
ключей.

## Генерация кода
### Модель языка Си и препроцессора
### Модель файла с исходным кодом
#### Взаимосвязь с существующим кодом
#### Учёт зависимостей
### Встраивание в код QEMU
## Методика испытаний
### 1440FX
### Q35
### CISCO C2600 из Dynamips
## Результаты
## Заключение
## Использованные источники

* <a name="Git"></a>Система контроля версий Git. "https://git-scm.com/about",
09.03.2017.

