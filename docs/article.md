[//]: # (for t in docx html;do pandoc article.md --standalone --smart -o article.$t;done)

# Автоматизация разработки моделей устройств и вычислительных машин для QEMU

## Обозначения и сокращения

* API Application programming interface
* BAR Base address registers
* CD Compact disc
* CLI Command line interface
* GPIO general purpose input/output
* IRQ Interrupt request
* LPC Low pin count
* MMIO Memory mapped input/output
* MSI Message signalled interrupt
* MSI-X Extended MSI
* PCI Peripheral component interconnect
* QOM QEMU object model
* ROM Read-only memory
* SHA1 Secure Hash Algorithm 1
* TAP ?
* TCG Tiny code generator
* TCP Transmission control protocol
* UDP User datagram protocol
* USB Universal serial bus
* АСД абстрактное синтаксическое дерево
* ВМ вычислительная машина
* ГИ графический интерфейс
* НЖМД накопитель на жестком магнитном диске
* ООП объектно-ориентированное программирования
* ОС операционная система
* ПЗУ постоянное запоминающее устройство
* ПО программное обеспечение
* УАПП универсальный асинхронный приёмо-передатчик

## Аннотация
## <a name="Introduction"></a>Введение

### Ручной подход

Используемый в настоящее время подход к реализации моделей для QEMU
заключается в поиске похожей функциональности в существующих моделях и
реализации требуемой по образу и подобию. При этом применяется обычное
копирование кода, с последующими его правками и дополнениями. С опытом
всё большую часть кода можно писать по памяти, но нужно следить за
изменениями в QEMU.

### Определение типа QOM
<a name=QOM_type_definition></a>

Минимальный код, который должен быт написан, чтобы встроить
новую модель в инфраструктуру QEMU включает в себя:

* инициализацию структуры `TypeInfo`, где должны быть указаны
строковые имена родительского класса и класса добавляемой модели;

* функцию-конструктор `register_types` модуля, вызывающую
`type_register_static` для всех `TypeInfo` в модуле;

* макроподстановку `type_init`, указывающую компилятору, что
`register_types` является конструктором модуля: её следует вызвать
неявно;

* правило в `Makefile`, регистрирующее модуль в системе сборки.

Добавленная таким образом модель не будет обладать никакой
функциональностью. Если класс родителя _абстрактный_, то модель даже
нельзя будет создать.

Реальный код чаще всего реализует, среди прочего, следующее.

* Структура, описывающая объекты своего класса (далее
_структура объекта_). В ней _первым_ полем обязательно присутствует
структура объекта родительского класса.

* Информация о размере структуры объекта.

* Функция инициализации структуры объекта.
При создании объекта класса модели выделяется область памяти,
указанного размера. Затем к ней в порядке наследования применяются
функции инициализации. В ООП такие функции (_методы_) называются
_конструкторами_.

* Структура, описывающая класс в целом (далее _структура класса_).
Она, аналогично, содержит _первым_ полем структуру класса родителя,
сопровождается информацией о её размере и функцией инициализации
(_конструктором класса_ в ООП).

Таким образом QEMU, на языке Си реализует объектно-ориентированную
парадигму программирования для моделирования платформ, устройств и
сопряжённых _сущностей_. Предназначение описанных контейнеров данных
и функций аналогично принятому в ООП.

Согласно принятым в QEMU правилам написания кода, все описанные выше
структуры, функции, строковые константы и т.д. имеют в своём названии
имя типа объекта. Оно принимает различные формы, в том числе, чтобы
быть синтаксически корректным. Далее по тексту, для ссылок на типы
будут использоваться имена структур классов.
<!-- Если тип не имеет собственной структуры, то будет выбран любой
доступный способ однозначной ссылки на тип. -->

### Определение модели устройства

Тип модели устройства должен быть потомком типа `DeviceClass`.
Этот тип предусматривает, что код устройства может реализовывать
следующее:

* объявление _свойств устройства_;

* объявление функции _реализации_ устройства;

* объявление _состояния устройства_.

Свойство устройства --- это поле
структуры объекта, доступное по строковому имени путём вызова
специальных функций. Свойство является константным начальным значением,
т.е. оно задается во время создания устройства и не может быть изменено
впоследствии.
Объявление свойств осуществляется следующим образом.

*  Определение массива структур типа `Property` при помощи
макросов вида `DEFINE_PROP_*`, указывающих строковое имя,
тип, поле структуры объекта и, в некоторых случаях, значение
по умолчанию (в остальных случаях значение по умолчанию
фиксировано API QEMU.

* Определение в заголовочном файле устройства макросов со
строковыми именами свойств (требование стиля программирования).

* Инициализация поля `props` структуры класса указателем на
массив свойств (т.е. на первый элемент). Данное поле предусмотрено
в типе `DeviceClass` (т.е. осуществляется его _перегрузка_).
Инициализация производится в конструкторе класса.

Функция реализации устройства выполняет "второй этап" инициализации
структуры объекта.
Наиболее яркий пример применения второго этапа --- свойства.
Причина этому следующая. Свойства не могут быть назначены, пока
не создано устройство. Устройство не может быть создано _до
конца_ пока не определены его свойства. Функция реализации
_доинициализирует_ устройство после определения его свойств.
Она регистрируется по указателю в поле `realize`, предусмотренным
в типе `DeviceClass`, конструктором класса.

Оболочка полей структуры устройства в свойства усложняет привычный
для Си способ определения начальных значений структуры, но
предоставляет следующие возможности:

* Прозрачное преобразование инвариантных строковых идентификаторов
объектов в указатели. Идентификаторы удобно использовать при
создании устройства. При написании кода ВМ это снимает с
программиста необходимость писать код, получающий указатели.
Код получается короче и понятнее.
Кроме того, только таким способом можно определить значение
свойства через CLI. Указатели же оптимизируют доступ к памяти
внутри реализации устройства.

* Контроль корректности значений.

В QEMU реализована возможность сохранения состояния ВМ в файл.
Сохранённое состояние называется _снимком_ (англ. _snapshot_).
Снимок ВМ включает в себя снимки её устройств. Поддержка данной
возможности требует, чтобы поведение модели устройства полностью
определялось значениями свойств и _состоянием_. Для объявления
своего состояния тип устройства определяет переменную типа
`VMStateDescription`, где указывает:

* перечень своих полей и их типов, которые влияют на поведение
модели (исключая свойства);

* строковое имя своего состояния;

* версию своего состояния.

Тип поля состояния определяет способ его сохранения и загрузки.
Версия используется для контроля использования сохранений,
сделанных прежними версиями модели устройства.

Для хранения указателя на описание состояния устройства в
в структуре класса типа `DeviceClass` предусмотрено поле
`vmsd`, инициализируемое конструктором класса.

### Определение модели вычислительной машины

Новая модель вычислительной машины должна быть потомком _абстрактного_
класса `MachineClass`, который наследован от `ObjectClass`. Минимальный
код, определяющий ВМ должен содержат следующее.

* Функцию инициализации ВМ. Её не следует путать с конструктором объекта.
Основная задача функции инициализации ВМ --- создание элементов ВМ.
Она может быть пустой.

* Конструктор класса, регистрирующий функцию инициализации и определяющий
строковое имя ВМ, без которого инициализировать ВМ будет проблематично.

* Регистрацию нового типа QOM, как описано [выше](#QOM_type_definition).
Важной особенностью является то, что имя QOM типа ВМ должно иметь суффикс
`-machine`.

Основную часть кода ВМ составляет функция инициализации ВМ. В ней
инициализируются процессор, память, основные мосты, периферийные
устройства и т.д.

В отличие от устройств, для ВМ не предусмотрено удобное объявление
свойств. Однако свойства являются частью базового типа `ObjectClass`.
Чтобы добавит свойства в ВМ необходимо определить конструктор объекта,
которой объявит требуемые свойства. Конструктор в типе `MachineClass`
уже имеет ряд свойств, которых достаточно для большинства ВМ:

* `kernel`, `initrd` и `append`: используются если в функции
инициализации ВМ предусмотрена загрузка ядра ОС Linux;

* `firmware`: предусматривает загрузку микропрограммного обеспечения;

* `usb`: даёт возможность включить/выключить поддержку USB в ВМ; и др.

Реальная работоспособность этих свойств зависит от реализации функции
инициализации.

Кроме того, структура объекта ВМ, `MachineState`, содержит следующие
важные поля, не оформленные как свойства:

* `cpu_model`: имя QOM типа процессора;

* `ram_size`: объём установленной оперативной памяти.

Однако, функция инициализации может игнорировать и их: реальная
ВМ может существовать с фиксированной моделью процессора и объёмом
памяти.

## Подход к автоматизации

Условно код модели можно разделить на две части _индивидуальную_ и
_интерфейсную_.
Индивидуальная часть воплощает суть устройство в его программной реализации.
Именно эта часть определяет то как именно будет эмулироваться присутствие
конкретно этого устройства в системе; делает его модель особенной,
относительно других устройств, уникальной. При этом модель устройство является
частью инфраструктуры QEMU, и индивидуальная часть должна эмулировать
поведение устройства, используя
предоставленные посредством API QEMU возможности. В модели всегда можно
выделить часть кода
взаимодействующую с этим API, она и называется _интерфейсной_. То есть,
интерфейсная часть кода
служит связкой между кодом индивидуальной части модели и окружающей средой.

Индивидуальная часть обычно сформулирована на естественном языке в документации
на устройство. При этом отсутствует единый формат _формального_ описания,
которого бы придерживались производители.
Ввиду этого автоматизация разработки этой части весьма затруднительна и
выходит за рамки этой работы.

С другой стороны, интерфейсная часть всех устройств очень похожа. Отличия
заключаются, в основном, в перечне и количестве используемых моделью внешних
интерфейсов, а также в именах собственных, которые часто формируются из
названия модели устройства путём применения к нему формализованных правил,
сформулированных или _де-факто_ (в коде существующих устройств), или в
тексте из файла `CODING_STYLE`, описывающим принятый в проекте стиль
программирования.

Опираясь на формализуемость правил написания интерфейсной части можно
разработать программу, принимающую небольшое количество понятных параметров
и возвращающую компилируемый код-шаблон, реализующий минимальный функционал
и готовый к внесению в него индивидуальной логики вручную. Таким образом,
программист, ознакомившись с техническим описанием устройства, может
формально сформулировать перечень требуемых модели устройства интерфейсов
и, применив разработанный инструмент, приступить непосредственно к
реализации индивидуальной части.

Отдельно нужно сказать о вычислительных машинах. Хотя описания вычислительных
машин, аналогично устройствам, лишены формализма и единообразия, в QEMU
присутствует развитое API для интеграции устройств в единое целое (то есть в
ВМ).
Состав ВМ определяется функцией её инициализации, которая последовательно
создаёт все устройства и соединяет их воедино. В данной работе реализован
программный интерфейс, позволяющий описать состав ВМ и сгенерировать её
функцию инициализации. Интерфейс реализован на языке Python, поэтому описание
получается несколько короче, чем соответствующий ему генерированный код. Но
основное преимущество заключается в возможности написания графического
интерфейса, значительно повышающего наглядность и скорость описания ВМ. Таким
образом, отсутствие формализованного описания ВМ смягчается удобством
компоновки ВМ по этому описанию.

С помощью этого API можно формально описать полноценную ВМ. При этом
имеются следующие ограничения.

1. Устройства, входящие в ВМ, должны иметь интерфейсную часть реализованную в
полном соответствии с текущим подходом к встраиванию устрйоств.

2. Сформулированная машина сильна ограничена в настройке.

В QEMU присутствует ряд устройств, которые были реализованы еще до того, как
был выработан текущий подход к встраиванию устройств. На данный момент
не все из них были переписаны в соответствии с этим подходом. То есть они
реализуют свою индивидуальную часть в обход новейших возможностей API для
интерфейсной части.

Первое ограничение не существенно,
если преобладающая часть устройств ВМ реализуется вместе с ней по формальному
описанию. Такие устройства будут иметь совместимую интерфейсную часть. Если
же нужно использовать существующую модель устройства, то возможны следующие
варианты.

* Скорректировать реализацию устройства.

* Вписать код, выполняющий его подключение в ВМ, в функцию инициализации после
её генерации. Этот вариант существенно ограничивает возможности инструмента:

    * устройство должно будет подключаться к шине вручную;

    * если устройство --- мост, то и его шины должны будут подключаться также
вручную;

    * подключение прерываний придётся выполнять вручную;

    * в общем случае, отсутствие возможности сослаться на устройство из API
при проектировании устройства приведёт к снижению количества автоматизированной
работы.

Второе ограничение заключается в следующем.
Сгенерированная ВМ зафиксирована на уровне исходного кода. То есть, в
неё будет проблематично добавить новое устройстве и невозможно удалить
имеющееся. CLI QEMU поддерживает ряд ключей, динамически создающих
дополнительные устройства (например, можно подключить к шине PCI новую
функцию). Также часть параметров машины заведомо требуется от пользователя,
например, файл-образ ПЗУ (НЖМД, микросхема flash-памяти, CD, и т.п.),
оконечную точку УАПП (виртуальный терминал, файл, и т.п.), способ подключения
сетевого порта (TAP-адаптер, Ethernet по UDP и т.п.) и т.д.

### Метод шаблонов

Как уже отмечалось, код интерфейсной части всех устройств достаточно
единообразен, чтобы его можно было получить из некоторого набора строковых
заготовок, путём подстановки параметров.

Часто для одного интерфейса необходимо сгенерировать несколько фрагментов кода.
При этом фрагменты должны следовать в правильном порядке как относительно
друг друга, так и фрагментов других интерфейсов. Это требование следует из
синтаксиса языка Си. Например, если один из аргументов функции является
указателем на структуру, то сама структура должна быть объявлена выше.

Часть параметров одних шаблонов может быть связана с параметрами других
шаблонов. Например, функция инициализации устройства, является частью шаблона,
встраивающего устройство в иерархию типов QOM. Если же устройство имеет
регистр MMIO, то для него применяется другой шаблон. Но регистр должен быть
зарегистрирован в функции инициализации. А значит, имя переменной, описывающей
регистр, является параметром шаблона функции инициализации.

Символы API QEMU должны быть доступны в сгенерированных файлах. Для этого
нужно включить (директивой `#include`) соответствующие заголовочные файлы.
Список этих файлов может быть автоматически вычислен по перечню использованных
символов. При этом, код будет выглядеть лучше, если минимизировать список
заголовочных файлов.

Эти и другие тонкости учтены в модели, используемой системой. При этом нельзя
сказать, что она закончена, так как периодически обнаруживаются случаи,
требующие её модификацию. Здесь представлено описание модели, используемой
в текущей версии.

### Программный интерфейс модели QEMU

Значительная часть сложной системы взаимосвязей шаблонов может быть создана
автоматически. От пользователя требуется небольшое количество интуитивно
понятных параметров. Это достигается разработанным API, скрывающим от него
сложность взаимосвязи шаблонов. Пользователь настраивает генерацию кода
посредством ниже перечисленных классов.

Видимая пользователю иерархии классов построена по тому-же принципу, что и
иерархия классов QOM. Таким образом, он легко сможет сопоставить
соответствующие классы.

Реализована следующая иерархия классов.

* `QOMDescription`
    * `SysBusDeviceDescription`
    * `PCIExpressDeviceDescription`
    * `MachineNode`

`QOMDescription` является базовым классом. Он не предназначенный для
использования.

`SysBusDeviceDescription` описывает устройство на системной шине.

`PCIExpressDeviceDescription` описывает PCI устройство. PCI _устройство_
в QEMU соответствует одной _функции_ реального устройства. QEMU не моделирует
физические взаимодействия по шине. Поддержка MSI (а именно реакция на
запись сообщения в память) реализуется главным мостом, обычно являющимся
устройством на системной шине. Как следствие, и PCI, и PCI Express устройство
может быть описано через этот класс.

`MachineNode` описывает ВМ и входящие в её устройства.

Перечисленные классы выполняют роль контейнеров для параметров. При генерации
кода на основе этих параметров создаются классы внутреннего API,
непосредственно участвующего в генерации.

В то время как для описания устройств системной шины или PCI достаточно базовых
типов, для описания устройств, входящих в ВМ, требуется ещё одно дерево
классов. Причём в это дерево включает классы, описывающие то же самое, что и
перечисленные выше классы. А именно: устройства системной шины и PCI. Тем не
менее, они описывают эти устройства с разных точек зрения:

* первые содержат перечень использованных в модели устройства элементов API
  QEMU;
* вторые же описывают способ подключения устройств.

Поскольку часть элементов API QEMU способствуют единообразию подключения
устройств в машину, то вторые могут быть вычислены из первых. Однако это
является одним из направлений дальнейших исследований.

Совместно объекты этих классов образуют _проект_ (`QProject`): контейнер с
данными для генератора кода.

### Модель вычислительной машины

Содержимое ВМ описывается с использованием следующей иерархии классов.

* `Node`
    * `BusNode`
        * `SystemBusNode`
        * `PCIExpressBusNode`
        * `ISABusNode`
        * `IDEBusNode`
        * `I2CBusNode`
    * `DeviceNode`
        * `SystemBusDeviceNode`
        * `PCIExpressDeviceNode`
    * `IRQLine`
    * `IRQHub`
    * `MemoryNode`
        * `MemoryLeafNode`
            * `MemoryAliasNode`
            * `MemoryRAMNode`
            * `MemoryROMNode`

`Node` содержит уникальный идентификатор узла ВМ.

`BusNode` содержит все данные, необходимые чтобы описать шину любого типа. Все
дочерние классы конкретизируют эти данные. Они были введены для сокращения
объёма кода, необходимого для добавления шины вручную. При использовании
графического интерфейса это не актуально.

Большинство параметров шины определяют генерацию кода для шины этого типа. И
только следующие параметры определяют место шины в ВМ:

* ссылка на устройство-мост (родительское), контролирующее эту шину;
* ссылки на устройства, подключённые к шине (дочерние).

`DeviceNode` описывает параметры, присущие любому устройству:

* модель устройства (листовой тип в дереве типов QOM);
* ссылку на шину, к которой подключено это устройство (родительскую);
* ссылки на контролируемые (дочерние) шины, если устройство является мостом;
* список значений свойств устройства, как объекта QOM.
* ссылки на привязанные прерывания с параметрами их привязки.

`IRQLine` (линия) и `IRQHub` (концентратор) описывают распространение
прерываний между устройствами (ту его часть, которая по какой-то причине не
спрятана в шину). Концентратор прерываний используется в случаях, когда одно
прерывание должно быть доставлено в несколько устройств и/или может быть
получено из нескольких устройств (так как линия прерывания соединяет строго
два узла). Линия содержит информацию об _источнике_ и _приёмнике_ прерывания.
Причём для каждого конце, являющегося устройством, определены:

* ссылка на устройство;
* индекс порта прерывания в группе прерываний;
* имя группы прерываний.

Если концом является концентратор, то достаточно только ссылки.

Большую часть адресного пространства ВМ определяют сами устройства. В адресное
пространство входят MMIO и BAR (PCI) регистры устройств, блоки памяти ROM
устройств и т.д. Однако, такие диапазоны как адресное пространство PCI, RAM
и т.п. должны быть определены отдельно. Причём в некоторых случаях адресное
пространство PCI создаётся главным мостом, а в некоторых создаётся
функцией инициализации машины и передаётся мосту как параметр.

`MemoryNode` описывает интервал-контейнер, содержащий в себе другие интервалы
со смещением, относительно своего начала.

`MemoryLeafNode` (лист) является служебным промежуточным классом, запрещающим
добавлять интервалы в интервалы, не являющимися контейнерами.

`MemoryAliasNode` (псевдоним) используется, чтобы обеспечить доступ к
интервалу (или его отрезку) из другого адреса.

`MemoryRAMNode` и `MemoryROMNode` описывают непрерывный интервал эмулируемой
физической памяти. Причём `MemoryROMNode` нельзя менять.

Каждый из перечисленных классов, описывающих интервал памяти, имеет следующие
параметры:

* отладочное строковое имя;
* размер;
* смещение в контейнере и ссылку на него;
* допустимость перекрытия в пределах одного контейнера и приоритет для его
  разрешения;

`MemoryNode` _может_ иметь непустой список ссылок на детей, а
`MemoryAliasNode` _должен_ содержать смещение в пределах интервала, на который
он перенаправляет запросы к себе, и ссылку на него.

Каждый из перечисленных классов (включая потомков `QOMDescription`)
является контейнером для параметров. Их основные функции:

* хранение настроек пользователя,
* сохранение настроек в файл и обратно,
* взаимодействие с графическим интерфейсом.

### Формат файлов

Настройки генерации устройств и ВМ собраны в единый _проект_. Проект
описывается классом `QProject` (QEMU project). При работе с ГИ используется
его подкласс `GUIProject` (GUI project), дополнительно хранящий настройки
отображения.

Проект сохраняется в файл в текстовом формате, совместимым с синтаксисом
языка Python. Сохранённый проект представляет собой _почти_ корректную
программу на языке Python, результатом выполнения которой является
определение переменой ссылающейся на объект класса `QProject` (или
`GUIProject`, в случае ГИ), _эквивалентный_ объекту, сохранённому в
файл. Программа используется имена из пользовательского API. Генератор
файлов сохранений изначально разрабатывался таким образом, чтобы файлы
выводились в удобном для человека формате. В сгенерированной
программе отсутствуют инструкции импорта необходимых имён (это
возложено на загрузчик файла), поэтому программа не является корректной.

Под _эквивалентностью_ сохранённого и восстановленного объекта понимается:

* равенство значений простых типов в соответствующих атрибутах;
* каждый ссылочный атрибут в восстановленном объекте указывает на
объект эквивалентный тому, на который этот атрибут указывал в
сохранённом объекте (ссылки на `None` восстанавливаются как ссылки на
`None`).

При сохранении не гарантируются:

* равенство _незначащих_ пробельных символов;
* синтаксически не значащий порядок фрагментов кода (порядок определения
аргументов конструкторов со значениями по умолчанию, порядок
восстановления несвязанных объектов, и т.п.);
* сохранность комментариев, если таковые были внесены вручную в файл
проекта.

Данные особенности создают сложности при ручной работе с файлами проекта,
а также при хранении файлов с использованием системы контроля версий.
Решение этой проблемы является одним из направлений дальнейших исследований.

## Графический интерфейс

Все возможности инструмента доступны пользователю посредством API. Для
описания устройств и ВМ достаточно произвольного текстового редактора.
Однако применение ГИ, спроектированного _специально_ для работы с API,
имеет следующие преимущества.

* Исключены лексические ошибки в именах элементов API и синтаксические
ошибки, т.к. пользователь водит только значения параметров.

* Для многих значений параметров в QEMU определены макросы,
использование которых предпочтительней, согласно _хорошему тону
программирования_. ГИ интерфейс, проанализировав код QEMU, может
предоставить пользователю список доступных макросов, обычно применяемых
с данным типом параметра. Например, идентификатор PCI, родительский
тип QOM, свойство QOM и т.п.

* Исключены некоторые семантические ошибки (например, в ГИ не
предусмотрена возможность соединения линией прерывания двух шин, в то
время как пользователь волен написать всё, что угодно в текстовом
редакторе). Имеется возможность дополнить ГИ средствами поиска менее
очевидных семантических ошибок.

* Все доступные параметры сосредоточены в _виджетах_ с названиями на
естественном языке. В большинстве случаев знания QEMU достаточно, чтобы
понять суть параметра, не обращаясь к справочной информации.

* Интерпретация ВМ в виде схемы.

### Обратимые операции

Современный редактор должен предоставлять средства по работе с изменениям.
Минимальный перечень возможностей: _отмена_ и _повторение_. В разработанном
ГИ контроль изменений пользователя реализован с использованием абстракции
_обратимых операций_.

Обратимая операция содержит следующую информацию:

* данные, необходимые для осуществления действия;
* данные, необходимые для возврата к состоянию до осуществления действия;
* флаг завершённости операции;
* ссылки на предшествующие и последующие операции, позволяющие перемещаться
вдоль истории изменений;
* описание действия, выполняемого операцией, на естественном языке для
пользователя.

ГИ построен таким способом, что любые изменения в проекте должны
быть осуществлены через абстракцию "_трекер истории_" (`HistoryTracker`).
То есть, для выполнения действия ГИ создаёт операцию, добавляет её в
историю и даёт команду на выполнение трекеру. Данный процесс скрыт от
пользователя реализацией кнопки "_Применить_".

В памяти всегда присутствует состояние проекта, соответствующее перечню
выполненных операций. Поддержание этого соответствия --- задача трекера.
Действия по отмене и повторению операций выполняются с использованием его
методов.

<!--
Часто сделанная в прошлом операция не связана с операциями сделанными после
неё. Такая операция может быть отменена без отмены последующих операций.
Формально, в будущем не должно быть операций, _зависящих_ от отменяемой
операции. Операция называется зависящей от _предшествующей_ операции, если
предшествующая операция:
1. изменяет то, что операция потом изменяет повторно;
2. создаёт то, что операция потом использует (для выполнения своего
действия), изменяет или удаляет;
3. удаляет то, что операция потом создаёт.

Операция, изменяющая что-то перед его удалением, здесь считается
независимой относительно удаляющей с тем условием, что при отмене
изменяющей операции будут обновлены данные в удаляющей, т.к., очевидно,
что удаляющая операция содержит в себе последнюю копию утрачиваемых
данных удаляемого объекта.
-->

### Обратная связь при изменениях

Текущие значения параметров проекта влияют не только на значения,
представленные в виджетах. Они также могут влиять на:

* выбор типа виджета (тип свойства QOM объекта определяет, какой виджет
должен быть использован для представления его значения);
* существование виджета (при удалении узла ВМ должны исчезать
виджеты его редактирующие);
* перечень допустимых значений (выпадающий список выбора дочерней
шины для устройства должен отображать список всех допустимых шин,
имеющихся в ВМ, и он должен корректироваться при добавлении или
удалении очередной шины);
* формулировка допустимых значений (если был изменён индекс шины
в мосте, все списковые виджеты должны скорректировать текст в
соответствующих строках).

Это не полный перечень зависимостей. При этом, любое значение
может быть изменено _минимум_ двумя способами:

* через соответствующий виджет;
* отменой или повторением правки пользователя.

Для учёта произвольных зависимостей в ГИ применяются _события_. Каждый
виджет добавляет свой метод обратного вызова в список
_наблюдателей_ трекера. При выполнении операции трекер уведомляет всех
наблюдателей о выполнении операции. Наблюдатель должен выбрать
операции, относящиеся к виджету и среагировать соответствующим образом.

### Сопрограммы и фоновые вычисления

Стандартом _де-факто_ при разработке ГИ является применение событийно-
ориентированного программирования, при котором непозволительно выполнять
длительные вычисления при обработке события. Так как это приводит к
"подтормаживанию" интерфейса и снижению удобства.

Встраивание длительных вычислений в ГИ принято производить следующими
способами:

* вынос вычислений в отдельный процесс или нить;
* фрагментация (вычисления разбиваются на малые фрагменты, которые
могут быть быстро выполнены при обработке события, и выполняются
в течение обработки специализированных событий).

Для реализации фрагментации удобно использовать "сопрограммы" --- функции
позволяющие передавать управление другой сопрограмме раньше
выхода, "замораживая" своё состояние, а затем получать его в
то же место, откуда оно было передано (при этом сохраняются все
локальные переменные).

Python, в свою очередь, имеет языковую поддержку т.н. _генераторов_ ---
сопрограмм способных дополнительно вернуть значение при очередной передаче
управления (инструкцией `yield`).

В ГИ длительные вычисления реализуются генераторами. Долго работающие
функции реализуются как сопрограммы, снабжаясь операторами `yield` через
каждый фрагмент вычислений. Управление между сопрограммами распределяется
_диспетчером_, встраиваясь между обработкой событий ГИ.

В ГИ в фоне выполняются следующие задачи:

* анализ исходного кода QEMU;
* предварительное вычисление эвристик о текущей версии QEMU;
* генерация кода;
* уведомления о событиях (т.н. _сигналы_), не требующих синхронной
обработки;
* динамическое размещение узлов ВМ на диаграмме (опция позволяющая
избегать взаимного прекрытия изображений узлов).

Выбор в пользу фрагментации, был сделан с целью упрощения разработки:

* исключено состояние гонки, не требуется синхронизация, нет параллельных
ошибок, легче отладка;
* в Python нити выполняются синхронно, причём встроенный
планировщик не различает приоритетных вычислений при обработке событий
ГИ в реальном времени от фоновых вычислений, что приводит к "подтормаживанию";
для реальной параллельности требуется использовать сторонние библиотеки;
* для реализации параллельности требуется больше кода;
* в инструменте отсутствуют _регулярные_ сложные вычисления: достаточно
одного процесса.

### Диаграмма вычислительной машины

ВМ состоит из множества элементов, которые связаны между собой
различными способами. Схема позволяет пользователю видеть основные
связи в ВМ, не прибегая к интерпретации текстового описания в воображении.

Полезной функцией является экспорт диаграммы в векторное изображение.
Это экономит значительное количество времени пользователя при
написании сопряжённых текстов. Например, иллюстрации, представленные
в этой статье, получены автоматизированно с использованием данной
функции.

### Динамический текст, интернационализация

В ряде случаев требуется удобный механизм, позволяющий обновлять текст
в уже созданных виджетах. Библиотека Tkinter[[Tkinter](#Tkinter)]
поддерживает изменение текстовой информации в виджетах, но способы
варьируются от класса к классу. Также требуется хранить ссылки
на все виджеты, где используется переменный текст. Наконец, нужен
механизм уведомления об изменениях. В библиотеке уже реализовано дерево
классов для реализации переменных, поддерживающих уведомления.
В частности, класс `StringVar` имеет методы `set` и `get`, для доступа
к значению, и метод `trace_variable`, назначающий функцию обратного
вызова по его изменению.

Для наиболее часто используемых классов виджетов были разработаны
классы-оболочки, принимающие переменные класса `StringVar` в качестве
значений текстовых параметров. Используя `trace_variable`, они
прозрачно для остального кода выполняют обновление соответствующих
полей обёртываемых объектов. Таким образом, для изменения текста во
время выполнения достаточно вызвать метод `set`. Это также унифицирует
механизм изменения текста в виджетах.

Особый интерес представляют динамические строки, являющиеся результатом
форматирования. Причём, как исходная строка форматирования, так и
использованные значения могут быть динамическими.
Когда меняется строка форматирования или любое из значений,
использованных в подстановке, требуется пересчитать производное
значение. В работе был реализован класс `FormatedStringVar` с этим
функционалом. Он используется в связке с классом `FormatVar`
реализующим оператор `%` для класса `StringVar`. Это даёт возможность
использовать динамические строки, как строки форматирования,
синтаксически так же как обычные строки Python. Данные классы совместимы
с виджетами-оболочками, так как наследованы от `StringVar`.

В проекте повсеместно используются виджеты классов-оболочек. Это
упрощает реализацию следующего функционала:

* динамическое изменение языка интерфейса, в том числе строк описания
операций редактирования проекта, полученных путём форматирования;
* обновление подсказок о клавишах быстрого доступа;
* обновления текстов, зависящих от значений параметров проекта.

Распространённым способом интернационализации интерфейса является
составление базы соответствия между текстом, использованным непосредственно,
и переводом этого текста на каждый поддерживаемый язык. Стандартом _де-факто_
является применение библиотеки `gettext` (или её аналога для соответствующего
языка). Она работает именно таким образом. Для перевода текстов в данном
инструменте используется её оболочка для языка Python. Многие приложения
используют функционал `gettext` для перевода текстов непосредственно при
создании виджетов. При этом изменение языка требует перезагрузки ГИ после
изменения выбранной локализации. Применение динамических строк в ГИ данного
инструмента исключает эту необходимость. В том числе и для случаев, когда
переведённая строка используется не непосредственно, а, например, как строка
форматирования.

## Шаблоны

Основой генерации кода интерфейсной части моделей устройств являются шаблоны.
Тут под шаблоном понимается строка, в которой присутствуют _метки_, заменяемые
при генерации требуемыми строками. Программно это соответствует двум способам,
имеющимся в языке Python:

* оператор `%` нахождения остатка от деления, перегруженный для строк,
осуществляет замену меток подобно функции `sprintf` стандартной библиотеки Си;
* метод `format` определённый для строк, поддерживающий свой синтаксис меток.

Второй вариант используется для написания более сложных шаблонов, т.к. в
шаблонах написанных на нём легче ориентироваться, однако они получаются
длиннее.

В текущей реализации инструмента даже при написании шаблонов ручное
редактирование почти полностью заменено на написание кода на языке Python,
для чего специально разработано API. Подробно это API рассматривается в
главе "[Генерация кода](#Codegeneration)". Ниже приводится список шаблонов,
реализованных для генерации интерфейсной части устройств.

### Объектная модель QEMU

Объектная модель QEMU (QEMU Object Model --- QOM), предусматривает классы,
от которых должно наследоваться устройство предназначенное для конкретной шины.
Наиболее распространёнными являются устройства системной шины и устройства
PCI. В настоящее время инструмент поддерживает генерацию заготовок для
устройств этих шин. А также сопутствующих элементов интерфейсной части.
Кроме того некоторые части интерфейсного API универсальны относительно шины
устройства, при этом они почти всегда используются в моделях. Модель ВМ
аналогично должна быть наследована от соответствующего типа QOM.

Ниже приводятся примеры сгенерированного кода для различных шаблонов.
Описание [было приведено во введении](#Introduction).

### Вычислительная машина

Следующий код определяет минимальную ВМ.

```c
/* Пустая функция инициализации машины (её не следует путать с конструктором
   объекта). В этой функции должно происходить создание и связывание
   устройств. */
static void init_q35_test(MachineState* machine) {}

/* Конструктор класса. Он определяет имя машины и описание, а также
   регистрирует функцию инициализации .*/
static void machine_q35_test_class_init(ObjectClass* oc, void* opaque)
{
    MachineClass *mc = MACHINE_CLASS(oc);

    mc->name = "q35_test";
    /* Описание генерируется равным имени. Это технически верно, но
    разработчику следует вручную его изменить. Например так:
    "Test implementation of Q35 chipset". */
    mc->desc = "q35_test";
    mc->init = init_q35_test;
}

/* Описание нового типа. Для машины требуется минимум информации: имя
   нового типа, имя родительского типа и конструктор класса. */
static TypeInfo machine_type_q35_test = {
    /* TYPE_MACHINE_SUFFIX - обязательный суффикс для имён типов машин */
    .name = "q35_test" TYPE_MACHINE_SUFFIX,
    .parent = TYPE_MACHINE,
    .class_init = machine_q35_test_class_init
};

/* Обеспечивает регистрацию описания нового типа в инфраструктуре QEMU. */
static void machine_init_q35_test(void)
{
    type_register(&machine_type_q35_test);
}

/* Макрос, раскрывающийся в конструктор модуля, согласно способу
   соответствующему компилятору. Конструктор обеспечивает вызов
   machine_init_q35_test. */
type_init(machine_init_q35_test)
```

Генерированный код приведён без изменений, включая форматирование. Только
комментарии добавлены вручную для ясности примера: в реально генерируемом
коде они отсутствуют.

Здесь и во многих последующих примерах не приведены директивы `include`.
Это сделано
для экономии места. Стоит отметить, что для реальной ВМ количество заголовков
с учётом реализованной оптимизации достигает нескольких десятков. Это в
первую очередь связано с тем, что почти каждое устройство имеет свой заголовок.

### GPIO и прерывания

Прерывания реализуются пр помощи _обратных вызовов_. Параметры обратного вызова
хранятся в структуре `IRQState`. Для ссылки на эту структуру определён
специальный тип указателя `qemu_irq`. _Источник_ содержит содержит поле
`qemu_irq` в _структуре объекта_. _Приёмник_ прерывания инициализирует
`IRQState`, память под которую обычно выделяется из _кучи_ в процессе
создания прерывания. Для соединения двух устройств линией прерывания в поле
типа `qemu_irq` источника записывается адрес структуры `IRQState` приёмника.
Операции с этими типами данных обёрнуты в специальное GPIO API. Более того,
для распространённых шин (системной, PCI) используются свои оболочки. Само же
GPIO API оборачивает прерывания в свойства объектов QOM с именами специального
вида.

Организация исходящих прерываний сильно отличается от шины к шине и будет
рассмотрена далее. С другой стороны, входящие прерывания часто реализуются
контроллером прерываний или мостом. Более того реализация контроллера (моста)
как раз и определяет собственный API, которым должны пользоваться устройства.
В настоящее время инструмент не поддерживает создание новых шин, а значит и
мостов к ним. Инструмент способен сгенерировать заготовку для контроллера
прерываний на системной шине, главного моста PCI или альтернативного
моста PCI-PCI.

Прерывания _внутри_ PCI реализуются иначе, без использования `IRQState`.
Главный мост PCI является _композицией_ минимум из двух устройств: интерфейса
на системной шине и конфигурационного пространства (PCI-устройства). Для
приёма входящих прерываний он использует внутренне API для PCI. Таким образом,
генерация заготовок для входящих прерываний в данном инструменте предусмотрена
только для реализации контроллера прерываний на системной шине. При этом
используется GPIO API, что позволяет реализовать другие виды устройств на
системной шине, имеющие входящие прерывания.

Пример заготовки для организации входящих прерываний приведён ниже.

```c
/* Обработчик входящего прерывания. */
static void a20_line_irq_handler(void* opaque, int n, int level)
{
    __attribute__((unused)) A20LineState *s = A20_LINE(opaque);
}

static void a20_line_instance_init(Object* obj)
{
    /* Другой код */
    /* При регистрации обработчика указывается количество входящих прерываний.
       Макроподстановка A20_LINE_IN_IRQ_NUM определена в заголовке
       соответствующего устройства. */
    qdev_init_gpio_in(DEVICE(obj), a20_line_irq_handler, A20_LINE_IN_IRQ_NUM);
    /* Другой код */
}
```

Фрагмент кода приведён без изменений, все комментарии добавлены вручную.

### Устройства системной шины

Устройства системной шины являются самыми распространёнными. Интересной
особенностью является то, что системные шины разнятся от процессора к
процессору. В то же время все они обеспечивают один и тот же функционал.
Эта особенность позволяет разработчикам QEMU не плодить модели системных
шин и единообразно писать модели системных устройств.

Пример заготовки системного устройства приведён ниже.

#### Заголовок устройства системной шины
Заголовок устройства обеспечивает доступность модели остальному коду QEMU и,
в особенности, моделям ВМ, использующим его.
```c
#ifndef INCLUDE_IO_PORT_80_H /* Защита от двойного включения заголовка. */
#define INCLUDE_IO_PORT_80_H
/* В sysbus.h опредлена структура SysBusDevice, используемая при определении
   структуры объекта нового типа. */
#include "hw/sysbus.h"

/* Макрос, используемый для динамического приведения типов. */
#define IO_PORT_80(obj) OBJECT_CHECK(IOPort80State, (obj), TYPE_IO_PORT_80)
/* Макроподстановка идентификатора модели устройства. */
#define TYPE_IO_PORT_80 "io_port_80"
typedef struct _IOPort80State {
    /* Структура объекта родительского класса всегда первая. */
    SysBusDevice parent_obj;
    /* Другие поля. */
} IOPort80State;

#endif /* INCLUDE_IO_PORT_80_H */
```
Сгенерированный код заголовка приведён полностью. Все комментарии дописаны
для наглядности. Остальной код соответствует выходу генератора.

#### Код модуля системного устройства
Само устройство реализуется в отдельном файле `*.c` --- _модуле_.
```c
/* Конструктор объекта. */
static void io_port_80_instance_init(Object* obj)
{
    /* Аттрибут unused добавляется для обхода ошибок компиляции. В QEMU наличие
       неиспользованной переменной в функции считается за ошибкоу. Когда
       разработчик реализует логику этой функции, этот аттрибут должен быть
       удалён. Кроме того, использование других шаблонов совместно в этой
       модели приводит к наполнению этой функции кодом. В этом случае
       этот аттрибут не генерируется вообще. */
    __attribute__((unused)) IOPort80State *s = IO_PORT_80(obj);
}

static void io_port_80_realize(DeviceState* dev, Error** errp)
{
    __attribute__((unused)) IOPort80State *s = IO_PORT_80(dev);
}

/* Функция предусматривает сброс устройства в начальное состояние.
   Например, при перезагрузке ВМ. */
static void io_port_80_reset(DeviceState* dev)
{
    __attribute__((unused)) IOPort80State *s = IO_PORT_80(dev);
}

static void io_port_80_class_init(ObjectClass* oc, void* opaque)
{
    DeviceClass *dc = DEVICE_CLASS(oc);

    dc->realize = io_port_80_realize;
    dc->reset   = io_port_80_reset;
}

static TypeInfo io_port_80_info = {
    .name          = TYPE_IO_PORT_80,
    .parent        = TYPE_SYS_BUS_DEVICE,
    .instance_size = sizeof(IOPort80State),
    .instance_init = io_port_80_instance_init,
    .class_init    = io_port_80_class_init
};

static void io_port_80_register_types(void)
{
    type_register_static(&io_port_80_info);
}

type_init(io_port_80_register_types)
```
Такое устройство может быть скомпилировано и создано при инициализации ВМ, но
оно не будет никак себя проявлять в системе. Любое реальное устройство
может иметь регистр, отображенный на память (MMIO), исходящее и/или входящее
прерывание. Примеры этого приведены ниже.

#### MMIO и PMIO

Заготовка отображения регистров устройства на память выглядит следующим
образом. Помимо представленного кода в структуру объекта добавляется поле
`mmio`.
```c
/* Пара функций: обработчики записи в регистр устройства и чтения. */
static void a20_line_mmio_write(void* opaque, hwaddr addr, uint64_t data, \
    unsigned size)
{
    __attribute__((unused)) A20LineState *s = A20_LINE(opaque);

    switch (addr) {
    /* Для удобства отладки шаблон предусматривает только генерацию сообщения
       об обращении к нереализованному регистру. Реализация регистров
       заключается в добавлении `сase` блоков для обработки доступа к
       соответствующим смещениям регистров относительно условного стартового
       адреса. Т.е. одна пара функций может реализовывать сразу несколько
       регистров. Обычно за условный стартовый адрес принимают адрес регистра с
       наименьшим смещением. */
    default:
        printf("%s: unimplemented write to 0x%"HWADDR_PRIx", size %d, "
                "value 0x%"PRIx64"\n", __FUNCTION__, addr, size, data);
        break;
    }
}

static uint64_t a20_line_mmio_read(void* opaque, hwaddr addr, unsigned size)
{
    __attribute__((unused)) A20LineState *s = A20_LINE(opaque);
    uint64_t ret = 0; /* Функция чтения должна вернуть что-нибудь. */

    switch (addr) {
    default:
        printf("%s: unimplemented read from 0x%"HWADDR_PRIx", size %d\n",
            __FUNCTION__, addr, size);
        break;
    }

    return ret;
}

/* Параметры одного отображения группируются в специальную структуру. */
static MemoryRegionOps a20_line_mmio_ops = {
    .read = a20_line_mmio_read,
    .write = a20_line_mmio_write
};

static void a20_line_instance_init(Object* obj)
{
    A20LineState *s = A20_LINE(obj);
    /* Другой код. */
    /* Инициализация отображения. */
    memory_region_init_io(&s->mmio, obj, &a20_line_mmio_ops, s, TYPE_A20_LINE, \
        A20_LINE_MMIO_SIZE);
    /* Данный вызов регистрирует это отображение именно как MMIO отображение
       на адресное пространство системную шину. */
    sysbus_init_mmio(SYS_BUS_DEVICE(obj), &s->mmio);
    /* Другой код. */
}
```

IBM PC совместимые ВМ имеют также шину LPC. По историческим причинам она
тесно переплетена с системной шиной в QEMU. Эта шина позволяет устройствам
отображать свои регистры не только на адресное пространство памяти, но и на
независимое адресное пространство портов ввода/вывода. Этот механизм
известен как PIO или PMIO. Добавление PMIO-регистров к заготовке устройства
отличается от добавления MMIO-регистров только способом регистрации
отображения. Пример регистрации PMIO приведён ниже.

```c
static void io_port_80_instance_init(Object* obj)
{
    /* Другой код. */
    memory_region_init_io(&s->pio, obj, &io_port_80_pio_ops, s, \
        TYPE_IO_PORT_80, IO_PORT_80_PIO_SIZE);
    /* Основное отличие MMIO и PMIO регистров системной шины IBM PC совместимых
       ВМ заключается в строчке ниже. */
    sysbus_add_io(SYS_BUS_DEVICE(obj), IO_PORT_80_PIO_ADDR, &s->pio);
    /* Данный код привязывает отображение к конкретному адресу. В общем случае,
       привязка возлагается на функцию инициализации ВМ. Но в LPC устройства
       не поддерживают свободное перемещение по адресам. Протокол шины таков,
       что мост лишь по ответу устройства понимает, что они присутствует в
       системе. На какие адреса отвечать --- это решает разработчик
       устройства. */
    sysbus_init_ioports(SYS_BUS_DEVICE(obj), IO_PORT_80_PIO_ADDR, \
        IO_PORT_80_PIO_SIZE);
    /* Другой код. */
}
```

#### Исходящие прерывания

Заготовка устройства системной шины для каждого исходящего прерывания
имеет поле `qemu_irq` в структуре объекта. Объявления исходящего прерывания
происходит следующим образом.

```c
static void io_port_f0_instance_init(Object* obj)
{
    IOPortF0State *s = IO_PORT_F0(obj);
    /* Другой код */
    /* Регистрация одного исходящего прерывания, соответствующего полю out_irq.
       В случае регистрации нескольких прерываний важен порядок,
       т.к. используется неявная нумерация. */
    sysbus_init_irq(SYS_BUS_DEVICE(obj), &s->out_irq);
    /* Другой код */
}
```

Фрагмент кода приведён без изменений, все комментарии добавлены вручную.

### PCI

PCI-устройство в QEMU соответствует одной _функции_ реального PCI-устройства.
Функция представлена:

* конфигурационным пространством, где, среди прочего, содержится
идентификационная информация PCI;
* перемещаемыми регистрами (BAR), отображаемыми на адресное пространство PCI;
* четырьмя физическими прерываниями и несколькими логическими прерываниями
(MSI).

#### Идентификация

Конфигурационное пространство функции PCI является первичным интерфейсом
взаимодействия ПО с устройством. Опрашивая регистры конфигурационного
пространства с _идентификационной информацией_, драйвер опознаёт
соответствующее устройство, и, используя другие регистры осуществляет
предварительную настройку. В конфигурационном пространстве также содержится
множество другой информации, в том числе и времени выполнения.

Чтобы обеспечить видимость присутствия PCI-устройства в системе достаточно
следующей заготовки (для краткости часть кода заменена комментариями вида
"` -= ... =- `").

```c
/* -= конструктор объекта =- */

/* Базовый класс PCI-устройств перегружает методы realize и unrealize,
реализуя в них общую функциональность. PCI-функции должны перегружать
другую пару соответствующих методов: realize (несмотря на схожесть имён, это
разные методы) и exit, для добавления дополнительной логики. */
static void test_pci_card_realize(PCIDevice* dev, Error** errp)
{
    __attribute__((unused)) TestPCIcardState *s = TEST_PCI_CARD(dev);
}

static void test_pci_card_exit(PCIDevice* dev)
{
    __attribute__((unused)) TestPCIcardState *s = TEST_PCI_CARD(dev);
}

static VMStateDescription vmstate_test_pci_card = {
    .name = TYPE_TEST_PCI_CARD,
    .version_id = 1,
    .fields = (VMStateField[]) {
        /* Всякая PCI-функция должна добавить к своему состоянию поле,
           соответствующее структуре объекта родительского класса - PCIDevice,
           т.к. в ней содержится состояние конфигурационного пространства. */
        VMSTATE_PCI_DEVICE(parent_obj, TestPCIcardState),
        VMSTATE_END_OF_LIST()
    }
};

static void test_pci_card_class_init(ObjectClass* oc, void* opaque)
{
    DeviceClass *dc = DEVICE_CLASS(oc);
    PCIDeviceClass *pc = PCI_DEVICE_CLASS(oc);

    /* Важно, что метод перегружаются в PCIDeviceClass, а не в DeviceClass. */
    pc->realize   = test_pci_card_realize;
    pc->exit      = test_pci_card_exit;
    dc->vmsd      = &vmstate_test_pci_card;
    /* Последующие поля определяют идентификационную информацию об устройстве.
       Они не являются непосредственной частью конфигурационного пространства,
       но, на основании их значений конструктор объекта базового класса
       автоматически заполнит соответствующие регистры. */
    pc->vendor_id = PCI_VENDOR_ID_AMD;
    pc->device_id = PCI_DEVICE_ID_AMD_SCSI;
    pc->class_id  = PCI_CLASS_STORAGE_SCSI;
    pc->revision  = 0;
}

static TypeInfo test_pci_card_info = {
    .name          = TYPE_TEST_PCI_CARD,
    .parent        = TYPE_PCI_DEVICE,
    /* -= регистрация конструкторов и размера объекта =- */
};
/* -= код регистрации типа =- */
```

Код приведён без изменений, все комментарии добавлены вручную.

#### BAR

Перемещаемые регистры реализуются таким же образом, как и MMIO (PMIO) регистры.
Принципиальное отличие заключается в способе регистрации отображения.
От разработчика устройства требуется только зарегистрировать BAR-отображение.
Управление перемещаемыми регистрами осуществляется через конфигурационное
пространство. Соответствующая логика реализуется базовым классом PCI-устройств.

```c
/* -= обработчики доступа к отображению =- */

static MemoryRegionOps test_pci_card_mem_bar_ops = {
/* -= регистрация обработчиков доступа и других параметров отображения =- */
};

static void test_pci_card_realize(PCIDevice* dev, Error** errp)
{
    TestPCIcardState *s = TEST_PCI_CARD(dev);
    /* -= инициализация отображения в структуре объекта =- */
    /* Регистрация отображения как BAR. */
    pci_register_bar(&s->parent_obj, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, \
        &s->mem_bar);
    /* -= другой код =- */
}
```

Код приведён без изменений, все комментарии добавлены вручную.

#### Прерывания INTx и MSI

На шине PCI существует ряд способов сигнализации прерываний. В работе
рассматриваются:

* традиционная сигнализация по линиям INTx,
* сигнализация с помощью сообщений (MSI).

При традиционной сигнализации используется выделенные физические линии
(их обычно 4), к которым могут иметь доступ устройства на шине.
В конфигурационном пространстве предусмотрен регистр, через который можно
сообщить устройству, какую линию ему следует использовать. Устройства в
данном случае часто предсказуемы (т.е. они честно используют указанную линию).
Модель PCI-устройств в QEMU имеет вспомогательные функции для этого.
Поведение остальных участники распространения прерываний сильно отличается от
платформы к платформе:

* может быть разное количество физических линий;
* линии могут быть разведены к разным контактам на разных разъёмах.

Количество линий и способ внешней сигнализации определяется контроллером шины.
Также предусмотрена возможность настройки отображения контактов на физические
линии. Чтобы пользоваться традиционными прерываниями от устройства не требуется
инициализации. Сама сигнализация выполняется одной функцией. Т.е. для поддержки
традиционных прерываний не требуются шаблоны.

Традиционные прерывания имеют ряд недостатков. По этой причине были введены
прерывания основанные на пересылке сообщений (MSI). В последующем было
увеличено количество сообщений, доступных устройству (MSI-X). Пересылка
сообщения есть запись по настраиваемому адресу. Часто адрес соответствует
специализированному регистру в контроллере прерываний. Благодаря этому
контроллер максимально сразу оповещается о прерывании.

Наличие прерываний MSI --- особенность конкретного устройства. О наличии
свидетельствуют стандартные регистры в конфигурационном пространстве, которые
должны быть соответствующим образом настроены при создания устройства.
Инструмент позволяет сгенерировать соответствующую заготовку.

```c
static void test_pci_card_realize(PCIDevice* dev, Error** errp)
{
    /* -= Другой код =- */
    /* Инициализация MSI. */
    msi_init(dev, TEST_PCI_CARD_MSI_CAP_OFFSET, TEST_PCI_CARD_MSI_VECTORS, \
        TEST_PCI_CARD_MSI_64BIT, TEST_PCI_CARD_MSI_VECTOR_MASKING);
    /* -= Другой код =- */
}

static void test_pci_card_exit(PCIDevice* dev)
{
    /* -= Другой код =- */
    msi_uninit(dev); /* Отмена инициализации MSI. */
    /* -= Другой код =- */
}
```

Код приведён без изменений, все комментарии добавлены вручную.

При инициализации MSI требуется указать:

* смещение регистров в конфигурационном пространстве;
* количество векторов (значение должно быть степенью 2 в интервале [1, 32]);
* количество бит в адресе для записи сообщения (64 или 32);
* допустимость маскирования (отключения) сообщений.

Инструмент создаёт в заголовочном файле устройства макроподстановки с
со значениями этих параметров и использует их в коде инициализации.

### Таймеры

Таймеры используются для отсрочки действия относительно времени ВМ или времени
основной машины. В устройствах, в основном, используются первые. С их
помощью можно ограничить пропускную способность УАПП, реализовать периодические
прерывания и т.п.

Добавление заготовки таймера, помимо добавления указателя в заготовку структуры
объекта, включает следующий код.

```c
/* Функция, вызываемая по истечение времени таймера. */
static void io_port_80_timer_cb(void* opaque)
{
    __attribute__((unused)) IOPort80State *s = IO_PORT_80(opaque);
}

static void io_port_80_instance_init(Object* obj)
{
    IOPort80State *s = IO_PORT_80(obj);
    /* Другой код. */
    /* Создание таймера */
    s->timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, io_port_80_timer_cb, s);
}
```
Фрагмент кода приведён без изменений, все комментарии добавлены вручную.

Кроме этого таймер имеет часть состояния, которое должно быть сохранено в
снимке ВМ. Генерация соответствующего кода рассматривается ниже.

### Состояние времени выполнения

Как уже говорилось, модель любого реального устройства имеет переменные
времени выполнения, которые описывают мгновенное _состояние устройства_.
Чтобы сообщить QEMU список этих переменных конструктор класса должен
соответствующим образом инициализировать поле в структуре класса.
Пример объявления состояния устройства приведён ниже.

```c
static VMStateDescription vmstate_test_pci_card = {
    .name = TYPE_TEST_PCI_CARD,
    .version_id = 1,
    .fields = (VMStateField[]) {
        /* Любое PCI устройство должно сообщить, в каком поле своей структуры
           объекта содержится структура базового класса PCIDevice. Т.к. этот
           класс содержит часть состояния. Например, конфигурационное
           пространство PCI. Для сохранения этого состояния в QEMU даже
           предусмотрен специальный макрос. */
        VMSTATE_PCI_DEVICE(parent_obj, TestPCIcardState),
        /* Некоторые элемента API QEMU могут иметь состояние и соответствующие
           поля тоже должны быть объявлены. Например, таймеры. */
        VMSTATE_TIMER_PTR(timer_0, TestPCIcardState),
        VMSTATE_TIMER_PTR(timer_1, TestPCIcardState),
        VMSTATE_END_OF_LIST()
    }
};

static void test_pci_card_class_init(ObjectClass* oc, void* opaque)
{
    /* Другой код. */
    /* Регистрация описателя состояния в статической переменной класса. */
    dc->vmsd      = &vmstate_test_pci_card;
    /* Большой пробел перед = является следствием выравнивания всех
       присваиваний. В данном случае по следующему коду. */
    pc->vendor_id = PCI_VENDOR_ID_AMD;
    /* Другой код. */
}
```
Фрагмент кода приведён без изменений, все комментарии добавлены вручную.

Данный пример демонстрирует тесную связь между разными шаблонами. В частности,
добавление заготовки таймера к устройству также затрагивает заготовку
состояния устройства.

### Символьные устройства

Абстракция "символьное устройство" в QEMU применяется для унификации
поточного ввода/вывода. Распространённый пример: последовательный порт УАПП,
который может быть подключён к виртуальному терминалу, завернут в TCP
соединение, выведен в файл и мн.др. Такая вариативность как раз и достигается
использованием этой абстракции.

Инструмент позволяет сгенерировать следующую заготовку.

```c
/* Вызывается для чтения size байт, начиная с адреса buf. */
static void test_pci_card_chr_read(void* opaque, const uint8_t* buf, int size)
{
    __attribute__((unused)) TestPCIcardState *s = TEST_PCI_CARD(opaque);
}

/* Опрос устройства о количестве байт, которые оно готово принять. */
static int test_pci_card_chr_can_read(void* opaque)
{
    __attribute__((unused)) TestPCIcardState *s = TEST_PCI_CARD(opaque);

    return 0; /* Устройство ещё не реализовано и принимать не может. */
}

/* Уведомление устройства о событии, произошедшем в канале. */
static void test_pci_card_chr_event(void* opaque, int event)
{
    __attribute__((unused)) TestPCIcardState *s = TEST_PCI_CARD(opaque);
}

/* Функция реализации объекта. */
static void test_pci_card_realize(PCIDevice* dev, Error** errp)
{
    /* Другой код */
    /* Наличие назначенного символьного устройства не обязательно. Устройство
       должно уметь корректно работать без него. */
    if (s->chr) {
        /* Регистрация обработчиков. */
        qemu_chr_add_handlers(s->chr, test_pci_card_chr_can_read, \
            test_pci_card_chr_read, test_pci_card_chr_event, s);
    }
    /* Другой код */
}

```

Фрагмент кода приведён без изменений, все комментарии добавлены вручную.
Во фрагменте не приведены добавление поля в структуру объекта и регистрация
этого поля как _свойства_. Последнее описывается далее.

### Блочные устройства

Блочные устройства применяются для упрощения реализации ПЗУ. Поддерживается
доступ к блокам байт по произвольному адресу. При этом применяется асинхронное
выполнение (в отдельной нити) операций ввода/вывода применительно к
_файлу-образу_ в файловой системе основной ВМ, содержащему данные ПЗУ.
Также абстракция "блочное устройство" поддерживает нетривиальные форматы
хранения файлов-образов, предоставляя разработчику ПЗУ унифицированный API.

Для добавления блочного устройства к заготовке устройства генерируется
следующий код.

```c
/* Структура объекта. */
typedef struct _TestPCIcardState {
    /* Другие поля */
    BlockBackend *blk; /* Ссылка на описатель блочного устройства. */
} TestPCIcardState;

static void test_pci_card_realize(PCIDevice* dev, Error** errp)
{
    /* Другой код */
    if (s->blk) { /* Наличие назначенного блочного устройства не обязательно. */
        /* Даже способ инициализации блочного устройства уже относится
           к индивидуальной части модели устройства. Всё что можно сделать:
           добавить блок проверки в функцию реализации объекта. */
        /* TODO: Implement interaction with block driver. */
    }
    /* Другой код */
}

```

Фрагмент кода приведён без изменений, все комментарии, кроме `TODO` подсказки
для разработчика, добавлены вручную. Помимо этого кода, поле `blk`
регистрируется как свойство. Это описано ниже.

### Свойства объектов

Любой объект QOM может иметь свойства. Формирование перечня свойств для каждого
объекта возложено, в общем случае, на конструктор объекта. Добавление каждого
свойства осуществляется вызовом специальной функции имеющей множество
параметров. В то же время базовый класс устройств реализует механизм более
компактного определения свойств некоторых типов. Инструмент использует именно
этот механизм, т.к. генерация свойств низкоуровневым способом не требуется
для генерируемых заготовок по следующим причинам:

* модели ВМ не нуждаются в дополнительных свойствах;
* для устройств принято использовать соответствующий механизм.

Ниже приведён пример определения свойств устройства.

```c
/* Этот массив определяет два свойства PCI устройства: символьное и блочное
   устройства. Макросы TEST_PCI_CARD_CHR и TEST_PCI_CARD_DRIVE сгенерированы в
   заголовочном файле устройства. */
static Property test_pci_card_properties[] = {
    DEFINE_PROP_CHR(TEST_PCI_CARD_CHR, TestPCIcardState, chr),
    DEFINE_PROP_DRIVE(TEST_PCI_CARD_DRIVE, TestPCIcardState, blk),
    DEFINE_PROP_END_OF_LIST()
};

/* Конструктор класса */
static void test_pci_card_class_init(ObjectClass* oc, void* opaque)
{
    DeviceClass *dc = DEVICE_CLASS(oc);
    /* Другой код */
    /* Регистрация перечня свойств. Затрагивается шаблон функции конструктора
       касса. */
    dc->props     = test_pci_card_properties;
    /* Другой код */
}
```

Фрагмент кода приведён без изменений, все комментарии добавлены вручную. Как
уже отмечалось, наличие назначенного блочного или символьного устройства не
обязательно. Регистрация соответствующих полей как свойств даёт возможность
пользователю с командной строки настроить подключение устройства к внешним
источникам ввода/вывода. Это особенно часто применяется для символьных
устройств, т.к. для блочных в QEMU есть дополнительная абстракция, и
пользователь работает уже с ней (опции `hda` ... `hdd`, `fda`, `cdrom`,
`pflash` и др.).

Этот фрагмент, аналогично фрагменту, регистрирующему состоянию устройства,
демонстрирует сложную взаимосвязь различных шаблонов, при их применении к
одному устройству.

### Адаптация к изменениям QEMU

QEMU является развивающимся проектом. Это приводит к тому, что в нём
периодически происходят изменения, делающие генератор кода несовместимым с
новой версией.

Для решения этой проблемы используется эвристический подход. Все аспекты
поведения инструмента, зависящие от версии QEMU, называются _эвристиками_.
Т.к. один аспект работы может меняться многократно, то каждая эвристика
представлена одной или несколькими записями в базе данных.

Код инструмента получает доступ к требуемой эвристике по _строковому
ключу_ --- уникальному имени эвристики.
Значением эвристики может быть любая сущность языка Python: от целочисленной
константы до класса или модуля. Таким образом, при необходимости, можно
_подменить_ почти всю реализацию инструмента.

Каждая запись об эвристике имеет как минимум два значения: _новое_ и _старое_.
Запись привязывается к SHA1-идентификатору изменения в Git-графе [[Git](#Git)]
истории QEMU.

При обнаружении очередного несоответствия между инструментом и QEMU,
разработчик должен сделать следующие действия.

* Определить, что изменилось.
* Определить, SHA1 соответствующего изменения.
* Дополнить базу данных эвристик записью о новом и старом значениях, придумав
эвристике осмысленное название (_ключ_).
* Изменить код инструмента таким образом, чтобы он зависел от значения,
соответствующего _ключу_ в данный момент.

В инструменте реализован алгоритм, позволяющий для заданных SHA1,
базы эвристик и Git-истории вычислить значения для всех имеющихся в базе
ключей. Хранение обоих значений в каждой записи об эвристике избыточно. Но эта
избыточность используется для проверки непротиворечивости записей.

##<a name="Codegeneration"></a> Генерация кода

Первым подходом к генерации кода было использование строк форматирования
двух видов:

* `printf`-подобный, реализуемый оператором `%`, для простых подстановок;
* расширенный, поддерживаемый методом `format`, для форматирования с
большим количеством параметром.

С развитием инструмента стало ясно, что для генерации даже небольшого
шаблона требуется определить множество параметров. Многие из которых
являются производными как от настроек пользователя, так и от особенностей
кода QEMU (по большей части). В результате строки форматирования были
обёрнуты в специальные классы, упрощающие разработчику написание
шаблонов. В настоящее время строки используются только на самом низком
уровне инструмента. Разработчик, реализуя шаблоны, уже использует
специализированное API. Исключением является написание шаблонов тел
функций. Однако функционал API, упрощающий реализацию шаблонов тел
функций развивается, упрощая этот процесс. Со временем, ручное написание
строк форматирования при создании тел функции будет исключено.

Параллельно была предпринята попытка использовать для определения
шаблонов АСД языка Си. Библиотека PyCParser[[PyCParser](#PyCParser)],
реализует двустороннее преобразование. Однако у применения АСД имеются
следующие недостатки:

* не поддерживается препроцессор, макросы которого активно используются
в интерфейсной (и не только) части модели устройства;

* не учитываются незначащие символы (пробелы, переносы строк,
комментарии), что требует доработки генератора PyCParser, таким образом,
чтобы он генерировал код, не противоречащий стилю программирования,
принятому в QEMU.

Получаемые при генерации фрагменты кода не являются независимыми. Язык
Си требует, чтобы многие имена были объявлены до их использования.
В том числе с использованием директивы `include` препроцессора.
Аналогичное требование есть для препроцессора.
То есть генератор должен не только сгенерировать фрагменты кода, но
и расположить их в правильном порядке. Также требуется сгенерировать
включение требуемых заголовков, причём желательно, минимизировать
количество включений. Не стоит забывать, что порядок включения заголовков
иногда существенен.

В результате для генерации файла исходного кода были разработаны две
модели.

1. Модель синтаксиса языков Си и препроцессора. Она описывает, какие
синтаксические конструкции присутствуют в файле, как они связаны между
собой и с существующим кодом.

2. Модель файла с исходным кодом. Она оперирует неделимыми текстовыми
фрагментами, из которых состоит файл, и порядковыми связями между ними.
Она конструируется автоматически из первой модели.

### Модель языков Си и препроцессора

Реализованное API для написания шаблонов в представляет собой
модель _гибридного языка_, полученного путём слияния языка Си и языка
препроцессора. API работает на уровне файлов: с его помощью
разработчик описывает содержимое каждого генерируемого файла.
При этом API позволяет описать содержимое существующих файлов. Это
необходимо для встраивания генерируемого файла в QEMU. Существующие
файлы можно описывать не так подробно и не полностью, следуя
принципу минимально достаточной информации.

При описании содержимого файла используются следующие классы.

* `Type`
    * `TypeReference`
    * `Structure`
    * `Function`
    * `Pointer`
    * `Macro`
* `Initializer`
* `Variable`
* `Usage`

_Тип_ (класс `Type`), как можно заметить из перечня подклассов, тут
понимается как нечто большее, чем тип в языке Си.

Объект класса `Type` обладает следующими свойствами:

* `name` --- уникальное имя типа;
* `incomplete` --- незавершенный тип, нельзя создать _переменную_
такого типа;
* `definer` --- идентификатор файла, где этот тип _определён_;
* `base` --- базовый тип, который имеется в языке, для его использования
не нужно подключать заголовки.

Уникальность имени типа даёт возможность находить тип только по имени:
не требуется сначала искать файл, где этот тип определён. Это облегчает
работу разработчика шаблонов, но имеет _теоретический_ недостаток,
заключающийся в следующем.
Совместное хранение макросов вместе с типами языка Си, строго говоря, делает
требование уникальности имени невыполнимым в общем случае.
Однако данная проблема не возникает в QEMU благодаря принятому стилю
программирования.
Известно, что в QEMU реализации двоичного транслятора для разных
целевых архитектур имеют пересекающиеся множества имён символов языка Си
и препроцессора. Но устройства и ВМ реализуются архитектурно независимо,
и файлы определяющие одноимённые типы не используются вместе.

Класс `Type` не предусматривает шаблона для генерации кода. Это значит,
что нельзя сгенерировать файл, где есть хоть одна сущность, описываемая
этим классом. Фактически, этот класс применяется для ручного определения
списка типов, присутствующих в существующих файлах QEMU, в тех
случаях, когда достаточно только имени типа для подключения нужного
заголовка.

Одним из направлений дальнейших исследования является синтаксический
анализ файлов QEMU с целью автоматического создания объектов,
описывающих существующие типы. В настоящий момент такая функциональность
реализована только для макросов препроцессора и опирается на функционал
модифицированного препроцессора из библиотеки PyCParser.

Объект `TypeReference` (ссылка на тип) используется для ссылок на типы
из других файлов. Любой тип может присутствовать непосредственно только
в файле, где он объявлен. Такой подход даёт возможность при генерации кода
однозначно определить следует ли сгенерировать непосредственное
определение типа по шаблону, или сгенерировать включение заголовочного
файла, где он определён.

Если необходимо объявить переменную типа из другого файла, используется
`TypeReference`. То есть создаётся ещё один тип с тем же именем, но
особым способом обработки:

* имя такого типа не индексируется в API и, следовательно, требование
уникальности игнорируется;
* шаблоном для генерации кода `TypeReference` является директива
`include` препроцессора.

Тут важно заметить, что в отличие от Си, модель не делает разграничения
на _объявление_ и _определение_. То есть объявление функции (или
внешней переменной) в заголовке
и её определение в модуле --- два разных _определения_ в данной модели.
Синтаксическая необходимость обеспечить объявление функции до
её определения достигается добавлением в объект типа, представляющим
её определение, ссылки (`TypeReference`) на тип, представляющий её
объявление. Таким образом, будет сгенерирована директива `include`,
подключающая соответствующий заголовочный файл до определения функции.

Класс `Variable` (переменная) описывает пару: "тип, имя". В данной модели
_переменная_ нечто большее, чем переменная в языке Си. Суть этого
класса раскрывается при описании нижеизложенных классов API. Для случая,
когда этот класс используется для описания переменной языка Си,
предусмотрены следующие поля:

* `static` --- соответствует одноимённому слову языка Си;
* `initializer` --- инициализатор, начальное значение переменной;
* `array_size` --- используется для определения массивов, в т.ч. и
безразмерных (когда размер определяется компилятором по инициализатору,
или когда нужно определить переменную-указатель, используя `[]` вместо
`*`).

Класс `Structure` (структура) используется для объявления составного типа.
По представленному в нём описанию создаётся конструкция `struct` языка Си.
Объект класса содержит список полей (`fields`), определяемых объектами
класса `Variable`.
<!--
Иногда часть полей структуры в языке Си определяется
макроподстановкой. В данной модели такие поля описываются одной
_переменной_, тип которой является соответствующим макросом (`Macro`), а
имя игнорируется.
-->

Класс `Function` (функция) используется для описания конструкций языка
Си, связанных с функциями этого языка:

* объявление функции;
* определение функции, в том числе статических (`static`) и/или
встраиваемых (`inline`);
* определение типа указателя на функцию (применяется совместно с
классом `Pointer`);

Объект `Function` содержит следующие дополнительные поля:

* `ret_type` --- тип возвращаемый функцией;
* `args` --- список аргументов функции (аналогично полям структуры);
* `static` и `inline` --- фактически определяют наличие соответствующих
ключевых слов в генерированном коде;
* `body` --- текст тела функции;
* `used_types` и `used_globals` --- список, соответственно, типов и
глобальных переменных, использованных в теле функции; данная информация
необходима, так как на данный момент модель не поддерживает тела
функций.

При определении тела функции разработчик должен, используя
вспомогательные методы API, сконструировать тело функции, сохраняя
списки использованных в нём типов и глобальных переменных.
Затем он передаёт эти списки в объект функции.

Важно заметить, что под понятие "использованный тип" подпадают
также такие сущности как:

* вызванные функции;
* структуры, использованные при объявлении переменных;
* использованные макросы; и т.п.

Класс `Pointer` (указатель) применяется для создания указателей
различного вида:

* именованных типов указателей (например, `typedef int* intptr;`),
включая указатели на функции;
* определение переменных-указателей на другие типы (в том числе
полей структур и аргументов функций).

При определении переменной-указателя создаётся _безымянный_ тип
указателя. На самом деле имя ему формально генерируется путём
подстановки '`*`' к основному типу, согласно синтаксису языка
Си. Но имя такого типа не индексируется API и, следовательно,
может не быть уникальным. Кроме того, этот тип не привязывается
к какому-либо файлу, т.е. наличие где-нибудь переменной такого
типа не вызывает генерации директивы `include` само по себе.
Однако тип под указателем, если он не является базовым, должен быть
обеспечен либо директивой `include`, либо непосредственным
определением.

Класс `Macro` (макрос) соответствует директиве `define`
препроцессора. Поддерживаются как параметризованные макросы, так
и не параметризованные макросы. Однако поддержка параметров
ограничивается только генерацией вызова макроса: раскрытие же не
требуется для генерации файла (ровно как и выполнение
сгенерированного кода, чем, по сути, и является раскрытие макроса,
с точки зрения данной модели).

Класс `Initializer` (инициализатор) используется для определения
начальных значений
переменных или параметров вызова макроса. Поле `code` содержит
данные, используемые для генерации кода инициализатора, а поля
`used_types` и `used_variables` хранят ссылки на, соответственно,
типы и переменные, использованные в коде инициализатора. Модель
инициализатора схожа с моделью тела функции, и обе они пока не
развиты, являясь объектами дальнейших исследований.

Класс `Usage` (использование) применяется, когда при генерации
переменной некоторого
типа не достаточно использовать в шаблоне имя типа непосредственно.
Т.е. имя типа должно быть преобразовано некоторым образом перед
вставкой в шаблон. `Usage`
добавляет инициализатор (`Initializer`) к _типу_ переменной, на
основании которого и происходит видоизменение имени типа.
Единственным примером в настоящее время является макрос.
Инициализатор используется для расстановки
значений при генерации вызова макроса. Имя переменной и _её_
инициализатор при этом игнорируются.

Рассмотренная модель не является законченной. Но даже в таком варианте
она позволяет с достаточно гибкостью описывать шаблоны устройств и ВМ,
используемые при генерации интерфейсной части их кода. Развитие
этой модели является направлением дальнейших исследований.

### Модель файла с исходным кодом

Описанная выше модель содержимого файла не обеспечивает генерацию
синтаксически корректного файла. Её задача: сгенерировать законченные
_фрагменты_ генерируемого файла. При этом остаётся решить следующие
задачи:

* расположить фрагменты в синтаксически корректном порядке;
* обеспечить смысловую группировку фрагментов;
* не допускать длину строки более 80 символов (требование стиля
программирования);
* устранить дублирующиеся фрагменты;
* минимизировать количество директив включения заголовков.

Далее эти задачи рассматриваются подробнее.

#### Сортировка фрагментов

Как известно, язык Си накладывает жесткие ограничения на порядок
определения различных символов. Например, тип должен быть объявлен
до того, как будет создана переменная этого типа, или будет
объявлена функция, принимающая аргумент такого типа. Подробное
рассмотрение всех возможных примеров выходит за пределы данной статьи.
Важно заметить, что почти все фрагменты связаны друг с другом, образуя
ациклический граф, и для обеспечения синтаксически корректного порядка
используется топологическая сортировка.

Помимо требований синтаксиса есть требования стиля программирования и
здравого смысла, согласно которым, фрагменты должны следовать в
следующем порядке:

1. включение заголовков;
2. объявление типов языка Си и макросов;
3. объявления функций;
4. определение функций, глобальных переменных и прочий код.

#### Выравнивание строк

Стиль программирования требует, чтобы строки были не длиннее
80 символов. Удовлетворение этого требования было снято с модели
модели языков Си и препроцессора, чтобы не усложнять её. Требуемая длина
строки обеспечивается переносом строк по словам, при этом применяется
экранирование непечатного символа конца строки символом "`\`". Это
консервативный подход, обеспечивающий корректность в случае макросов и
строковых литералов.

#### Устранение дубликатов

При генерации фрагментов из модели языка не отслеживаются уже созданные
фрагменты. Это сделано для упрощения алгоритма построения модели
файла из модели языка. При генерации фрагментов осуществляется обход
графа использования типов, последовательно, начиная с каждого
типа, определяемого в генерируемом файле. Если типы одного файла
используют для определения себя типы из этого же файла, то для
использованных многократно типов будет сгенерировано несколько
клонов.

Для определения клонов, каждый фрагмент хранит ссылку на тип, из
которого он получен. Таким образом для каждого типа можно найти все
клоны и оставить один. Важно учесть, что каждый клон содержит свою
часть зависимостей от других фрагментов, ровно как и разные
фрагменты зависят от разных клонов. При устранении клонов эти
зависимости объединяются. Для ускорения алгоритма объединения
зависимостей хранятся обратные ссылки (на зависимые фрагменты).

#### Учёт зависимостей и взаимосвязь с существующим кодом

Как уже отмечалось, для обеспечения видимости символов, объявленных в
других файлах, генерируются директивы `include`. При этом имеются следующие
тонкости:

1. заголовочные файлы сами используют `include` для подключения других
файлов, поэтому подключение одного файла может заменить подключение
нескольких;

2. иногда важен порядок включения заголовков:

    * один заголовок может определять макросы, влияющие на поведение
    макросов в другом заголовке;
    * заголовок может не обеспечивать видимость определённых в других
    заголовках типов требуемых для определения своих типов, возлагая
    задачу включения тех заголовков на файлы, которые будут включать его
    (эта возможность активно используется в сообществе QEMU для
    облегчения работы препроцессора <!--(экономия дискового пространства,
    занимаемого исходным кодом, и электрической энергии, расходуемой на
    конкатенацию более длинных строк)--> и усложнения работы программиста).
    <!--(а шоб жизнь мёдом не казалась)-->

3. перед подключением некоторых заголовков, подключающий файл должен
сам определит некоторые макросы и/или типы языка Си; подобный случай не
встречается при написании моделей устройств и ВМ, но известно, что он
используется в коде, относящемся к транслятору TCG.

Первая особенность используется инструментом для сокращения количества
подключаемых заголовков на основе анализа графа включения заголовков.
Граф строится автоматически с использованием модифицированного
препроцессора из библиотеки PyCParser.

Чтобы учесть вторую особенность для заголовка можно указать список
зависимостей. Каждая зависимость это тип (`Type`). Когда для
определения своего типа заголовку требуются другие типы, то можно
поступить следующими способами:

1. подключить необходимые заголовки, при этом:

    * рекурсивно подключая заголовки, удовлетворяющие зависимости
    подключаемых заголовков;
    * или добавляя зависимости подключаемых заголовков к своим зависимостям;

2. добавить требуемые типы в список зависимостей.

При генерации заголовков инструмент придерживается первого способа, подключая
все необходимые заголовки. А поскольку модификация существующих заголовков не
применяется, то для них остаётся только второй подход.

### Встраивание в код QEMU
## Методика испытаний
### 1440FX
### Q35
### CISCO C2600 из Dynamips
## Результаты
## Заключение
## Использованные источники

* <a name="Git"></a>Система контроля версий Git. "https://git-scm.com/about",
09.03.2017.

* <a name="Tkinter"></a>Страница библиотеки для создания графического
интерфейса "Tkinter". "https://wiki.python.org/moin/TkInter", 2017.03.13.

* <a name="PyCParser"></a>Страница библиотека PyCParser на GitHub.
"https://github.com/eliben/pycparser", 20.03.2017.

