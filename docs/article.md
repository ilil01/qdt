[//]: # (make)

<!--
Перед подачей в pandoc статься должна быть предобработана сценарием
md-preprocessor.py. Он осуществляет автоматизацию ссылок. Ниже приводятся
некоторые пояснения по поводу оформления ссылок. Подробные сведения и нюансы:
см. код сценария. Примеры оформления см. в тексте.

Типы ссылок:
ref.MyRefName     - ссылки на источники
rel.MyText        - ссылки на такст, которые будут заменены на "выше" или "ниже"
pic.MyPictureName - ссылка на картинку
tbl.MyTable       - ссылка на таблицу
без приставки     - ссылка никак не обрабатывается

Для каждой ссылки должен быть объявлен "якорь" - позиция, на которую эта ссылка
ссылается. Якори расставляются так.

$. <a name="preffix.MyName">$</a>

где $ - ставится только в том случае, если предполагается автоматическая
замена этого символа на что-то другое (в соответствии с типом ссылки). Якорь
должен быть ПЕРЕД соответствующим текстом.
-->

# Автоматизация разработки моделей устройств и вычислительных машин для QEMU

# Обозначения и сокращения

* API Application programming interface
* ABI Application binary interface
* BAR Base address registers
* CD Compact disc
* CLI Command line interface
* EEPROM Electrically erasable programmable ROM
* GPIO general purpose input/output
* ICH I/O Controller Hub
* ICMP Internet control message protocol
* IRQ Interrupt request
* LPC Low pin count
* MMIO Memory mapped input/output
* MSI Message signalled interrupt
* MSI-X Extended MSI
* PCI Peripheral component interconnect
* QOM QEMU object model
* ROM Read-only memory
* SHA1 Secure Hash Algorithm 1
* TAP ?
* TCG Tiny code generator
* TCP Transmission control protocol
* UDP User datagram protocol
* USB Universal serial bus
* АСД абстрактное синтаксическое дерево
* ВМ вычислительная машина
* ГИ графический интерфейс
* НЖМД накопитель на жестком магнитном диске
* ООП объектно-ориентированное программирования
* ОС операционная система
* ПЗУ постоянное запоминающее устройство
* ПО программное обеспечение
* УАПП универсальный асинхронный приёмо-передатчик

# Аннотация

# _Не прикреплённое_


<!--- QEMU, ВВМ, состояние ВВМ --->
В QEMU реализована возможность сохранения _состояния_ ВВМ в файл.
<!--
Под состоянием понимается такое множество всех данных, используемых алгоритмами
эмуляции, что _при условии изолированности ВВМ от внешних воздействий_
мгновенная совокупность значений этих данных однозначно определяет дальнейшее
развитие эмуляции.
-->
Сохранённое состояние называется _снимком_ (англ. _snapshot_).
<!--+ снимок (ВВМ) +-->


<!--- --->
Символы API QEMU должны быть доступны в сгенерированных файлах. Для этого
нужно включить (директивой `#include`) соответствующие заголовочные файлы.
Список этих файлов может быть автоматически вычислен по перечню использованных
символов. При этом, код не будет перегружен, если включать только необходимые
заголовки и минимизировать их количество. Также будет уменьшено время
компиляции. <!-- Последнее не является главной целью, т.к. величина выигрыша
времени компиляции не измерялась, и, есть подозрение, что практическая
значимость имеется только на очень долгосрочной перспективе. -->

Эти и другие особенности учтены в модели, используемой системой. При этом нельзя
сказать, что она закончена, так как периодически обнаруживаются случаи,
требующие её модификации. Здесь представлено описание модели, используемой
в текущей версии.
<!--+ +-->


# <a name="Introduction"></a>Введение

## Ручной подход

Используемый в настоящее время подход к реализации моделей для QEMU
заключается в поиске похожей функциональности в существующих моделях и
реализации требуемой по образу и подобию. При этом применяется обычное
копирование кода, с последующими его правками и дополнениями. С опытом
всё большую часть кода можно писать по памяти, но нужно следить за
изменениями в QEMU.

<!--- QEMU , ООП (парадигма), Си (язык) --->
# Объектная модель QEMU

Основой использованного в QEMU подхода к моделированию ВМ и их компонент
является так называемая "объектная модель QEMU" (англ. _QEMU Object Model_ или,
далее по тексту, _QOM_). Данная модель применяется не только для ВМ и их
компонент, но и для моделирования других связанных сущностей). QOM является
реализацией парадигмы ООП на процедурном языке Си.
<!--+ QOM +-->

<!--- QOM, наследование (ООП) --->
QOM организует иерархию _типов_ (type).
Каждый тип имеет уникальное строковое _имя_.
Тип описывает _класс_ (class) и _экземпляр_ (instance).
Экземпляров может быть много, в то время как класс один.
Иерархия QOM получается путём _наследования_ (по аналогии с ООП) ---
установления отношения между двумя типами, таким образом, что один тип
называется _ребёнком_, а другой --- _родителем_.
Ребёнок копирует всю информацию из родителя --- _наследует_.
Множественное наследование не поддерживается.
Тип может быть _абстрактным_: такой тип не может иметь экземпляров.
<!--+ тип, класс, экземпляр, (тип-)родитель, (тип-)ребёнок, наследование,
абстрактный тип +-->

<!--- QOM, структура (Си), функция (Си), конструктор (ООП), экземпляр (QOM),
класс --->
<a name="rel.QOM_type_structs"></a>
Экземпляр описывается структурой (термин языка Си) и функцией
её инициализации. На этом уровне для QOM существенен только размер этой
структуры, так как он используется для выделения под неё памяти. Эту структуру
будем называть _структурой экземпляра_, а функцию ---
_конструктором экземпляра_ (по аналогии с ООП). Класс тоже описывается
структурой (её размером) и функцией с аналогичными назначениями ---
_структурой класса_ и _конструктором класса_.
В начале каждой структуры типа-ребёнка должно быть зарезервировано место под
соответственную структуру родительского типа.
<!--+ структура экземпляра, конструктор экземпляра, структура класса,
конструктор класса +-->

<!--- конструктор экземпляра, конструктор класса --->
Инициализация как экземпляра, так и класса происходит путём вызова
конструкторов в порядке от родителя к ребёнку: явный вызов соответственного
конструктора родителя не требуется.
<a name="overridance_in_QOM"></a>
Изменение поля любой из структур родителя (_перегрузка_) должно выполняться
в соответственном конструкторе.
Поскольку структура класса у каждого типа своя, перегрузка не повлияет
ни на родителя, ни на братьев <!-- этот термин не вводится явно: предполагается,
что читатель сам сможет догадаться --> и _их_ потомков <!-- этот, кстати,
тоже -->. Но она повлияет на потомков перегружающего типа, поскольку
конструктор будет вызван в течении каждой инициализации соответственной
структуры каждого потомка. Это справедливо и для перегрузки полей структуры
экземпляра.
<!--+ порядок инициализации экземпляра и класса, перегрузка +-->

<!--- стиль программирования QEMU, структура экземпляра, конструктор экземпляра,
структура класса, конструктор класса --->
Согласно принятому в QEMU стилю программирования, все описанные выше
структуры, функции, строковые константы (имена типов) и т.д. имеют в своём
названии имя типа. Оно принимает различные формы, в том числе, чтобы
быть синтаксически корректным. Далее по тексту, для ссылок на типы
будут использоваться строковые имена типов в оригинальном виде. Некоторые из
них удобнее использовать переведёнными на язык остального текста. В таком
случае при первом упоминании типа будет указано и его оригинальное имя.
<!--+  соглашение о способе упоминания тиnа QOM +-->

<!--- QOM, экземпляр, класс, тип --->
## Объекты в QOM

Несмотря на название QOM, _объект_ (object) не является её базовым понятием, а
только одним из типов. Данный тип добавляет <a name="QOM_object_property">
_свойства_</a> к экземплярам и классам.
Свойство описывается строковым именем (уникальным в пределах объекта или
класса), функциями доступа (присваивания (set) и разыменования (get)) и типом.
Со свойством связана и другая информация, но её рассмотрение выходит за
рамки данной работы.
Тип свойства ограничивает область его допустимых значений. Несмотря на то, что
функции доступа дают большую свободу действий со значением, в большинстве
случаев значению соответствует поле структуры, соответственно, экземпляра или
класса. Так как свойства не входят в базовую часть QOM, их добавление ложится
на конструкторы соответствующих структур.
<!--+ объект, свойство, функция доступа к свойству +-->


<!--- QOM, объект, ВВМ, шина, устройство, прерывание, запрос прерывания,
память --->
## Виртуальные вычислительные машины и их компоненты в QOM
Моделирование ВВМ и её элементов основано на потомках типа _объект_ (object).
К ним относятся:

* машина (machine),
* устройство (device),
* шина (bus),
* запрос прерывания (irq),
* участок памяти (qemu:memory-region).

Модели ВВМ, шин и устройств должны быть, соответственно, потомками machine, bus
и device.
Типы irq и участка памяти являются инфраструктурными, они используются в
общем API и их уточнение обычно не требуется.
Дальнейшее наследование шин и устройств происходит по принадлежности к
стандарту шины.
При этом вводятся промежуточные типы, реализующие общий функционал.
Конкретная модель устройства наследуется от типа соответствующего стандарту
её шины.
При реализации модельного ряда устройств добавляется промежуточный тип с общими
для всего ряда особенностями.
<!--+ основные типы ВВМ, соглашение о наследовании от основных типов ВВМ +-->


<!--- основные типы ВВМ, отрезок (лин.ал.), целые числа, неотрицательные
числа, наложение отрезков? (лин.ал.), функция (язык Си), ОЗУ, ПЗУ, регистр
устройства, шина --->
### Моделирование памяти

Моделирование памяти основано на покрытии её _участками_ (англ. _region_).
Участок памяти описывает непрерывный отрезок _адресного пространства_
(англ. _address space_).
В QEMU адресное пространство --- это отображение целых неотрицательных чисел на
участки памяти.
Участки памяти бывают следующих видов:

* контейнер,
* псевдоним,
* RAM,
* ROM,
* ROMD,
* IO.

Контейнер содержит в себе участки любых видов.
Вложенный участок сопровождается _смещением_ относительно начала контейнера и
_приоритетом_ относительно других участков, вложенных в этот контейнер.
При наложении выбирается участок с наибольшим приоритетом.
<!-- Приоритет является целым числом. -->

Псевдоним отображает свой отрезок адресов на участок любого вида со _смещением_
относительно начала второго.

Участок RAM соответствует ячейкам памяти доступным как на чтение, так и на
запись.
ROM --- только на чтение.
ROMD --- это ROM, запись в который обрабатывается функцией.
IO и чтение, и запись обрабатывает функциями.
<!--
Последний тип ранее назывался "MMIO" по историческим причинам: первоначально
он использовался для эмуляции MMIO.
-->

На практике RAM соответствует ОЗУ; ROM и ROMD --- соответственно, не
перепрограммируемым и перепрограммируемым ПЗУ; IO --- регистрам устройств,
контейнер --- адресному пространству; псевдоним используется для
доступа к одному и тому же участку памяти с разных адресов или для отображения
адресного пространства одной шины в адресное пространство другой.
В общем случае возможны и другие применения.
<!--+ участок памяти, адресное пространство, контейнер, псевдоним,
участок RAM, участок ROM, участок ROMD, участок IO, приоритет в контейнере,
смещение в контейнере, смещение псевдонима +-->


<!--- основные типы ВВМ, QEMU --->
### Моделирование шин

Шина в QEMU --- это элемент ВВМ, связывающий устройства. Одно из устройств
называется _родителем_ (parent) шины, а остальные --- _детьми_ (children).
Симметрично, устройства соединяется с одной или более шиной. При этом
выделяется шина-_родитель_, а остальные шины называются _детьми_.
Устройство имеющие хотя бы одну шину-ребёнка называется _мостом_ или
_контроллером шины_.
Таким способом происходит связывание всех элементов ВВМ в единое дерево.

Особым образом моделируется системная шина.
В каждой ВВМ имеется единственная системная шина, которая является корнем
дерева устройств.
Ей не соответствует никакого экземпляра, а все её функции закреплены в API.
Все экземпляры устройств системной шины считаются подключенными к ней.
<!--+ устройство-родитель, устройство-ребёнок, шина-родитель, шина-ребёнок,
мост (устройство), контроллер шины, системная шина +-->


<!--- основные типы ВВМ, IRQ, API, обратный вызов (парадигма
программирования), структура экземпляра,  целые числа, неотрицательные числа,
устройство, указатель (Си), структура (Си), IRQ, запрос прерывания,
двоичный сигнал --->
### <a name="rel.IRQ_modeling"></a>Моделирование запросов прерывания

Запрос прерывание есть передача бинарного сигнала от устройства-_источника_ к
устройству-_приёмнику_.
Передача реализуется при помощи обратного вызова, которому передаётся текущее
значение двоичного сигнала на линии.
<!--
Обратный вызов не обязательно сопровождается изменением сигнала.
Об этом важно помнить при разработке модели устройства.
Вызов без изменения сигнала, хоть и избыточен, но не является ошибкой.
-->
Параметры обратного вызова хранятся в структуре `IRQState`.
Данная структура является структурой экземпляра типа "irq".
Для ссылки на эту структуру определён специальный тип указателя `qemu_irq`.
<!--
Одним из параметров обработчика является индекс входа на который пришел сигнал.
Поэтому один обработчик может использоваться для нескольких входных сигналов.
Структура IRQState` содержит описание одного входа:

* обработчик;
* индекс;
* указатель на `void`, через который в обработчик можно передать
произвольные данные.

Симметрично, указатель `qemu_irq` соответствует одному выходу.
-->
Источник содержит содержит поле типа `qemu_irq` в своей структуре экземпляра.
Приёмник инициализирует `IRQState`<!--, память под которую
обычно выделяется из _кучи_ в процессе создания прерывания-->.
Для формирования одной линии в поле типа `qemu_irq` источника записывается
адрес структуры `IRQState` приёмника.
<!--+ IRQState, qemu_irq, источник IRQ, приёмник IRQ +-->


<!--- устройство (QOM), принцип чёрного ящика, свойства (QOM),
мост (устройство), регистры устройств, шина, шина-родитель, устройство-родитель,
MMIO, PMIO, PIO, адресное пространство, гостевое ПО, стандарт шины, ЦП, MMU, IO
участок памяти, BAR, PCI, IBM PC, приёмник IRQ, источник IRQ, целые числа,
неотрицательные числа --->
### Моделирование устройств

Подход к моделированию устройств использует принцип _чёрного ящика_: API
определяет какие действия можно совершать над устройством снаружи, и как
устройство должно выполнять свои функции изнутри.

_Снаружи_ устройство:

* подключается к шине-родителю;
* может являться родителем одной или нескольких шин (мостом);
* может допускать настройку через свойства (QOM);
* может иметь входы и/или выходы _GPIO_ (англ. _General Purpose Input/Output_
--- ввод-вывод общего назначения).

_Изнутри_ устройство:

* имеет состояние;
* может взаимодействовать с внешней средой;
* реализует взаимодействие с устройствами на дочерней шине (если является
мостом);
* _реализует внутреннюю поддержку функционала, предоставляемого наружу_.

Данные возможности поддерживаются на базовом уровне.
Реальные стандарты шин предусматривают дополнительные возможности:

* обмен данными;
* передача запросов прерываний.

Этот перечень основан на изучении поддержки шины стандарта PCI и системной шины.
Вторая отличаются тем, что несмотря на многообразие
стандартов системных шин, варьирующихся от процессора к процессору,
все системные шины реализуют один и тот же функционал.
Это позволило реализовать в QEMU поддержку устройств системной шины без
привязки к конкретному стандарту.
<!-- Однако ощущается влияние архитектуры IBM PC.
У этого исторические предпосылки. -->

Подробное рассмотрение других реализованных в QEMU стандартов шин и способа
реализации новых выходит за рамки данной работы.
<!--
В реализации стандарта шины должно быть задействовано минимум три новых типа:

* тип устройства;
* тип шины;
* тип моста.

При этом происходит добавление новых или уточнение существующих возможностей:
в соответствии со стандартом.
Новый тип устройства является промежуточным.
Модели конкретных устройств должны быть его потомками.
Чтобы новую ветку типов можно было использовать в ВВМ должен быть определён
хотя бы один мост.
Мост является устройством одного из _реализованных_ стандартов.
Он предоставляет доступ к шине добавляемого стандарта по шине реализованного.
Минимальные требования стандарта к мосту, как правило, достаточно высоки, что
позволяет использовать базовый тип моста в ВВМ, не прибегая к реализации
на его основе моделей реальных устройств.
Это во многом зависит от требовательности гостевого ПО.
Хорошим тоном считается определение вспомогательных функций и макросов,
упрощающих работу типами реализуемого стандарта.
-->

#### Обмен данными

Обмен данными по шине осуществляется через _регистры_.
Согласно модели QEMU, регистры --- это относящиеся к устройству участки
памяти, с которыми возможен обмен данными.
Для обмена данными регистры добавляются в адресное пространство соответственной
шины.
Доступ к адресному пространству реализует мост.
Исключением является системная шина: мост не используется, а его функции
реализуются ЦП, MMU и связанным системным кодом.
Подробное рассмотрение этой части эмулятора выходит за рамки данной работы.

Примерами регистров являются:

 * MMIO системной шины;
 * PMIO (PIO) системной шины у IBM PC совместимых машин;
 * BAR шины PCI.

Для реализации регистров используются IO участки памяти.
Логика чтения и записи программируется в функциях-обработчиках.
В API определены вспомогательные функции для объявления регистров изнутри
устройства и для работы с ними снаружи.

#### Запросы прерывания

Помимо обмена данными шины поддерживают передачу запросов прерываний от
устройств к мосту.
А иногда и между устройствами.
Мост может предать запрос дальше: шине-родителю.
В случае системной шины последним приёмником запросов является ЦП.
Перед ЦП обычно встраивается _контроллер прерываний_, управляющий запросами от
других устройств.

Принцип передачи запроса прерывания рассмотрен [$](#rel.IRQ_modeling).
Базовый класс устройств предоставляет API, обобщающий работу с прерываниями
до GPIO.
Этот интерфейс реализует адресацию точек подключения сигнальных линий в
пределах устройства.
Одна точка может быть или входом, или выходом.
Точки собраны в именованные группы.
_Все_ точки имеют _имя_.
API позволяет объявлять точки без указания имени.
Таким точкам неявно присваивается имя "unnamed" (англ. _безымянная_).
Каждая точка внутри именованной группы имеет _индекс_ --- неотрицательное целое
число.
Входы и выходы индексируются раздельно.

При реализации точек подключения именно для линий запроса прерывания выбирается
специальное имя. Например, "sysbus" --- линии, используемые для подключения
прерываний системной шины.

<!--
Реализация API GPIO основана на [свойствах] (#QOM_object_property)(от
родительского типа "object").
-->
<!--+ подход к моделированию устройств, GPIO, адресация GPIO, имя GPIO,
индекс GPIO +-->


<!--- подход к моделированию устройств, снимок (ВВМ), состояние (ВВМ),
запрос прерываний, GPIO, свойства устройства, регистр устройства,
внешняя среда, поведение устройства, структура экземпляра,
поле структуры (Си) --->
#### Состояние устройства

Поведение устройства в течение времени определяется:

* записью и _чтением_ в/из регистров;
* входящими запросами прерываний и другими GPIO;
* взаимодействием с внешней средой и др.

Если вышеописанное влияет не только на текущее, но и на последующее
поведение устройства, то устройство имеет _состояние_.
Технически, состояние является множеством полей структуры экземпляра, которые
по совокупности влияют на результат работы кода модели устройства.
Состояние устройства является частью состояния всей ВВМ и должно быть включено
в снимок.
Каждое устройство должно зарегистрировать своё состояние.
Используя эту информацию, эмулятор может, приостановив работу, сделать
снимок устройства и всей ВВМ.
<!--+ состояние устройства +-->


<!--- свойства объекта (QOM), поле структуры (Си), структура (Си),
тип QOM, конструктор экземпляра, ВВМ --->
#### Свойства устройства

Базовый тип устройств реализует упрощённый механизм добавления свойств к
экземплярам.
В основе механизма лежит допущение, что большинство свойств устройства
может быть представлено одним полем структуры экземпляра.
Механизм позволяет задать соответствие между полем и строкой: именем свойства.
Также вводится ограничение, не позволяющее снаружи изменять значения многих
свойств устройства после того, как оно было создано.
Ограничение состоит в разбиении процесса создания на _инициализацию_ и
_реализацию_.
Инициализация соответствует конструированию экземпляра типа QOM.
В ходе инициализации конструктором экземпляра в устройство добавляются свойства.
В результате получается законченный, с точки зрения QOM, экземпляр, и
начинается реализация.
В ходе реализации происходит внешняя настройка устройства: присваивание
значений свойствам.
В последнюю очередь булеву свойству "realized" присваивается "истина", что
является завершением реализации.
Менять значения свойств реализованного устройства нельзя.
После реализации происходит встраивание устройства в ВВМ.

<!--
Способ регистрации полей структуры устройства в качестве его свойств усложняет
их определение и задание им начальных значений, но предоставляет следующие
возможности:

* Прозрачное преобразование инвариантных строковых идентификаторов
объектов в указатели. Идентификаторы удобно использовать при
создании устройства. При написании кода ВМ это снимает с
программиста необходимость писать код, получающий указатели.
Код получается короче и понятнее.
Кроме того, только таким способом можно определить значение
свойства через CLI. Указатели же оптимизируют доступ к памяти
внутри реализации устройства.

* Контроль корректности значений.
-->
<!--+ свойство устройства, инициализация устройства, реализация устройства +-->


<!--- QOM, тип (QOM), тип-родитель, конструктор модуля (язык Си), правило (GNU
Make), макрос (Си), деструктор класса, деструктор экземпляра  --->
## <a name="rel.QOM_type_inheritance"></a>Наследование типа QOM

Минимальный код, который должен быть написан, чтобы наследовать тип в QOM,
включает в себя:

* инициализацию структуры `TypeInfo`, где должны быть указаны
строковые имена родительского типа и наследуемого типа;

* функцию `register_types` --- конструктор модуля, вызывающую
`type_register_static` для всех `TypeInfo` в модуле;

* применение макроса `type_init`, указывающего компилятору, что
`register_types` является конструктором модуля<!--: её следует вызвать
неявно (не помню, что я этим хотел сказать)-->;

* правило в `Makefile`, регистрирующее модуль в системе сборки.

Добавленный таким образом тип не будет обладать новой
функциональностью. А если родитель _абстрактный_, то новый тип даже
нельзя будет создать.
<!--+ TypeInfo, register_types, type_register_static, type_init, минимальный код
при наследовании типа +-->

<!--- структура экземпляра, конструктор экземпляра, структура класса,
конструктор класса, TypeInfo, минимальный код при наследовании типа --->
На практике код чаще всего содержит, среди прочего, следующее.

* Структуры экземпляра и класса. В них _первым_ полем обязательно присутствует
структура экземпляра родительского типа. <!-- Это повтор, см.
[$](#rel.QOM_type_structs). -->

* Указание размеров структур экземпляра и класса в `TypeInfo`.

* Указание в `TypeInfo` адресов функций, выполняющих роли конструкторов и
деструкторов экземпляра и класса.
<!--+ практический код при наследовании типа +-->


<!--- тип QOM, практический код при наследовании типа, свойство устройства,
реализация устройства, состояние устройства, стиль программирования,
перегрузка (QOM), сброс устройства --->
## Определение модели устройства

Модель устройства является типом QOM и должна содержать соответствующий код.
Кроме этого код модели устройства обычно содержит:

* регистрацию состояния устройства,
* регистрацию свойств устройства,
* функцию реализации устройства,
* функцию сброса устройства,

Регистрация состояния устройства заключается в следующем.

* Инициализируется структура `VMStateDescription`.
Важным полем этой структуры является массив `fields`.
Помощи макросов вида `VMSTATE_*` в этом массиве должны быть перечислены поля
структуры экземпляра составляющие состояние устройства.

    * Выбор макроса зависит от типа поля;
    * Если поле является структурой, то для неё должна быть инициализирована
    отдельная структура `VMStateDescription`.
    * Последним элементом массива должен быть признак конца:
    `VMSTATE_END_OF_LIST()`.
    * Допускается указание _версии_ поля, которая используется для
    совместимости снимков разных версий модели устройства.

* Перегрузка поля `vmsd` структуры класса указателем на структуру
`VMStateDescription`.
[Напомним](#overridance_in_QOM), что перегрузка производится в
соответствующем конструкторе: конструкторе класса.

Регистрация свойств устройства выполняется следующим образом.

* Создаётся массив описателей свойств.
Описателем является структура `Property`.
Определение элементов массива осуществляется с помощью макросов вида
`DEFINE_PROP_*`.
Выбор макроса зависит от типа свойства.
При этом для каждого свойства указывается:

    * строковое имя,
    * поле этой структуры, которое будет хранить значение свойства;
    * значение по умолчанию (в случае, когда оно не фиксировано API QEMU).

Последним элементом должен быть признак конца массива:
`DEFINE_PROP_END_OF_LIST()`.

* Определение в заголовочном файле устройства макросов со
строковыми именами свойств (требование стиля программирования).

* Перегрузка поля `props` структуры класса указателем на массив описателей
свойств.

Функция сброса устройства должна устанавливать структуру экземпляра в
определённое начальное состояние.
Причём обработку полей, которые не меняются в процессе работы устройства
следует оставить функции реализации или конструктору.

Функция реализации устройства должна выполнять действия, которые зависят от
значений свойств. Остальные действия (кроме сброса) желательно размещать в
конструкторе.
<!--+ минимальный код определения модели устройства +-->


<!--- тип QOM, практический код при наследовании типа, конструктор экземпляра
конструктор класса, компоненты ВМ, ВВМ, ОС, Linux,
микропрограммное обеспечение --->
## Определение модели вычислительной машины

Виртуальная вычислительная машина является типом QOM и должна содержать
соответствующий код.
Важной особенностью является то, что имя типа должно иметь суффикс `-machine`.
Кроме этого код модели обычно содержит следующее.

* Функцию инициализации. Её не следует путать с конструктором экземпляра.
Основная задача функции инициализации --- создание и связывание компонентов.
Первоначально, она может быть пустой.

* Регистрация функции инициализации и определение строкового имени ВМ.
Используя это имя, пользователь может выбрать эту ВМ при старте эмулятора.
Эти действия выполняются в конструкторе класса. Использование этой информации
осуществляется в конструкторе экземпляра базового типа "machine".

Основную часть кода ВВМ составляет функция инициализации.
В ней создаются процессор, память, мосты, периферийные устройства и т.д.

В некоторых случаях ВВМ может допускать настройку через свойства.
Чтобы добавить свойства в ВВМ, необходимо определить конструктор экземпляра,
который выполнит соответствующие действия.
Конструктор экземпляра базового типа предусматривает ряд свойств, которых
достаточно для большинства ВВМ:

* `kernel`, `initrd` и `append`: используются, если в функции
инициализации ВВМ предусмотрена загрузка ядра ОС Linux;

* `firmware`: предусматривает загрузку микропрограммного обеспечения;

* `usb`: даёт возможность включить поддержку USB в ВВМ; и др.

Реальная работоспособность этих свойств зависит от реализации функции
инициализации ВВМ.

Кроме того, структура экземпляра базовго типа, содержит следующие
поля, не оформленные как свойства:

* `cpu_model`: имя QOM типа процессора;

* `ram_size`: объём ОЗУ.

Однако, функция инициализации может игнорировать и их: реальная
ВВМ может существовать с фиксированной моделью процессора и объёмом
ОЗУ.
<!--+ минимальный код определения ВВМ, свойства ВВМ +-->


<!--- QEMU --->
# Подход к автоматизации

Любая модель, как устройство, так и машина, является частью эмулятора.
Следовательно, её код, среди прочего, содержит фрагменты, обусловленный,
по большей части, требованиями эмулятора, а не особенностями оригинала.
Таким образом, условно код модели можно разделить на две части:
_индивидуальную_ и _интерфейсную_.

В первую очередь рассмотрим это разделение для устройств.
Индивидуальная часть задает поведение виртуального устройства в его программной
реализации.
Именно эта часть определяет то, как именно будет эмулироваться присутствие
конкретно этого устройства в системе; делает его модель особенной,
относительно других устройств, уникальной. При этом модель устройства является
частью инфраструктуры QEMU, и индивидуальная часть должна эмулировать
поведение устройства, используя
предоставленные посредством API QEMU возможности. В модели всегда можно
выделить часть кода,
взаимодействующую с этим API, она и называется _интерфейсной_. То есть,
интерфейсная часть кода
служит связкой между кодом индивидуальной части модели и остальным кодом
эмулятора.

Индивидуальная часть обычно сформулирована на естественном языке в документации
на устройство. При этом отсутствует единый формат _формального_ описания,
которого бы придерживались производители.
Ввиду этого автоматизация разработки этой части весьма затруднительна и
выходит за рамки этой работы.

С другой стороны, интерфейсная часть всех устройств очень похожа. Отличия
заключаются, в основном, в перечне и количестве используемых моделью внешних
интерфейсов, а также в именах собственных, которые часто формируются из
названия модели устройства путём применения к нему формализованных правил,
сформулированных или _де-факто_ (в коде существующих устройств), или в
тексте из файла `CODING_STYLE`, описывающим принятый в проекте стиль
программирования.

Задав правила формального описания интерфейсной части, можно
разработать программу, принимающую небольшое количество параметров
и возвращающую компилируемый код-заготовку, реализующий минимальный функционал и
готовый к внесению в него индивидуальной логики вручную. Таким образом,
программист, ознакомившись с техническим описанием устройства, может
формально сформулировать перечень требуемых модели устройства интерфейсов
и, применив разработанный инструмент, приступить непосредственно к
реализации индивидуальной части.

Отдельно нужно сказать о применимости данного подхода к вычислительным машинам
в целом. Хотя их описания,
аналогично устройствам, лишены формализма и единообразия, в QEMU
присутствует развитое API для интеграции устройств в единое целое (то есть в
ВМ).
Состав ВМ определяется функцией её инициализации, которая последовательно
создаёт все устройства и соединяет их воедино. В данной работе разработан
программный интерфейс, позволяющий описать состав ВМ и сгенерировать её
функцию инициализации. Интерфейс реализован на языке Python, поэтому описание
получается несколько короче, чем соответствующий ему генерированный код. Но
основное преимущество заключается в возможности написания графического
интерфейса, значительно повышающего наглядность и скорость описания ВМ. Таким
образом, отсутствие общепринятого формализованного описания ВМ смягчается
разработанным графическим интерфейсом для компоновки ВМ по описанию на
естественном языке.

С помощью разработанного API можно формально описать полноценную ВМ. При этом
имеются следующие ограничения.

1. Устройства, входящие в ВМ, должны иметь интерфейсную часть, реализованную в
полном соответствии с принятым в QEMU подходом к написанию моделей устройств.
Иначе несоответствие придётся компенсировать вручную.

2. Сгенерированная машина не поддаётся настройке, так как все её параметры
зафиксированы на уровне исходного кода. Реализация возможности настраивать
машины требует внесения кода вручную.

Первое ограничение не существенно, если преобладающая часть устройств ВМ
реализуется вместе с ней по формальному описанию.
Такие устройства будут иметь совместимую интерфейсную часть.
Но в QEMU присутствует ряд устройств, которые были реализованы еще до того, как
был выработан текущий подход к написанию моделей устройств.
На данный момент не все из них были переписаны в соответствии с этим подходом.
То есть они реализуют свою индивидуальную часть в обход новейших возможностей
API для интерфейсной части.
Если же нужно использовать подобную модель устройства, то возможны следующие
варианты.

* Обновить реализацию устройства.

* Вписать код, выполняющий его подключение в ВМ, в функцию инициализации после
её генерации.
Этот вариант существенно ограничивает возможности инструмента:

    * устройство должно будет подключаться к шине вручную;

    * если устройство --- мост, то и его шины должны будут подключаться также
    вручную;

    * подключение прерываний придётся выполнять вручную;

    * в общем случае, отсутствие возможности сослаться на устройство из API
    при проектировании устройства приведёт к снижению количества
    автоматизированной работы.

Второе ограничение заключается в следующем.
Сгенерированная ВМ зафиксирована на уровне исходного кода.
То есть, в неё будет проблематично добавить новое устройстве и невозможно
удалить имеющееся.
CLI QEMU поддерживает ряд ключей, динамически создающих
дополнительные устройства (например, можно подключить к шине PCI новую
функцию).
Также часть параметров машины задается пользователем только в момент запуска
эмулятора:

* файл-образ ПЗУ (НЖМД, микросхема flash-памяти, CD, и т.п.),
* оконечную точку УАПП (виртуальный терминал, файл, и т.п.),
* способ подключения сетевого порта (TAP-адаптер, Ethernet по UDP и т.п.)
и т.д.
<!--+ интерфейсная часть, индивидуальная часть +-->


## Метод шаблонов
<!--- интерфейсная часть, индивидуальная часть, QEMU, эмулятор, интерфейс,
язык Си, функция (Си), аргумент функции, структура (Си) --->
Состав интерфейсной части устройства определяется:

* задаваемым эмулятором формальным минимумом;
* потребностями индивидуальной части.

QEMU предоставляет ряд интерфейсов, из которых в интерфейсную часть
выбираются нужные.
Код, соответствующий отдельно взятому интерфейсу, единообразен.
Его можно получать из некоторого набора строковых заготовок, путём подстановки
параметров.
Часто для одного интерфейса необходимо сгенерировать несколько фрагментов кода.
При этом фрагменты должны следовать в правильном порядке как относительно
друг друга, так и фрагментов других интерфейсов.
Это требование следует из синтаксиса языка Си.
Например, если один из аргументов функции является
указателем на структуру, то сама структура должна быть объявлена выше.
Часть параметров одних шаблонов может быть связана с параметрами других
шаблонов.
<!--+ шаблон +-->
<!--- шаблон, QOM, конструктор устройства, регистр устройства,
участок памяти IO, --->
Например, конструктор устройства является частью шаблона, встраивающего
устройство в иерархию типов QOM.
Если же устройство имеет регистры, то для их реализации применяется шаблон
участка памяти типа IO.
Но регистры должен быть зарегистрирован конструктором.
А значит, имя переменной, описывающей регистры, является параметром
шаблона конструктора.
<!--+ +-->

<!--- шаблон --->
Таким образом, между шаблонами существуют следующие виды связей:

* порядковая --- один шаблон должен следовать за другим;
* параметрическая --- когда в нескольких шаблонах используются связанные по
значению параметры.
<!--+ связь между шаблонами +-->

<!--- шаблон, связь между шаблонами, модуль (Python)  --->
## Программный модуль шаблонов

Связи между шаблонами происходят или от эмулятора, или от языка Си.
Это значит, что связи могут быть или получены автоматически, или быть
определены вручную однократно и тиражироваться.
С учётом этого был разработан программный модуль автоматизирующий работу со
связями.
Модуль предоставляет два интерфейса:

* по _использованию_ шаблонов;
* по _добавлению_ шаблонов связей между ними.
<!--+ интерфейс использования шаблонов, интерфейс добавления шаблонов  +-->

<!--- интерфейс использования шаблонов, QEMU, иерархия классов QOM, ВМ,
PCI, MSI, QEMU, PCI Express, устройство PCI, функция PCI --->
### Интерфейс использования шаблонов
Интерфейс использования шаблонов ориентирован на получение от пользователя
перечня перечня интерфейсов QEMU, требуемых разрабатываемой моделью, и их
параметров.
Для этого интерфейс использования предоставляет иерархию классов.
Она построена по тому же принципу, что и иерархия классов QOM.

* `QOMDescription`
    * `SysBusDeviceDescription`
    * `PCIExpressDeviceDescription`
    * `MachineNode`

`QOMDescription` является базовым классом. Он не предназначен для
использования.

`SysBusDeviceDescription` описывает устройство на системной шине.

`PCIExpressDeviceDescription` описывает PCI устройство QEMU.

Напомним, что PCI-_устройство_ в QEMU соответствует одной _функции_ реального
устройства.
А поскольку QEMU не моделирует физические взаимодействия по шине,
поддержка MSI (а именно реакция на запись сообщения в память) реализуется
мостом или контроллером прерываний, обычно являющимися устройствами.
Как следствие, и PCI, и PCI Express устройство может быть описано через этот
класс.

Перечисленные классы выполняют роль контейнеров для параметров.
При генерации кода на основе этих параметров создаются объекты внутренних
классов модуля, непосредственно участвующего в генерации.

В то время как для описания устройств системной шины или PCI достаточно
одного объекта перечисленных классов, для описания ВМ требуется ещё
одна иерархия, рассмотренная [$](#rel.machine_hierarchy).
Объект класса `MachineNode` служит контейнером для объектов последней иерархии
и прочих параметров генерации.

Совместно объекты этих классов-потомков `QOMDescription` образуют
_проект_ (`QProject`), аккумулирующий данные для генератора кода.
<!--+ QOMDescription, SysBusDeviceDescription, PCIExpressDeviceDescription,
MachineNode, QProject +-->

<!-- MachineNode, мост, дочернее устройство, иерархия QOM, дочерняя шина,
устройство-родитель шины, свойства устройства, GPIO, инкапсуляция (ООП),
источник прерывания, приёмник прерывания, адресация GPIO, GPIO,
двоичный сигнал, участок памяти, участок-контейнер, участок-псевдоним,
участок-RAM, участок-ROM, участок-IO, графический интерфейс инструмента -->
#### <a name="rel.machine_hierarchy"></a>Модель вычислительной машины

Содержимое ВМ описывается с использованием следующей иерархии классов.

* `Node`
    * `BusNode`
        * `SystemBusNode`
        * `PCIExpressBusNode`
        * `ISABusNode`
        * `IDEBusNode`
        * `I2CBusNode`
    * `DeviceNode`
        * `SystemBusDeviceNode`
        * `PCIExpressDeviceNode`
    * `IRQLine`
    * `IRQHub`
    * `MemoryNode`
        * `MemoryLeafNode`
            * `MemoryAliasNode`
            * `MemoryRAMNode`
            * `MemoryROMNode`

`Node` содержит уникальный идентификатор узла ВМ.

`BusNode` содержит все данные, необходимые чтобы описать шину любого типа.
Все дочерние классы конкретизируют эти данные. Они были введены для сокращения
объёма кода, необходимого для ручной работы с программным интерфейсом.
При использовании графического интерфейса это не актуально.

Большинство параметров шины определяют генерацию кода для шины этого типа. И
только следующие параметры определяют место шины в ВМ:

* ссылка на мост;
* ссылки на дочерние устройства.

`DeviceNode` описывает параметры, присущие любому устройству:

* модель устройства (тип в иерархии QOM);
* ссылку на родительскую шину;
* ссылки на дочерние шины, если устройство является мостом;
* список значений свойств устройства;
* ссылки на подключённые GPIO с параметрами их подключения.

Классы наследуемые от `DeviceNode` расширяют этот список в соответствии с
шаблонами устройств для конкретных стандартов шин.

`IRQLine` (линия) и `IRQHub` (концентратор) описывают распространение
прерываний между устройствами (ту его часть, которая по какой-то причине не
инкапсулирована в шину).
Концентратор прерываний используется в случаях, когда одно
прерывание должно быть доставлено в несколько устройств и/или может быть
получено из нескольких устройств (так как линия прерывания соединяет строго
два конца).
Линия содержит информацию об источнике и приёмнике прерывания.
Причём для каждой точки подключения, являющейся устройством, определены:

* ссылка на устройство;
* имя GPIO;
* индекс GPIO.

Если концом является концентратор, то достаточно только ссылки.

Исходя из используемого в QEMU обобщения прерываний до GPIO, данные связи могут
использоваться для обмена любыми двоичными сигналами, а не только прерываниями.

Следующие классы используются для явного создания участком памяти.
Большую часть адресного пространства ВМ определяют сами устройства.
Участки памяти, соответствующие ОЗУ, некоторм ПЗУ и т.п., должны быть добавлены
явно.
Кроме этого, некоторые мосты не создают адресное пространство для своих шин, а
требуют его передачи извне.
В таблице [$](#tbl.memory_region_correspondence) приведено соответствие классов
узлов ВМ и типов участков памяти, шаблоны которых создаются для этих узлов.

Таблица <a name="tbl.memory_region_correspondence">$</a>.
Соответствие узлов ВМ и описываемых ими участков памяти.

+-------------------+--------------------+
|       Узел        | Тип участка памяти |
+===================+====================+
|    `MemoryNode`   |      контейнер     |
+-------------------+--------------------+
| `MemoryAliasNode` |      псевдоним     |
+-------------------+--------------------+
|  `MemoryRAMNode`  |         RAM        |
+-------------------+--------------------+
|  `MemoryROMNode`  |         ROM        |
+-------------------+--------------------+

`MemoryLeafNode` (лист) является служебным промежуточным классом, запрещающим
добавлять участки в участки, не являющиеся контейнерами.
Для участков IO специального узла не предусмотрено.
Это обусловлено тем, что IO участки используются для реализации регистров.
А все регистры должны быть распределены по устройствам.

Каждый из классов, описывающих участок памяти, предусматривает следующие
параметры:

* отладочное строковое имя;
* размер;
* смещение в контейнере и ссылку на него;
* допустимость перекрытия в пределах одного контейнера и приоритет для его
разрешения;

<!--
`MemoryNode` _может_ иметь не пустой список ссылок на детей, а
`MemoryAliasNode` _должен_ содержать смещение в пределах интервала, на который
он перенаправляет запросы, и ссылку на него.
-->

Основными функциями всех классов, предоставляемых интерфейсом использования
шаблонов (включая потомков `QOMDescription`), являются:

* хранение параметров генератора,
* сохранение параметров в файл и обратно.
<!--+ Node, BusNode. SystemBusNode, PCIExpressBusNode, ISABusNode, IDEBusNode,
I2CBusNode, DeviceNode, SystemBusDeviceNode, PCIExpressDeviceNode`,
IRQLine, IRQHub, MemoryNode, MemoryLeafNode, MemoryAliasNode, MemoryRAMNode,
MemoryROMNode +-->

<!--- QProject, Python, аттрибут объекта (Python), "простой тип" (Python),
None (Python) --->
### Формат файла проекта

<!--
При работе с ГИ используется
его подкласс `GUIProject` (GUI project), дополнительно хранящий настройки
отображения.
-->

Формат файла, хранящего проект, основывается на возможности интерпретатора
языка Python динамически добавлять код в программу.
Сохранённый проект представляет собой код на языке Python.
В данном случае код загружается из файла.
Поскольку инструмент сам написан на языке Python, данное решение существенно
упростило разработку.
Результатом выполнения кода проекта является определение переменной,
ссылающейся на объект класса `QProject`, _эквивалентный_ объекту,
сохранённому в этом коде.
Генератор файлов сохранений изначально разрабатывался таким образом, чтобы
файлы выводились в удобном для человека форматировании.

Под _эквивалентностью_ сохранённого и восстановленного объектов понимается:

* равенство значений простых типов в соответствующих атрибутах;
* каждый ссылочный атрибут в восстановленном объекте указывает на
объект, эквивалентный тому, на который этот атрибут указывал в
сохранённом объекте<!-- (ссылки на `None` восстанавливаются как ссылки на
`None`) (излишняя техническая деталь) -->.

При сохранении не гарантируются:

* равенство _незначащих_ пробельных символов;
* синтаксически незначащий порядок фрагментов кода (порядок определения
аргументов конструкторов со значениями по умолчанию, порядок
восстановления несвязанных объектов, и т.п.);
* сохранность комментариев, если таковые были внесены вручную в файл
проекта.

Данные особенности создают сложности при ручной работе с файлами проекта,
а также при хранении файлов с использованием системы контроля версий.
Решение этой проблемы является одним из направлений дальнейших исследований.
<!--+ формат файла проекта, эквивалентный объект (Python) +-->


<!--- шаблоны, .format (Python), % (Python), форматная строка (концепция),
АСД, препроцессор (Си), стиль программирования QEMU, printf,
интерфейсная часть, индивидуальная часть, цикл (Си), ветвление (Си),
конструктор экземпляра, конструктор класса, принцип чёрного ящика,
функции (Си), макрос, функция реализации устройства,
функция инициализации ВВМ --->
###<a name="Codegeneration"></a>Интерфейс добавления шаблонов

Шаблоны реализованы с помощью форматных строк.
Генерация кода заключается в подстановке параметров в форматные строки.
Из полученных фрагментов кода затем составляются файлы.
Для форматирования используются следующие способы:

* `printf`-подобный, реализуемый оператором `%`, для простых подстановок;
* расширенный, поддерживаемый методом `format`.

Второй вариант используется для написания более сложных шаблонов, так как
за счёт именования позиций подстановок в форматных строках легче
ориентироваться, однако они получаются избыточней.

Форматные строки являются самым низкоуровневым способом определения
шаблонов.
Изначально все шаблоны разрабатывались в виде форматных строк.
Сложность их написания сравнима со сложностью программирования на языке Си.
Однако форматные строки ограничены в программной обработке.
Кроме этого было замечено что у них есть много общего, так как они являются
кодом на языке Си.
В связи с этим для разработки шаблонов был введён вспомогательный интерфейс.
Он тоже основан на форматных строках, но предоставляемые им инструменты
ориентированы на генерацию базовых конструкций языка Си.
Поэтому интерфейс напоминает программную реализацию АСД, однако
есть принципиальное отличие: он поддерживает и язык препроцессора тоже.

Параллельно была предпринята попытка использовать для определения
шаблонов АСД языка Си. Библиотека PyCParser[[$](#ref.PyCParser)],
реализует двустороннее преобразование. Однако у применения АСД имеются
следующие недостатки:

* не поддерживается препроцессор, макросы которого активно используются
в интерфейсной (и не только) части модели устройства;

* не учитываются незначащие символы (пробелы, переносы строк,
комментарии), что требует доработки генератора PyCParser, таким образом,
чтобы он генерировал код, не противоречащий стилю программирования QEMU.

В настоящее время модель смешанного языка Си и препроцессора является
одним из основных объектов дальнейших исследований.
Текущая версия успешно описывает такие макроскопические конструкции как
структуры, переменные и их инициализацию, макросы и объявления функций.
Заметным упущением является отсутствие описания тел функций.
Они задаются первоначальным способом: форматными строками.
Ввиду того, что инструмент не ставит своей целью генерацию индивидуальной
части моделей устройств, тела функций, в большинстве случаев, могут
рассматриваться модулем шаблонов как чёрные ящики.
Исключением является конструкторы, функция реализации устройств и функция
инициализации ВВМ.
Но эти функции суть последовательность инициализаций: такие конструкции как
циклы и ветвления в таких функциях не используются.
То есть практической надобности в детальной проработке этой части модели пока
не было.
<!--+ общие сведения об интерфейсе добавления шаблонов +-->


<!--+ общие сведения об интерфейсе добавления шаблонов,
двоичный транслятор QEMU, PyCParser, макрос  +-->
#### Модель языков Си и препроцессора

Интерфейс добавления шаблонов основан на модели языков Си и препроцессора.
Она описывает _гибридный язык_, являющийся слиянием этих языков.
Интерфейс работает на уровне содержимого файлов.
Разработчик описывает содержимое шаблона с точки зрения того, какие
конструкции должны быть добавлены в файл в соответствии с этим шаблоном.
Причём один шаблон может касаться нескольких файлов, ровно как и один файл
может содержать конструкции из нескольких шаблонов.
Некоторые конструкции из шаблонов связаны с уже существующими в QEMU
конструкциями.
Поэтому интерфейс позволяет определять содержимое существующих файлов.
Описание существующих конструкций носит декларативный характер.
Многие подробности могут быть пропущены, так как генерация не предполагается.
Иными словами используется принцип минимально достаточной информации.

При описании содержимого файла используются следующие классы.

* `Type`
    * `TypeReference`
    * `Structure`
    * `Function`
    * `Pointer`
    * `Macro`
* `Initializer`
* `Variable`
* `Usage`

_Тип_ (класс `Type`), как можно заметить из перечня подклассов, тут
понимается как нечто большее, чем тип в языке Си.

Объект класса `Type` обладает следующими свойствами:

* `name` --- уникальное имя типа;
* `incomplete` --- незавершенный тип, нельзя создать _переменную_
такого типа;
* `definer` --- идентификатор файла, где этот тип _определён_;
* `base` --- базовый тип, который имеется в языке, для его использования
не нужно подключать заголовки.

Уникальность имени типа даёт возможность находить тип только по имени:
не требуется сначала искать файл, где этот тип определён. Это облегчает
работу разработчика шаблонов, но имеет _теоретический_ недостаток,
заключающийся в следующем.
Совместное хранение макросов вместе с типами языка Си, строго говоря, делает
требование уникальности имени невыполнимым в общем случае.
Однако данная проблема не возникает в QEMU благодаря принятому стилю
программирования.
Известно, что в QEMU реализации двоичного транслятора для разных
целевых архитектур имеют пересекающиеся множества имён символов языка Си
и препроцессора. Но устройства и ВМ реализуются архитектурно независимо,
и, обычно, не связаны с реализацией транслятора.
Кроме этого разные реализации транслятора не используются вместе.

Класс `Type` не предусматривает шаблона для генерации кода. Это значит,
что нельзя сгенерировать файл, где есть хоть одна сущность, описываемая
этим классом. Фактически, этот класс применяется для ручного определения
списка типов, присутствующих в существующих файлах QEMU, в тех
случаях, когда достаточно только имени типа для подключения нужного
заголовка.

Одним из направлений дальнейших исследования является синтаксический
анализ файлов QEMU с целью автоматического создания объектов,
описывающих существующие типы. В настоящий момент такая функциональность
реализована только для макросов препроцессора и опирается на функционал
модифицированного препроцессора из библиотеки PyCParser.

Объект `TypeReference` (ссылка на тип) используется для ссылок на типы
из других файлов. Любой тип может присутствовать непосредственно только
в файле, где он объявлен. Такой подход даёт возможность при генерации кода
однозначно определить следует ли сгенерировать непосредственное
определение типа по шаблону, или сгенерировать включение заголовочного
файла, где он определён.

Если необходимо объявить переменную типа из другого файла, используется
`TypeReference`. То есть создаётся ещё один тип с тем же именем, но
особым способом обработки:

* имя такого типа не индексируется реализацией интерфейса и, следовательно,
требование уникальности игнорируется;
* шаблоном для генерации кода `TypeReference` является директива
`include` препроцессора.

Тут важно заметить, что в отличие от Си, модель не делает разграничения
на _объявление_ и _определение_. То есть объявление функции (или
внешней переменной) в заголовке
и её определение в модуле --- два разных _определения_ в данной модели.
Синтаксическая необходимость обеспечить объявление функции до
её определения достигается добавлением в объект типа, представляющего
её определение, ссылки (`TypeReference`) на тип, представляющий её
объявление. Таким образом, будет сгенерирована директива `include`,
подключающая соответствующий заголовочный файл до определения функции.

Класс `Variable` (переменная) описывает пару: "тип, имя". В данной модели
_переменная_ нечто большее, чем переменная в языке Си. Суть этого
класса раскрывается при описании нижеизложенных классов API. Для случая,
когда этот класс используется для описания переменной языка Си,
предусмотрены следующие поля:

* `static` --- соответствует одноимённому слову языка Си;
* `initializer` --- инициализатор, начальное значение переменной;
* `array_size` --- используется для определения массивов, в том числе и
безразмерных (когда размер определяется компилятором по инициализатору,
или когда нужно определить переменную-указатель, используя `[]` вместо
`*`).

Класс `Structure` (структура) используется для объявления составного типа.
По представленному в нём описанию создаётся конструкция `struct` языка Си.
Объект класса содержит список полей (`fields`), определяемых объектами
класса `Variable`.
<!--
Иногда часть полей структуры в языке Си определяется
макроподстановкой. В данной модели такие поля описываются одной
_переменной_, тип которой является соответствующим макросом (`Macro`), а
имя игнорируется.
-->

Класс `Function` (функция) используется для описания конструкций языка
Си, связанных с функциями этого языка:

* объявление функции;
* определение функции, в том числе статических (`static`) и/или
встраиваемых (`inline`);
* определение типа указателя на функцию (применяется совместно с
классом `Pointer`);

Объект `Function` содержит следующие дополнительные поля:

* `ret_type` --- тип возвращаемый функцией;
* `args` --- список аргументов функции (аналогично полям структуры);
* `static` и `inline` --- фактически определяют наличие соответствующих
ключевых слов в генерированном коде;
* `body` --- текст тела функции;
* `used_types` и `used_globals` --- список, соответственно, типов и
глобальных переменных, использованных в теле функции; данная информация
необходима, так как на данный момент модель не поддерживает тела
функций.

При определении тела функции разработчик должен, используя
вспомогательные средства интерфейса, сконструировать тело функции, сохраняя
списки использованных в нём типов и глобальных переменных.
Затем он передаёт эти списки в объект функции.

Важно заметить, что под понятие "использованный тип" подпадают
также такие сущности как:

* вызванные функции;
* структуры, использованные при объявлении переменных;
* использованные макросы; и т.п.

Класс `Pointer` (указатель) применяется для создания указателей
различного вида:

* именованных типов указателей (например, `typedef int* intptr;`),
включая указатели на функции;
* определение переменных-указателей на другие типы (в том числе
полей структур и аргументов функций).

При определении переменной-указателя создаётся _безымянный_ тип
указателя. На самом деле имя ему формально генерируется путём
подстановки '`*`' к основному типу, согласно синтаксису языка
Си. Но имя такого типа не индексируется реализацией интерфейса и, следовательно,
может не быть уникальным. Кроме того, этот тип не привязывается
к какому-либо файлу, то есть наличие где-нибудь переменной такого
типа не вызывает генерации директивы `include` само по себе.
Однако тип под указателем, если он не является базовым, должен быть
обеспечен либо директивой `include`, либо непосредственным
определением.

Класс `Macro` (макрос) соответствует директиве `define`
препроцессора. Поддерживаются как параметризованные макросы, так
и не параметризованные макросы. Однако поддержка параметров
ограничивается только генерацией вызова макроса: раскрытие же не
требуется для генерации файла (ровно как и выполнение
сгенерированного Си-кода, чем, по сути, и является раскрытие макроса,
с точки зрения данной модели).

Класс `Initializer` (инициализатор) используется для определения
начальных значений
переменных или параметров вызова макроса. Поле `code` содержит
данные, используемые для генерации кода инициализатора, а поля
`used_types` и `used_variables` хранят ссылки на, соответственно,
типы и переменные, использованные в коде инициализатора. Модель
инициализатора схожа с моделью тела функции, и обе они пока не
развиты, являясь объектами дальнейших исследований.

Класс `Usage` (использование) применяется, когда при генерации
переменной некоторого
типа не достаточно использовать в шаблоне имя типа непосредственно.
Т.е. имя типа должно быть преобразовано некоторым образом перед
вставкой в шаблон. `Usage`
добавляет инициализатор (`Initializer`) к _типу_ переменной, на
основании которого и происходит видоизменение имени типа.
Единственным примером в настоящее время является макрос.
Инициализатор используется для расстановки
значений при генерации вызова макроса. Имя переменной и _её_
инициализатор при этом игнорируются.

Рассмотренная модель не является законченной. Но даже в таком варианте
она позволяет с достаточно гибкостью описывать шаблоны устройств и ВМ,
используемые при генерации интерфейсной части их кода. Развитие
этой модели является направлением дальнейших исследований.
<!--+ модель Си и препроцессора, элементы интерфейса добавления шаблонов +-->


<!--- шаблон, форматная строка, модель Си и препроцессора,
двоичный транслятор QEMU --->
##<a name="Codegeneration"></a>Генерация кода

Генерация кода заключается в получении из шаблонов фрагментов кода и
объединение их в файлы.

Получаемые при генерации фрагменты кода не являются независимыми. Язык
Си требует, чтобы многие имена были объявлены до их использования.
В том числе с использованием директивы `include` препроцессора.
Аналогичное требование есть для препроцессора.
То есть генератор должен не только сгенерировать фрагменты кода, но
и расположить их в правильном порядке. Также требуется сгенерировать
включение требуемых заголовков, причём желательно, минимизировать
количество включений. Не стоит забывать, что порядок включения заголовков
иногда существенен.

Для учёта этих особенностей была разработана модель файла с исходным кодом
Она оперирует неделимыми текстовыми
фрагментами, из которых состоит файл, и порядковыми связями между ними.
Элементы этой модели конструируются из элементов модели языка Си и
препроцессора.

### Модель файла с исходным кодом

Описанная выше модель языка Си и препроцессора не обеспечивает генерацию
синтаксически корректного файла. Её задача: сгенерировать законченные
_фрагменты_ генерируемого файла. При этом остаётся решить следующие
задачи:

* расположить фрагменты в синтаксически корректном порядке;
* обеспечить смысловую группировку фрагментов;
* соблюсти требования стиля программирования QEMU к форматированию кода
(длина строки 80 символов, отступы, правила переноса и т.д.);
* устранить дублирующиеся фрагменты;
* минимизировать количество директив включения заголовков.

Далее эти задачи рассматриваются подробнее.

### Сортировка фрагментов

Язык Си накладывает жесткие ограничения на порядок
определения различных символов. Например, тип должен быть объявлен
до того, как будет создана переменная этого типа, или будет
объявлена функция, принимающая аргумент такого типа. Подробное
рассмотрение всех возможных примеров выходит за пределы данной статьи.
Важно заметить, что почти все фрагменты связаны друг с другом, образуя
ациклический граф, и для обеспечения синтаксически корректного порядка
используется топологическая сортировка.

Помимо требований синтаксиса есть требования стиля программирования и
здравого смысла, согласно которым, фрагменты должны следовать в
следующем порядке:

1. включение заголовков;
2. объявление типов языка Си и макросов;
3. объявления функций;
4. определение функций, глобальных переменных и прочий код.

### Соблюдение стиля программирования

Стиль программирования требует, чтобы строки были не длиннее
80 символов. Удовлетворение этого требования было снято с модели
модели языков Си и препроцессора, чтобы не усложнять её. Требуемая длина
строки обеспечивается переносом строк по словам, при этом применяется
экранирование непечатного символа конца строки символом "`\`". Это
консервативный подход, обеспечивающий корректность в случае макросов и
строковых литералов.

В настоящее время эта проработана недостаточно: не редко на выходе инструмента
получается код, нарушающий стиль программирования.
Это является одним из важнейших направлений дальнейших исследований, так как
качественная генерация кода освобождает разработчика от необходимости
внесения ряда правок в конечный код.
То есть она ускоряет разработку новых устройств и машин, что является основной
целью данной работы.

### Устранение дубликатов

При генерации фрагментов из модели языка не отслеживаются уже созданные
фрагменты. Это сделано для упрощения алгоритма генерации фрагментов
файла из модели языка. При генерации фрагментов осуществляется обход
графа использования типов, последовательно, начиная с каждого
типа, определяемого в генерируемом файле. Если типы одного файла
используют для определения себя типы из этого же файла, то для
использованных многократно типов будет сгенерировано несколько
клонов.

Для определения клонов, каждый фрагмент хранит ссылку на тип, из
которого он получен. Таким образом для каждого типа можно найти все
клоны и оставить один. Важно учесть, что каждый клон содержит свою
часть зависимостей от других фрагментов, ровно как и разные
фрагменты зависят от разных клонов. При устранении клонов эти
зависимости объединяются. Для ускорения алгоритма объединения
зависимостей хранятся обратные ссылки (на зависимые фрагменты).

### Учёт зависимостей и взаимосвязь с существующим кодом

Как уже отмечалось, для обеспечения видимости символов, объявленных в
других файлах, генерируются директивы `include`. При этом имеются следующие
тонкости:

1. заголовочные файлы сами используют `include` для подключения других
файлов, поэтому подключение одного файла может заменить подключение
нескольких;

2. иногда важен порядок включения заголовков:

    * один заголовок может определять макросы, влияющие на поведение
    макросов в другом заголовке;
    * заголовок может не обеспечивать видимость определённых в других
    заголовках типов требуемых для определения своих типов, возлагая
    задачу включения тех заголовков на файлы, которые будут включать его
    (эта возможность активно используется в сообществе QEMU для
    облегчения работы препроцессора <!--(экономия дискового пространства,
    занимаемого исходным кодом, и электрической энергии, расходуемой на
    конкатенацию более длинных строк)--> и усложнения работы программиста).
    <!--(а шоб жизнь мёдом не казалась)-->

3. перед подключением некоторых заголовков, подключающий файл должен
сам определить некоторые макросы и/или типы языка Си; подобный случай не
встречается при написании моделей устройств и ВМ, но известно, что он
используется в коде, относящемся к двоичному транслятору.

Первая особенность используется инструментом для сокращения количества
подключаемых заголовков на основе анализа графа включения заголовков.
Граф строится автоматически с использованием модифицированного
препроцессора из библиотеки PyCParser.

Чтобы учесть вторую особенность для заголовка можно указать список
зависимостей. Каждая зависимость это тип (`Type` из модели Си и препроцессора).
Когда для
определения своего типа заголовку требуются другие типы, то можно
поступить следующими способами:

1. подключить необходимые заголовки, при этом:

    * рекурсивно подключая заголовки, удовлетворяющие зависимости
    подключаемых заголовков;
    * или добавляя зависимости подключаемых заголовков к своим зависимостям;

2. добавить требуемые типы в список зависимостей.

При генерации заголовков инструмент придерживается первого способа, подключая
все необходимые заголовки. А поскольку модификация существующих заголовков не
применяется, то для них остаётся только второй подход.
<!--+ детали генерации кода +-->


<!--- GNU Make, bash, QEMU --->
### Встраивание кода в QEMU

Для добавления заготовки устройства или платформы в QEMU кроме создания
соответствующего исходного кода на Си, нужно зарегистрировать новые
модули компиляции в системе сборке. Система сборки QEMU реализована
распространённым методом: связкой bash-сценария `configure` и набора
правил для утилиты `GNU Make`. Модули QEMU разбиты на папки
по семантике, содержащегося в них кода. В каждой папке присутствует
`Makefile` с правилами сборки специального вида, которые перечисляют
модули и вложенные папки. Инструмент имеет функциональность, позволяющую
добавить модуль-заготовку в заданную папку, убедившись, что модуль включён в
список сборки.
<!--+ детали встраивания в QEMU +-->


<!--- QEMU, Git, SHA1, граф, Python, шаблон, целое число, модуль (Python),
класс (Python) --->
## Адаптация к изменениям QEMU

QEMU является развивающимся проектом. Это приводит к тому, что в нём
периодически происходят изменения, делающие шаблоны несовместимыми с
новой версией.

Для решения этой проблемы используется эвристический подход. Все аспекты
поведения инструмента, зависящие от версии QEMU, называются _эвристиками_.
Так как один аспект работы может меняться многократно, то каждая эвристика
представлена одной или несколькими записями в базе данных.

Код инструмента получает доступ к требуемой эвристике по _строковому
ключу_ --- уникальному имени эвристики.
Значением эвристики может быть любая сущность языка Python: от целочисленной
константы до класса или модуля. Таким образом, при необходимости, можно
_подменить_ почти всю реализацию инструмента.

Каждая запись об эвристике имеет как минимум два значения: _новое_ и _старое_.
Запись привязывается к SHA1-идентификатору изменения в Git-графе
[[$](#ref.Git)] истории QEMU.

При обнаружении очередного несоответствия между инструментом и QEMU,
разработчик должен сделать следующие действия.

* Определить, что изменилось.
* Определить, SHA1 соответствующего изменения.
* Дополнить базу данных эвристик записью о новом и старом значениях, придумав
эвристике осмысленное название (_ключ_).
* Изменить код инструмента таким образом, чтобы он зависел от значения,
соответствующего _ключу_ в данный момент.

В инструменте реализован алгоритм, позволяющий для заданных SHA1,
базы эвристик и Git-истории вычислить значения для всех имеющихся в базе
ключей. Хранение обоих значений в каждой записи об эвристике избыточно. Но эта
избыточность используется для проверки непротиворечивости записей.
<!--+ эвристика, ключ эвристики, значение эвристики,
запись об изменении значения эвристики +-->


<!-- интерфейс использования шаблонов, лексическая ошибка (Python),
имя переменной, синтаксическая ошибка (Python), QEMU, марос, параметр шаблона
стиль программирования QEMU, виджет, ВВМ, аббревиатура ГИ -->
# Графический интерфейс

Все возможности инструмента доступны разработчику посредством интерфейса
использования шаблонов.
Для описания устройств и ВВМ достаточно произвольного текстового редактора.
Однако применение ГИ, спроектированного _специально_ для работы с этим
интерфейсом, имеет следующие преимущества.

* Исключены лексические в именах переменных, названиях элементов интерфейса, а
также синтаксические ошибки: разработчик вводит только значения параметров.

* Для многих значений параметров в QEMU определены макросы, использование
которых предпочтительнее, согласно стилю программирования QEMU.
ГИ интерфейс, проанализировав код QEMU, может предоставить разработчику
список доступных макросов, обычно применяемых с данным типом параметра.
Например:

    * идентификатор PCI,
    * имя типа QOM,
    * список свойств выбранного устройства и т.п.

* Исключены некоторые семантические ошибки (например, в ГИ не
предусмотрена возможность соединения линией прерывания двух шин, в то
время как разработчик волен написать всё, что угодно в текстовом редакторе).
Имеется возможность дополнить ГИ средствами поиска менее очевидных
семантических ошибок.

* Все доступные параметры сосредоточены в _виджетах_ и сопровождаются
названиями на естественном языке.
В большинстве случаев знания QEMU достаточно, чтобы понять суть параметра,
не обращаясь к справочной информации.

* Интерпретация ВМ в виде схемы.
Эта возможность особенно актуальна при разработке многоэлементных ВВМ с
большим количеством связей, так как на схеме легче ориентироваться, чем в
тексте.

Для реализации ГИ инструмент использует API Tkinter[[$](#ref.Tkinter)].
Данный интерфейс содержит всё необходимую функциональность и прост в
развёртывании, так как включён в дистрибутивы Python.

<!--+ ГИ, Tkinter +-->


<!--- ВМ, ГИ, формат файлов проекта --->
## Схема вычислительной машины

ВМ состоит из множества элементов, которые связаны между собой
различными способами. Схема позволяет разработчику видеть основные
связи в ВМ, не прибегая к интерпретации текстового описания в воображении.

Полезной функцией является экспорт схемы в векторное изображение.
Это экономит значительное количество времени разработчика при
написании отчётной документации. Например, иллюстрации, представленные
в этой статье, получены автоматизированно с использованием данной
функции.
<!--+ схема ВМ +-->


<!--- ГИ, проект, устройство, шина, схема ВВМ, эвристика (общий смысл) --->
## Обратимые операции

Современный ГИ должен предоставлять средства по работе с изменениям.
Минимальный перечень возможностей: _отмена_ и _повторение_.
В разработанном ГИ контроль изменений разработчика реализован с использованием
концепции _обратимых операций_.

Обратимая операция содержит следующую информацию:

* данные, необходимые для осуществления действия;
* данные, необходимые для возврата к состоянию до осуществления действия;
* флаг совершения операции;
* ссылки на предшествующие и последующие операции, позволяющие перемещаться
вдоль истории изменений;
* описание выполняемого операцией действия для разработчика на естественном
языке.

ГИ построен таким способом, что любые изменения в проекте должны
быть осуществлены через абстракцию "_трекер истории_" (`HistoryTracker`).
То есть, для выполнения действия ГИ передаёт трекеру параметры операции.
Трекер создаёт операцию, добавляет её в историю и выполняет.
Многие действия разработчика являются высокоуровневыми и выполняются серией
операцией.
Для выполнения таких действий определены вспомогательные функции, которые
автоматизируют создание серии операций и контролируют корректность
последовательности их выполнения.
Например, нельзя удалить устройство, не отсоединив его от шины.
Если при добавлении устройства сразу присоединять его к ближайшей (на схеме)
шине соответствующего стандарта, то разработчик будет избавлен от
необходимости явного выполнения данной операции.
Это далеко не полный список небольших эвристических автоматизаций, которые
позволяет внедрить специализированный ГИ.

В памяти всегда присутствует состояние проекта, соответствующее перечню
выполненных операций. Поддержание этого соответствия --- задача трекера.
Действия по отмене и повторению операций выполняются с использованием его
методов.
<!--+ обратимая операция, отмена операции, повторение операции,
история операций, трекер истории, серия операций +-->

<!--
Часто сделанная в прошлом операция не связана с операциями, сделанными после
неё. Такая операция может быть отменена без отмены последующих операций.
Формально, в будущем не должно быть операций, _зависящих_ от отменяемой
операции. Операция называется зависящей от _предшествующей_ операции, если
предшествующая операция:
1. изменяет то, что операция потом изменяет повторно;
2. создаёт то, что операция потом использует (для выполнения своего
действия), изменяет или удаляет;
3. удаляет то, что операция потом создаёт.

Операция, изменяющая что-то перед его удалением, здесь считается
независимой относительно удаляющей с тем условием, что при отмене
изменяющей операции будут обновлены данные в удаляющей, т.к., очевидно,
что удаляющая операция содержит в себе последнюю копию утрачиваемых
данных удаляемого объекта.
-->


<!--- проект, виджет, свойство (QOM), ВВМ, элемент ВВМ, дочерняя шина, шина,
устройство, мост, обратный вызов (Python), метод класса (Python),
обратимая операция, трекер --->
## Обратная связь при изменениях

Текущие значения параметров проекта влияют на только на:

* значения, представленные в виджетах;
* выбор типа виджета (тип свойства QOM объекта определяет, какой виджет
должен быть использован для представления его значения);
* существование виджета (при удалении элемента ВВМ должны исчезать
виджеты для его редактирования);
* перечень допустимых значений (выпадающий список выбора дочерней
шины для устройства должен отображать список всех допустимых шин,
имеющихся в ВВМ, и он должен корректироваться при добавлении или
удалении очередной шины);
* формулировка допустимых значений (если был изменён индекс шины
в мосте, все списковые виджеты должны скорректировать текст в
соответствующих строках).

Это не полный перечень зависимостей.
При этом, любое значение может быть изменено _минимум_ двумя способами:

* через соответствующий виджет;
* отменой или повторением правки разработчика.

Для учёта зависимостей в ГИ применяются _события_.
Событие соответствует выполнению или отмене операции.
Генерация событий выполняется трекером.
Каждый виджет добавляет свой метод обратного вызова в список
_наблюдателей_ трекера.
При выполнении операции трекер уведомляет всех наблюдателей о выполнении
операции.
Наблюдатель должен определить, имеет ли отношение текущая операция к
данному виждету, и среагировать соответствующим образом.
<!--+ событие, наблюдатель +-->


<!--- ГИ, стандарт де-факто, событийно-ориентированное программирование,
Python, QEMU, эвристика (QEMU), узел ВВМ, схема ВВМ, процесс, нить
эвристика (общий смысл)  --->
## Сопрограммы и фоновые вычисления

Стандартом _де-факто_ при разработке ГИ является применение
событийно-ориентированного программирования, при котором непозволительно
выполнять вычислительно нагруженные действия при обработке событий, так как это
приводит к ухудшению отзывчивости интерфейса и общему снижению удобства его
использования.

Встраивание длительных вычислений в ГИ принято производить следующими
способами:

* вынос вычислений в отдельный процесс или нить;
* фрагментация (вычисления разбиваются на малые фрагменты, которые
могут быть быстро выполнены при обработке события, и выполняются
в течение обработки специализированных событий).

С целью упрощения разработки выбор был сделан в пользу фрагментации.
Упрощение разработки заключается в следующем:

* исключено состояние гонки, не требуется синхронизация, нет параллельных
ошибок, легче отладка;
* в Python нити выполняются синхронно, причём встроенный
планировщик не различает приоритетных вычислений при обработке событий
ГИ в реальном времени от фоновых вычислений, что приводит к
снижению отзывчивости ГИ;
для реальной параллельности требуется использовать сторонние библиотеки;
* для реализации параллельности требуется больше кода;
* в инструменте отсутствуют _регулярные_ сложные вычисления: достаточно
одного процесса. <!--(нити?) здесь не важен размер контекста, предлагается
использовать более общий термин -->

Для реализации фрагментации удобно использовать _сопрограммы_ --- функции
позволяющие, _сохраняя_ значения локальных переменных, приостановить
своё выполнение на не определённый срок. При возврате управления сопрограмме
она продолжает работу с места, где была приостановлена.

Python, в свою очередь, имеет языковую поддержку так называемых
 _генераторов_ --- сопрограмм способных дополнительно вернуть значение
при очередной остановке управления (инструкцией `yield`).

В ГИ длительные вычисления реализуются генераторами. Долго работающие
функции реализуются как сопрограммы, снабжаясь операторами `yield` через
небольшой интервал вычислений.
Управление между сопрограммами распределяется _диспетчером_, который
встраивается в обработку событий ГИ.
Величина интервала между остановками выбирается вручную.
При этом ищется баланс между:

* возрастающим общим временем выполнения сопрограмм за счёт увеличения доли
накладных расходов при уменьшении длины интервала;
* снижением отзывчивости ГИ при увеличении длины интервала с целью
уменьшения доли накладных расходов и ускорения сопрограмм.

ГИ в фоне выполняет следующие задачи:

* анализ исходного кода QEMU;
* предварительное вычисление эвристик о текущей версии QEMU;
* генерация кода;
* уведомления о _сигналах_ --- событиях, не требующих синхронной обработки;
* динамическое размещение узлов на схеме ВММ (эвристика позволяющая
избегать взаимного перекрытия изображений узлов).

<!--+ сопрограмма, генератор (Python), диспетчер сопрограмм, сигнал
дилемма выбора длины интервала сопрограммы, сигнал +-->


<!--- виджет, ГИ, Tkinter, форматная строка (концепция), модуль (Python),
обратимая операция --->
## Динамический текст, интернационализация

При разработке ГИ иногда возникает возможность изменять статический текст в уже
созданных виджетах.
Современные API для разработки ГИ (в том числе и используемый в данном
инструменте Tkinter) имеют необходимый функционал.
Однако способ отличается у разных классов виджетов.
Отображаемый текст может быть результатом подстановки значений в форматную
строку.
Подставляемые значения тоже могут являться результатом подстановки.
В общем случае зависимости формируют ациклический граф.


Для работы с таким текстом в ГИ реализован вспомогательный модуль со
следующими функциями:

* отслеживание зависимостей между строками;
* динамическое обновление производных строк при изменении подставляемых;
* классы-оболочки для библиотечных виджетов, расширяющие перечень параметров,
в качестве которых могут быть использованы динамические строки.

Отслеживание зависимостей основано на уже имеющемся в библиотеке классе
`Variable` (переменная).
Потомки этого класса позволяют работать со строками (`StringVar`), целыми
числами (`IntVar`), дробными числами (`DoubleVar`) и булевыми значениями
(`BoolernVar`).
Класс `Variable` имеет методы `set` и `get` для доступа к значению переменной
и метод `trace_variable`, позволяющий назначить функцию обратного вызова на
изменение переменной.
Для реализации динамически обновляемого форматирования строк были реализованы
следующие классы:

* `FormatedStringVar` --- потомок `StringVar`, соответствующий производной
строке и связывающий её с форматной строкой и параметрами форматирования.
* `FormatVar` --- потомок `StringVar` добавляющий поддержку оператора
форматирования (`%`). Оператор возвращает `FormatedStringVar`.

Форматная строка и её параметры могут быть переменными (потомками `Variable`).
`FormatedStringVar`, используя `trace_variable`, отслеживает их изменения,
переформатирует и обновляет производную строку, используя `set`.
Причём `FormatedStringVar` наследован от `FormatVar`, поэтому производная
строка может быть использована как форматная.

Классы-оболочки для виджетов позволяют использовать `StringVar`
(а следовательно, и `FormatedStringVar`) для ряда текстовых параметров.
Они используют `trace_variable` для реакции на изменение переменных.
В проекте повсеместно используются виджеты классов-оболочек.
Это упрощает реализацию следующего функционала:

* динамическое изменение языка интерфейса, в том числе и при использовании
интернационализированной строки в качестве форматной;
* обновление подсказок о клавишах быстрого доступа;
* обновление текстов, зависящих от значений параметров проекта.

Распространённым способом интернационализации интерфейса является
составление базы соответствия между текстом, использованным непосредственно,
и переводом этого текста на каждый поддерживаемый язык. Стандартом _де-факто_
является применение библиотеки `gettext` (или её аналога для соответствующего
языка). Она работает именно таким образом. Для перевода текстов в данном
инструменте используется её оболочка для языка Python. Многие приложения
используют функционал `gettext` для перевода текстов непосредственно при
создании виджетов. При этом изменение языка требует перезагрузки ГИ после
изменения выбранной локализации. Применение динамических строк в ГИ данного
инструмента исключает эту необходимость.
<!--+  Variable, StringVar, IntVar, DoubleVar, FormatedStringVar,
FormatVar +-->


<!--- интерфейсная часть, шаблон --->
# Шаблоны

Основой генерации кода интерфейсной части моделей являются шаблоны.
В настоящее время инструмент поддерживает генерацию заготовок для
машин, устройств системной шины и шины PCI.
А также для наиболее часто используемых программных интерфейсов QEMU.

Далее приводятся примеры заготовок кода, возвращаемых разработанным
инструментом.
Для повышения изобразительности заготовки при подготовке текста работы снабжены
комментариями, которые на самом деле не генерируются.
Такие комментарии только многострочные и начинаются с двух звёздочек
(`/** **/`) вместо одной, необходимой по синтаксису.
Все остальные комментарии следует считать генерируемыми инструментом.

Во многих примерах не приведены директивы `include`.
Это сделано для экономии места.
Стоит отметить, что для реальной модели ВМ количество заголовков
с учётом реализованной оптимизации достигает нескольких десятков.
Это в первую очередь связано с тем, что почти каждое устройство имеет свой
заголовок.
<!--+ оформление листингов +-->


<!--- оформление листингов, функция инициализации, конструктор класса,
конструктор экземпляра, устройство, ВВМ, тип (QOM), тип-родитель (QOM),
конструктор модуля (Си), макрос --->
## Вычислительная машина

Следующий код определяет минимальную ВВМ.

```c
/** Пустая функция инициализации машины (её не следует путать с конструктором
экземпляра). В этой функции должно происходить создание и связывание
устройств. **/
static void init_q35_test(MachineState* machine) {}

/** Конструктор класса. Он определяет имя машины и описание, а также
регистрирует функцию инициализации. **/
static void machine_q35_test_class_init(ObjectClass* oc, void* opaque)
{
    MachineClass *mc = MACHINE_CLASS(oc);

    mc->name = "q35_test";
    /** Описание генерируется равным имени. Это технически верно, но
    разработчику следует вручную его изменить. Например так:
    "Test implementation of Q35 chipset". **/
    mc->desc = "q35_test";
    mc->init = init_q35_test;
}

/** Описание нового типа. Для машины требуется минимум информации: имя нового
типа, имя родительского типа и конструктор класса. **/
static TypeInfo machine_type_q35_test = {
    /** TYPE_MACHINE_SUFFIX - обязательный суффикс для имён типов машин **/
    .name = "q35_test" TYPE_MACHINE_SUFFIX,
    .parent = TYPE_MACHINE,
    .class_init = machine_q35_test_class_init
};

/** Обеспечивает регистрацию описания нового типа в QOM. **/
static void machine_init_q35_test(void)
{
    type_register(&machine_type_q35_test);
}

/** Макрос, раскрывающийся в конструктор модуля согласно синтаксису компилятора.
Конструктор обеспечивает вызов machine_init_q35_test. **/
type_init(machine_init_q35_test)
```
<!--+ пример заготовки ВМ +-->


## Входящие GPIO и прерывания


Прерывания реализуются пр помощи _обратных вызовов_. Параметры обратного вызова
хранятся в структуре `IRQState`. Для ссылки на эту структуру определён
специальный тип указателя `qemu_irq`. _Источник_ содержит содержит поле
`qemu_irq` в _структуре объекта_. _Приёмник_ прерывания инициализирует
`IRQState`<!--, память под которую обычно выделяется из _кучи_ в процессе
создания прерывания-->. Для соединения двух устройств линией прерывания в поле
типа `qemu_irq` источника записывается адрес структуры `IRQState` приёмника.
Операции с этими типами данных обёрнуты в специальное GPIO API. Более того,
для распространённых шин (системной, PCI) используются свои оболочки. Само же
GPIO API оборачивает прерывания в свойства объектов QOM с именами специального
вида.

Организация исходящих прерываний сильно отличается от шины к шине и будет
рассмотрена далее. С другой стороны, входящие прерывания часто реализуются
контроллером прерываний или мостом. Более того реализация контроллера (моста)
как раз и определяет собственный API, которым должны пользоваться устройства.
В настоящее время инструмент не поддерживает создание новых шин, а значит и
мостов к ним. Инструмент способен сгенерировать заготовку для контроллера
прерываний на системной шине, главного моста PCI или альтернативного
моста PCI-PCI.

Прерывания _внутри_ PCI реализуются иначе, без использования `IRQState`.
Главный мост PCI является _композицией_ минимум из двух устройств: интерфейса
на системной шине и конфигурационного пространства (PCI-устройства). Для
приёма входящих прерываний он использует внутренний API для PCI. Таким образом,
генерация заготовок для входящих прерываний в данном инструменте предусмотрена
только для реализации контроллера прерываний на системной шине. При этом
используется GPIO API, что позволяет реализовать другие виды устройств на
системной шине, имеющие входящие прерывания.

Пример заготовки для организации входящих прерываний приведён ниже.

```c
/* Обработчик входящего прерывания. */
static void a20_line_irq_handler(void* opaque, int n, int level)
{
    __attribute__((unused)) A20LineState *s = A20_LINE(opaque);
}

static void a20_line_instance_init(Object* obj)
{
    /* Другой код */
    /* При регистрации обработчика указывается количество входящих прерываний.
       Макроподстановка A20_LINE_IN_IRQ_NUM определена в заголовке
       соответствующего устройства. */
    qdev_init_gpio_in(DEVICE(obj), a20_line_irq_handler, A20_LINE_IN_IRQ_NUM);
    /* Другой код */
}
```

Фрагмент кода приведён без изменений, все комментарии добавлены вручную.

## Устройства системной шины

Устройства системной шины являются самыми распространёнными. Интересной
особенностью является то, что системные шины разнятся от процессора к
процессору. В то же время все они обеспечивают один и тот же функционал.
Эта особенность освобождает разработчиков QEMU от необходимости реализовывать
каждую системную шину и позволяет единообразно писать модели системных
устройств.

Пример заготовки системного устройства приведён ниже.

### Заголовок устройства системной шины
Заголовок устройства обеспечивает доступность модели остальному коду QEMU и,
в особенности, моделям ВМ, использующим его.
```c
#ifndef INCLUDE_IO_PORT_80_H /* Защита от двойного включения заголовка. */
#define INCLUDE_IO_PORT_80_H
/* В sysbus.h опредлена структура SysBusDevice, используемая при определении
   структуры объекта нового типа. */
#include "hw/sysbus.h"

/* Макрос, используемый для динамического приведения типов. */
#define IO_PORT_80(obj) OBJECT_CHECK(IOPort80State, (obj), TYPE_IO_PORT_80)
/* Макроподстановка идентификатора модели устройства. */
#define TYPE_IO_PORT_80 "io_port_80"
typedef struct _IOPort80State {
    /* Структура объекта родительского класса всегда первая. */
    SysBusDevice parent_obj;
    /* Другие поля. */
} IOPort80State;

#endif /* INCLUDE_IO_PORT_80_H */
```
Сгенерированный код заголовка приведён полностью. Все комментарии дописаны
для наглядности. Остальной код соответствует выходу генератора.

### Код модуля системного устройства
Само устройство реализуется в отдельном файле `*.c` --- _модуле_.
```c
/* Конструктор объекта. */
static void io_port_80_instance_init(Object* obj)
{
    /* Аттрибут unused добавляется для обхода ошибок компиляции. В QEMU наличие
       неиспользованной переменной в функции считается за ошибкоу. Когда
       разработчик реализует логику этой функции, этот аттрибут должен быть
       удалён. Кроме того, использование других шаблонов совместно в этой
       модели приводит к наполнению этой функции кодом. В этом случае
       этот аттрибут не генерируется вообще. */
    __attribute__((unused)) IOPort80State *s = IO_PORT_80(obj);
}

static void io_port_80_realize(DeviceState* dev, Error** errp)
{
    __attribute__((unused)) IOPort80State *s = IO_PORT_80(dev);
}

/* Функция предусматривает сброс устройства в начальное состояние.
   Например, при перезагрузке ВМ. */
static void io_port_80_reset(DeviceState* dev)
{
    __attribute__((unused)) IOPort80State *s = IO_PORT_80(dev);
}

static void io_port_80_class_init(ObjectClass* oc, void* opaque)
{
    DeviceClass *dc = DEVICE_CLASS(oc);

    dc->realize = io_port_80_realize;
    dc->reset   = io_port_80_reset;
}

static TypeInfo io_port_80_info = {
    .name          = TYPE_IO_PORT_80,
    .parent        = TYPE_SYS_BUS_DEVICE,
    .instance_size = sizeof(IOPort80State),
    .instance_init = io_port_80_instance_init,
    .class_init    = io_port_80_class_init
};

static void io_port_80_register_types(void)
{
    type_register_static(&io_port_80_info);
}

type_init(io_port_80_register_types)
```
Такое устройство может быть скомпилировано и создано при инициализации ВМ, но
оно не будет никак себя проявлять в системе. Любое реальное устройство
может иметь регистр, отображенный на память (MMIO), исходящее и/или входящее
прерывание. Примеры этого приведены ниже.

### MMIO и PMIO

Заготовка отображения регистров устройства на память выглядит следующим
образом. Помимо представленного кода в структуру объекта добавляется поле
`mmio`.
```c
/* Пара функций: обработчики записи в регистр устройства и чтения. */
static void a20_line_mmio_write(void* opaque, hwaddr addr, uint64_t data, \
    unsigned size)
{
    __attribute__((unused)) A20LineState *s = A20_LINE(opaque);

    switch (addr) {
    /* Для удобства отладки шаблон предусматривает только генерацию сообщения
       об обращении к нереализованному регистру. Реализация регистров
       заключается в добавлении `сase` блоков для обработки доступа к
       соответствующим смещениям регистров относительно условного стартового
       адреса. Т.е. одна пара функций может реализовывать сразу несколько
       регистров. Обычно за условный стартовый адрес принимают адрес регистра с
       наименьшим смещением. */
    default:
        printf("%s: unimplemented write to 0x%"HWADDR_PRIx", size %d, "
                "value 0x%"PRIx64"\n", __FUNCTION__, addr, size, data);
        break;
    }
}

static uint64_t a20_line_mmio_read(void* opaque, hwaddr addr, unsigned size)
{
    __attribute__((unused)) A20LineState *s = A20_LINE(opaque);
    uint64_t ret = 0; /* Функция чтения должна вернуть что-нибудь. */

    switch (addr) {
    default:
        printf("%s: unimplemented read from 0x%"HWADDR_PRIx", size %d\n",
            __FUNCTION__, addr, size);
        break;
    }

    return ret;
}

/* Параметры одного отображения группируются в специальную структуру. */
static MemoryRegionOps a20_line_mmio_ops = {
    .read = a20_line_mmio_read,
    .write = a20_line_mmio_write
};

static void a20_line_instance_init(Object* obj)
{
    A20LineState *s = A20_LINE(obj);
    /* Другой код. */
    /* Инициализация отображения. */
    memory_region_init_io(&s->mmio, obj, &a20_line_mmio_ops, s, TYPE_A20_LINE, \
        A20_LINE_MMIO_SIZE);
    /* Данный вызов регистрирует это отображение именно как MMIO отображение
       на адресное пространство системную шину. */
    sysbus_init_mmio(SYS_BUS_DEVICE(obj), &s->mmio);
    /* Другой код. */
}
```

IBM PC совместимые ВМ имеют также шину LPC. По историческим причинам она
тесно переплетена с системной шиной в QEMU. Эта шина позволяет устройствам
отображать свои регистры не только на адресное пространство памяти, но и на
независимое адресное пространство портов ввода/вывода. Этот механизм
известен как PIO или PMIO. Добавление PMIO-регистров к заготовке устройства
отличается от добавления MMIO-регистров только способом регистрации
отображения. Пример регистрации PMIO приведён ниже.

```c
static void io_port_80_instance_init(Object* obj)
{
    /* Другой код. */
    memory_region_init_io(&s->pio, obj, &io_port_80_pio_ops, s, \
        TYPE_IO_PORT_80, IO_PORT_80_PIO_SIZE);
    /* Основное отличие MMIO и PMIO регистров системной шины IBM PC совместимых
       ВМ заключается в строчке ниже. */
    sysbus_add_io(SYS_BUS_DEVICE(obj), IO_PORT_80_PIO_ADDR, &s->pio);
    /* Данный код привязывает отображение к конкретному адресу. В общем случае,
       привязка возлагается на функцию инициализации ВМ. Но в LPC устройства
       не поддерживают свободное перемещение по адресам. Протокол шины таков,
       что мост лишь по ответу устройства понимает, что они присутствует в
       системе. На какие адреса отвечать --- это решает разработчик
       устройства. */
    sysbus_init_ioports(SYS_BUS_DEVICE(obj), IO_PORT_80_PIO_ADDR, \
        IO_PORT_80_PIO_SIZE);
    /* Другой код. */
}
```

### Исходящие прерывания

Заготовка устройства системной шины для каждого исходящего прерывания
имеет поле `qemu_irq` в структуре объекта. Объявления исходящего прерывания
происходит следующим образом.

```c
static void io_port_f0_instance_init(Object* obj)
{
    IOPortF0State *s = IO_PORT_F0(obj);
    /* Другой код */
    /* Регистрация одного исходящего прерывания, соответствующего полю out_irq.
       В случае регистрации нескольких прерываний важен порядок,
       т.к. используется неявная нумерация. */
    sysbus_init_irq(SYS_BUS_DEVICE(obj), &s->out_irq);
    /* Другой код */
}
```

Фрагмент кода приведён без изменений, все комментарии добавлены вручную.

## PCI

PCI-устройство в QEMU соответствует одной _функции_ реального PCI-устройства.
Функция представлена:

* конфигурационным пространством, где, среди прочего, содержится
идентификационная информация PCI;
* перемещаемыми регистрами (BAR), отображаемыми на адресное пространство PCI;
* четырьмя физическими прерываниями и несколькими логическими прерываниями
(MSI).

### Идентификация

Конфигурационное пространство функции PCI является обязательным базовым
интерфейсом
взаимодействия ПО с устройством. Опрашивая регистры конфигурационного
пространства с _идентификационной информацией_, драйвер опознаёт
соответствующее устройство, и, используя другие регистры осуществляет
предварительную настройку. В конфигурационном пространстве также содержится
множество другой информации, в том числе и времени выполнения.

Чтобы обеспечить видимость присутствия PCI-устройства в системе достаточно
следующей заготовки (для краткости часть кода заменена комментариями вида
"` -= ... =- `").

```c
/* -= конструктор объекта =- */

/* Базовый класс PCI-устройств перегружает методы realize и unrealize,
реализуя в них общую функциональность. PCI-функции должны перегружать
другую пару соответствующих методов: realize (несмотря на схожесть имён, это
разные методы) и exit, для добавления дополнительной логики. */
static void test_pci_card_realize(PCIDevice* dev, Error** errp)
{
    __attribute__((unused)) TestPCIcardState *s = TEST_PCI_CARD(dev);
}

static void test_pci_card_exit(PCIDevice* dev)
{
    __attribute__((unused)) TestPCIcardState *s = TEST_PCI_CARD(dev);
}

static VMStateDescription vmstate_test_pci_card = {
    .name = TYPE_TEST_PCI_CARD,
    .version_id = 1,
    .fields = (VMStateField[]) {
        /* Всякая PCI-функция должна добавить к своему состоянию поле,
           соответствующее структуре объекта родительского класса - PCIDevice,
           т.к. в ней содержится состояние конфигурационного пространства. */
        VMSTATE_PCI_DEVICE(parent_obj, TestPCIcardState),
        VMSTATE_END_OF_LIST()
    }
};

static void test_pci_card_class_init(ObjectClass* oc, void* opaque)
{
    DeviceClass *dc = DEVICE_CLASS(oc);
    PCIDeviceClass *pc = PCI_DEVICE_CLASS(oc);

    /* Важно, что метод перегружаются в PCIDeviceClass, а не в DeviceClass. */
    pc->realize   = test_pci_card_realize;
    pc->exit      = test_pci_card_exit;
    dc->vmsd      = &vmstate_test_pci_card;
    /* Последующие поля определяют идентификационную информацию об устройстве.
       Они не являются непосредственной частью конфигурационного пространства,
       но, на основании их значений конструктор объекта базового класса
       автоматически заполнит соответствующие регистры. */
    pc->vendor_id = PCI_VENDOR_ID_AMD;
    pc->device_id = PCI_DEVICE_ID_AMD_SCSI;
    pc->class_id  = PCI_CLASS_STORAGE_SCSI;
    pc->revision  = 0;
}

static TypeInfo test_pci_card_info = {
    .name          = TYPE_TEST_PCI_CARD,
    .parent        = TYPE_PCI_DEVICE,
    /* -= регистрация конструкторов и размера объекта =- */
};
/* -= код регистрации типа =- */
```

Код приведён без изменений, все комментарии добавлены вручную.

Значения идентифицирующих констант задаются с помощью макроподстановок,
которые определены в заголовке `pci_ids.h`. В инструменте реализована
возможность на основе анализа макроподстановок составить базу данных
PCI-идентификаторов, которая используется при генерации заготовок из шаблонов.
В ГИ реализован специальный виджет, позволяющий выбирать идентификатор из
списка. Добавление собственных идентификаторов пока не реализовано и является
направлением дальнейших исследований.

### BAR

Перемещаемые регистры реализуются таким же образом, как и MMIO (PMIO) регистры.
Принципиальное отличие заключается в способе регистрации отображения.
От разработчика устройства требуется только зарегистрировать BAR-отображение.
Управление перемещаемыми регистрами осуществляется через конфигурационное
пространство. Соответствующая логика реализуется базовым классом PCI-устройств.

```c
/* -= обработчики доступа к отображению =- */

static MemoryRegionOps test_pci_card_mem_bar_ops = {
/* -= регистрация обработчиков доступа и других параметров отображения =- */
};

static void test_pci_card_realize(PCIDevice* dev, Error** errp)
{
    TestPCIcardState *s = TEST_PCI_CARD(dev);
    /* -= инициализация отображения в структуре объекта =- */
    /* Регистрация отображения как BAR. */
    pci_register_bar(&s->parent_obj, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, \
        &s->mem_bar);
    /* -= другой код =- */
}
```

Код приведён без изменений, все комментарии добавлены вручную.

### Прерывания INTx и MSI

На шине PCI существует ряд способов сигнализации прерываний. В работе
рассматриваются:

* традиционная сигнализация по линиям INTx,
* сигнализация с помощью сообщений (MSI).

При традиционной сигнализации используется выделенные физические линии
(их обычно 4), к которым могут иметь доступ устройства на шине.
В конфигурационном пространстве предусмотрен регистр, через который можно
сообщить устройству, какую линию ему следует использовать. Устройства в
данном случае часто предсказуемы (т.е. они честно используют указанную линию).
Модель PCI-устройств в QEMU имеет вспомогательные функции для этого.
Поведение остальных участников распространения прерываний сильно отличается от
платформы к платформе:

* может быть разное количество физических линий;
* линии могут быть разведены к разным контактам на разных разъёмах.

Количество линий и способ внешней сигнализации определяется контроллером шины.
Также предусмотрена возможность настройки отображения контактов на физические
линии. Чтобы пользоваться традиционными прерываниями от устройства не требуется
инициализации. Сама сигнализация выполняется одной функцией. Т.е. для поддержки
традиционных прерываний не требуются шаблоны.

Традиционные прерывания имеют ряд недостатков. По этой причине были введены
прерывания основанные на пересылке сообщений (MSI). Впоследствии было
увеличено количество сообщений, доступных устройству (MSI-X). Пересылка
сообщения есть запись по настраиваемому адресу. Часто адрес соответствует
специализированному регистру в контроллере прерываний. Благодаря этому
контроллер максимально сразу оповещается о прерывании.

Наличие прерываний MSI --- особенность конкретного устройства. О наличии
свидетельствуют стандартные регистры в конфигурационном пространстве, которые
должны быть соответствующим образом настроены при создания устройства.
Инструмент позволяет сгенерировать соответствующую заготовку.

```c
static void test_pci_card_realize(PCIDevice* dev, Error** errp)
{
    /* -= Другой код =- */
    /* Инициализация MSI. */
    msi_init(dev, TEST_PCI_CARD_MSI_CAP_OFFSET, TEST_PCI_CARD_MSI_VECTORS, \
        TEST_PCI_CARD_MSI_64BIT, TEST_PCI_CARD_MSI_VECTOR_MASKING);
    /* -= Другой код =- */
}

static void test_pci_card_exit(PCIDevice* dev)
{
    /* -= Другой код =- */
    msi_uninit(dev); /* Отмена инициализации MSI. */
    /* -= Другой код =- */
}
```

Код приведён без изменений, все комментарии добавлены вручную.

При инициализации MSI требуется указать:

* смещение регистров в конфигурационном пространстве;
* количество векторов (значение должно быть степенью 2 в интервале [1, 32]);
* количество бит в адресе для записи сообщения (64 или 32);
* допустимость маскирования (отключения) сообщений.

Инструмент создаёт в заголовочном файле устройства макроподстановки с
со значениями этих параметров и использует их в коде инициализации.

## Таймеры

Таймеры используются для отсрочки действия относительно времени ВМ или времени
основной машины. В устройствах, в основном, используются первые. С их
помощью можно ограничить пропускную способность УАПП, реализовать периодические
прерывания и т.п.

Добавление заготовки таймера, помимо добавления указателя в заготовку структуры
объекта, включает следующий код.

```c
/* Функция, вызываемая по истечение времени таймера. */
static void io_port_80_timer_cb(void* opaque)
{
    __attribute__((unused)) IOPort80State *s = IO_PORT_80(opaque);
}

static void io_port_80_instance_init(Object* obj)
{
    IOPort80State *s = IO_PORT_80(obj);
    /* Другой код. */
    /* Создание таймера */
    s->timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, io_port_80_timer_cb, s);
}
```
Фрагмент кода приведён без изменений, все комментарии добавлены вручную.

Кроме этого таймер имеет часть состояния, которое должно быть сохранено в
снимке ВМ. Генерация соответствующего кода рассматривается ниже.

## Состояние времени выполнения

Как уже говорилось, модель любого реального устройства имеет переменные
времени выполнения, которые описывают мгновенное _состояние устройства_.
Чтобы сообщить QEMU список этих переменных конструктор класса должен
соответствующим образом инициализировать поле в структуре класса.
Пример объявления состояния устройства приведён ниже.

```c
static VMStateDescription vmstate_test_pci_card = {
    .name = TYPE_TEST_PCI_CARD,
    .version_id = 1,
    .fields = (VMStateField[]) {
        /* Любое PCI устройство должно сообщить, в каком поле своей структуры
           объекта содержится структура базового класса PCIDevice. Т.к. этот
           класс содержит часть состояния. Например, конфигурационное
           пространство PCI. Для сохранения этого состояния в QEMU даже
           предусмотрен специальный макрос. */
        VMSTATE_PCI_DEVICE(parent_obj, TestPCIcardState),
        /* Некоторые элемента API QEMU могут иметь состояние и соответствующие
           поля тоже должны быть объявлены. Например, таймеры. */
        VMSTATE_TIMER_PTR(timer_0, TestPCIcardState),
        VMSTATE_TIMER_PTR(timer_1, TestPCIcardState),
        VMSTATE_END_OF_LIST()
    }
};

static void test_pci_card_class_init(ObjectClass* oc, void* opaque)
{
    /* Другой код. */
    /* Регистрация описателя состояния в статической переменной класса. */
    dc->vmsd      = &vmstate_test_pci_card;
    /* Большой пробел перед = является следствием выравнивания всех
       присваиваний. В данном случае по следующему коду. */
    pc->vendor_id = PCI_VENDOR_ID_AMD;
    /* Другой код. */
}
```
Фрагмент кода приведён без изменений, все комментарии добавлены вручную.

Данный пример демонстрирует тесную связь между разными шаблонами. В частности,
добавление заготовки таймера к устройству также затрагивает заготовку
состояния устройства.

## Символьные устройства

Абстракция "символьное устройство" в QEMU применяется для унификации
поточного ввода/вывода. Распространённый пример: последовательный порт УАПП,
который может быть подключён к виртуальному терминалу, завернут в TCP
соединение, выведен в файл и мн.др. Такая вариативность как раз и достигается
использованием этой абстракции.

Инструмент позволяет сгенерировать следующую заготовку.

```c
/* Вызывается для чтения size байт, начиная с адреса buf. */
static void test_pci_card_chr_read(void* opaque, const uint8_t* buf, int size)
{
    __attribute__((unused)) TestPCIcardState *s = TEST_PCI_CARD(opaque);
}

/* Опрос устройства о количестве байт, которые оно готово принять. */
static int test_pci_card_chr_can_read(void* opaque)
{
    __attribute__((unused)) TestPCIcardState *s = TEST_PCI_CARD(opaque);

    return 0; /* Устройство ещё не реализовано и принимать не может. */
}

/* Уведомление устройства о событии, произошедшем в канале. */
static void test_pci_card_chr_event(void* opaque, int event)
{
    __attribute__((unused)) TestPCIcardState *s = TEST_PCI_CARD(opaque);
}

/* Функция реализации объекта. */
static void test_pci_card_realize(PCIDevice* dev, Error** errp)
{
    /* Другой код */
    /* Наличие назначенного символьного устройства не обязательно. Устройство
       должно уметь корректно работать без него. */
    if (s->chr) {
        /* Регистрация обработчиков. */
        qemu_chr_add_handlers(s->chr, test_pci_card_chr_can_read, \
            test_pci_card_chr_read, test_pci_card_chr_event, s);
    }
    /* Другой код */
}

```

Фрагмент кода приведён без изменений, все комментарии добавлены вручную.
Во фрагменте не приведены добавление поля в структуру объекта и регистрация
этого поля как _свойства_. Последнее описывается далее.

## Блочные устройства

Блочные устройства применяются для упрощения реализации ПЗУ. Поддерживается
доступ к блокам байт по произвольному адресу. При этом применяется асинхронное
выполнение (в отдельной нити) операций ввода/вывода применительно к
_файлу-образу_ в файловой системе основной ВМ, содержащему данные ПЗУ.
Также абстракция "блочное устройство" поддерживает нетривиальные форматы
хранения файлов-образов, предоставляя разработчику ПЗУ унифицированный API.

Для добавления блочного устройства к заготовке устройства генерируется
следующий код.

```c
/* Структура объекта. */
typedef struct _TestPCIcardState {
    /* Другие поля */
    BlockBackend *blk; /* Ссылка на описатель блочного устройства. */
} TestPCIcardState;

static void test_pci_card_realize(PCIDevice* dev, Error** errp)
{
    /* Другой код */
    if (s->blk) { /* Наличие назначенного блочного устройства не обязательно. */
        /* Даже способ инициализации блочного устройства уже относится
           к индивидуальной части модели устройства. Всё что можно сделать:
           добавить блок проверки в функцию реализации объекта. */
        /* TODO: Implement interaction with block driver. */
    }
    /* Другой код */
}

```

Фрагмент кода приведён без изменений, все комментарии, кроме `TODO` подсказки
для разработчика, добавлены вручную. Помимо этого кода, поле `blk`
регистрируется как свойство. Это описано ниже.

## Свойства объектов

Любой объект QOM может иметь свойства. Формирование перечня свойств для каждого
объекта возложено, в общем случае, на конструктор объекта. Добавление каждого
свойства осуществляется вызовом специальной функции имеющей множество
параметров. В то же время базовый класс устройств реализует механизм более
компактного определения свойств некоторых типов. Инструмент использует именно
этот механизм, т.к. генерация свойств низкоуровневым способом не требуется
для генерируемых заготовок по следующим причинам:

* модели ВМ не нуждаются в дополнительных свойствах;
* для устройств принято использовать соответствующий механизм.

Ниже приведён пример определения свойств устройства.

```c
/* Этот массив определяет два свойства PCI устройства: символьное и блочное
   устройства. Макросы TEST_PCI_CARD_CHR и TEST_PCI_CARD_DRIVE сгенерированы в
   заголовочном файле устройства. */
static Property test_pci_card_properties[] = {
    DEFINE_PROP_CHR(TEST_PCI_CARD_CHR, TestPCIcardState, chr),
    DEFINE_PROP_DRIVE(TEST_PCI_CARD_DRIVE, TestPCIcardState, blk),
    DEFINE_PROP_END_OF_LIST()
};

/* Конструктор класса */
static void test_pci_card_class_init(ObjectClass* oc, void* opaque)
{
    DeviceClass *dc = DEVICE_CLASS(oc);
    /* Другой код */
    /* Регистрация перечня свойств. Затрагивается шаблон функции конструктора
       касса. */
    dc->props     = test_pci_card_properties;
    /* Другой код */
}
```

Фрагмент кода приведён без изменений, все комментарии добавлены вручную. Как
уже отмечалось, наличие назначенного блочного или символьного устройства не
обязательно. Регистрация соответствующих полей как свойств даёт возможность
пользователю с командной строки настроить подключение устройства к внешним
источникам ввода/вывода. Это особенно часто применяется для символьных
устройств, т.к. для блочных в QEMU есть дополнительная абстракция, и
пользователь работает уже с ней (опции `hda` ... `hdd`, `fda`, `cdrom`,
`pflash` и др.).

Этот фрагмент, аналогично фрагменту, регистрирующему состоянию устройства,
демонстрирует сложную взаимосвязь различных шаблонов, при их применении к
одному устройству.

# Автоматизированная разработка моделей устройств и машин

Разработка моделей устройств и машин --- это два разных вида процессов.
Однако процесс разработки модели машины часто проходит одновременно и
взаимосвязанно с процессами разработки устройств, входящих в эту машину.
Далее эти процессы рассматриваются подробно с акцентом на применение
инструмента автоматизации, разработанного в рамках данной работы.

## Процесс разработки модели устройства

Общее время затрачиваемое программистом на создание модели устройства
складывается из следующих этапов.

### 1. Ознакомление с имеющейся информацией об устройстве.

На этом этапе программист должен получить следующую информацию.

*   тип шины, на которую подключается устройство (в данной работе
    подразумеваются только системная шина и PCI);
*   перечень внешних интерфейсов, через которые устройство взаимодействует
    с внешним миром, например:

    *   поточный (символьный или байтовый) канал;
    *   носитель информации, допускающий доступ к произвольным адресам;
    *   сетевой интерфейс; и др.;

*   перечень периодических событий в логике работы;
*   количество входящих и исходящих прерываний;
*   количество групп регистров для чтения и/или записи;
*   значения идентификаторов (для PCI);
*   имя нового типа QOM для этого устройства;
*   имя папки в QEMU, соответствующей семантике устройства.

### 2. Создание заготовки для устройства.

В течение этого этапа программист должен
создать компилируемый код, учитывающий полученную на предыдущем этапе
информацию. При наличии возможности, следует внедрить устройство в ВМ, и,
запустив ПО, удостовериться, что оно пытается взаимодействовать с
устройством. Сбои и отказы в работе ПО ожидаемы, так устройство не
реализовано. Однако сбои и отказы в работе самого эмулятора свидетельствуют
об ошибках программиста, допущенных в течение предыдущей работы. Они должны
быть решены до перехода на следующий этап.

Инструмент ориентирован на автоматизацию этого этапа.
При этом использование инструмента состоит в выполнении следующих действий.

*   внесение информации с предыдущего этапа в настройки генерации;
*   генерация кода;
*   тестирование сгенерированного кода и возможная корректировка
    инструмента.

При обнаружении ошибок, вызванных несоответствием инструмента,
программист должен идентифицировать изменения, произошедшие в QEMU, и
внести их в набор эвристик. Необходимость добавления эвристик в инструмент
смягчается их перманентностью: каждую корректировку нужно внести
однократно.

### 3. Реализация индивидуальной части устройства.

Этот этап выполняется _итеративно_. Одна итерация включает:

*   реализация _части_ логики устройства;
*   тестирование реализованной части вплоть до исправления основных ошибок;

Размер части которую нужно реализовать за одну итерацию должен быть
выбран программистом по своему усмотрению. Часто для исправления всех
ошибок требуется реализовать оставшиеся части. Такие ошибки можно
отложить на последующие итерации, но соответствующие части нужно
реализовывать в первую очередь.

При тестировании на каждой итерации важную роль играет качество тестового
ПО. Вопрос, касающиеся тестового ПО, выходят за рамки настоящей работы.
Однако стоит перечислить средства, имеющиеся в QEMU.

*   GDB-сервер, реализующий протокол remote GDB для контроля гостевого ПО.
    Он позволяет контролировать поведение устрйоства с точки зрения
    тестового ПО.
*   Можно использовать отладчик применительно к самому эмулятору. Но
    возможны проблемы с задержками в протоколе GDB, если необходимо
    одновременно контролировать и эмулятор, и гостевое ПО.

С версии 2.8 в QEMU была добавлена технология детерминированного
воспроизведения [[$](#ref.DetReplay)]. Выбранный подход к
реализации технологии требует от
программистов устройств внимания к тому, что их устройство вело себя
детерминировано в рамках данного подхода. Подробное рассмотрение
правил, которых должны придерживаться программисты выходит за рамки данной
работы. Так или иначе на каждой итерации следует хотя бы раз
воспользоваться технологией и убедиться в отсутствии расхождений при
воспроизведении.
Кроме того, отладка детерминированной модели принципиально легче.

Этот этап, в идеале, не заканчивается никогда. Практически, устройство
можно считать реализованным, когда в нём перестают проявляться ошибки
влияющие на работу _интересующего_ ПО. Опыт показывает, что глубина
проработки модели непосредственно определяется производственными нуждами и
экономической целесообразностью повышения качества модели.

Хорошим показателем является принятие модели устройства сообществом
разработчиков QEMU.

## Процесс разработки модели платформы

Разработка модели платформы включает разработку недостающих моделей устройств.
В особо сложном случае требуется разработка поддержки архитектуры процессора.
Исследование подходов к автоматизации этого случая является направлением
дальнейших исследований. Это выходит за рамки данной работы.

Рассмотрим процесс разработки модели платформы поэтапно.

### 1. Ознакомление с имеющейся информацией о платформе.

На этом этапе нужно получить следующую информацию.

* Перечень устройств. Для каждого устройства важно понять, имеется ли в QEMU
его реализация. Наличие аналога следует рассматривать как отсутствие самого
устройства с той разницей, что разработка этого устройства будет ускорена.

* Перечень шин. Эта информация может быть получена на основе анализа
устройств, являющихся мостами между разными шинами. Наличие в платформе
шины, не реализованной в QEMU значительно усложняет разработку, т. к. придётся
разрабатывать эмуляцию такой шины. Автоматизация создания нового типа шины
является направлением дальнейших исследований и выходит за рамки данной работы.

* Распределение устройств по шинам. К этой информации также относятся адреса,
которые имеют устройства на своих шинах.

* Перечень линий прерываний и прочей сигнализации, выходящей за пределы той,
что уже реализована в шине. В большинстве случаев это касается только
прерываний между устройствами системной шины, т.к. она не инкапсулирует этот
механизм.

* Перечень внешних интерфейсов. Сюда относятся порты сетевых адаптеров, УАПП и
носители для ПЗУ.

### 2. Создание заготовок недостающих устройств.

Задача этого этапа --- подготовить QEMU к созданию интегрированной платформы.
Недостающие устройства не следует реализовывать полностью. Достаточно
выполнить 1 и 2 этапы для каждого из устройств. Основная сложность в разработке
платформы --- это разработка устройств из этой платформы. Она, в свою
очередь, существенно упрощается, если имеется возможность тестировать
устройство в целостной платформе. Сложность интеграции платформы сравнима со
сложностью разработки одного устройства.

### 3. Создание модели платформы.

Имея полный перечень устройств (или их заготовок) можно сразу получить
модель платформу, которая будет работать при условии отсутствия ошибок в
устройствах.

Используя информацию, полученную на этапе 1, нужно реализовать функцию
инициализации машины QEMU, учтя все элементы (устройства, шины и
внешние интерфейсы) связи между ними (в т. ч. сигнализацию).

Корректность функции инициализации будет проверяться в течение разработки
всех устройств (выполнения третьего этапа). Концом этого этапа можно считать
момент, когда исправлены все ошибки в работе устройств, предположительно
вызванные неправильным подключением.

Разработанный инструмент позволяет выполнить большую часть этого этапа с
использованием графического представления платформы в виде схемы, похожей
на граф, где узлами являются устройства и точки объединения сигналов
(прерываний), а рёбрами --- шины и линии прерываний. Отдельно создаются
участки памяти, присутствующие на системной шине. Они иногда передаются как
свойства в специализированные устройства.

Некоторые контроллеры шин, например, главный контроллер PCI из Intel ICH9,
отображает адресное пространство PCI _под_ (с меньшим приоритетом при
перекрытии) адресное пространство системной шины, но сам при этом участок
памяти для PCI не создаёт, а принимает как свойство извне.

Инструмент генерирует функцию инициализации машины и служебный код. От
программиста требуется написание передачи ссылок на объекты, описывающие
внешние интерфейсы, в соответствующие устройства (как свойства; или методом,
определяемым реализацией модели устройства). Для ускорения этого процесса
рекомендуется записывать в соответствующие свойства устройств нулевые
ссылки. А затем заменить ссылки правильными значениями вручную.
Автоматизация этой подстановки является направлением дальнейших
исследований. Но она будет экономить порядка десятка строк кода, в то время как
объём сгенерированного кода может достигать сотен строк.

Кроме этого в QEMU есть устройства, метод создания которых отличается
от общепринятого. Для них потребуется ручное вмешательство. Для удобства
разработки платформы инструментом, вместо таких устройств рекомендуется
создавать узлы, соответствующие базовому классу устройств. А затем вручную
переписывать код создания. Этот подход позволит использовать ссылки на такие
устройства в остальных частях ВМ.

Таким образом, инструмент почти полностью реализует этот этап разработки
модели платформы.

# Результаты

Основным назначением инструмента является ускорение разработки моделей
устройств и платформ. Методика оценки качества инструмента ориентирована в
первую очередь на оценку достигнутого ускорения.

Ускорения разработки модели планируется достичь за счёт автоматической
генерации заготовки. Однако, поскольку QEMU непрерывно развивается, то
от пользователя может потребоваться адаптировать шаблоны под новые
изменения. Инструмент спроектирован так, чтобы сократить время на внесение
соответствующих эвристик. Время, затраченное на их внесение, тоже должно быть
учтено.

## 1440FX
## Q35
## CISCO C2600 из Dynamips

Одним из примеров применения инструмента был маршрутизатор C2621XM серии
C2600 (CISCO). За основу была взята его реализация из эмулятора
Dynamips [[$](#ref.Dynamips)]. Последний распространяется с открытым исходным кодом.
Его разработка на данный момент заморожена, если не считать проект
GNS3 [[$](#ref.GNS3)], который использует Dynamips для эмуляции маршрутизаторов,
коммутаторов и концентраторов, исправляя в нём ошибки.

На основе анализа исходного кода Dynamips был составлен перечень устройств и
сформулирована их взаимосвязь в рамках ВМ C2621XM. Схема ВМ представлена на
рисунке [$](#pic.C2621XM).

![Рисунок <a name="pic.C2621XM">$</a> --- Схема маршрутизатора C2621XM](C2600.png)

Начальной версией QEMU был выбран последний на тот момент выпуск 2.9.0.
Все устройства, использованные в C2621XM, отсутствовали в QEMU, и были
перенесены из Dynamips. При этом все заготовки были сгенерированы с помощью
инструмента. В таблице [$](#tbl.C2621XM_devices) приведена обзорная информация
по элементам C2621XM. Сразу стоит отметить, что все эти устройства в Dynamips и,
как следствие, их перенесённые в QEMU версии реализованы не полноценно, а
лишь до той степени, чтобы удовлетворять потребностям некоторых версий
системного ПО.

Таблица <a name="tbl.C2621XM_devices">$</a>. Элементы C2621XM

+-------------------+----------------------------------------------------------+
|       Тип         |                         Описание                         |
+===================+==========================================================+
| `MPC860`          | Процессор с системой команд PowerPC из одноимённого МК.  |
+-------------------+----------------------------------------------------------+
| `MPC860_IC`       | Контроллер прерываний. Поддерживает маскировку           |
|                   | прерываний.                                              |
+-------------------+----------------------------------------------------------+
| `MPC860_CPM`      | Маршрутизатор прерываний, позволяющий программно         |
|                   | перенаправить прерывания на другие номера. Стоит между IC|
|                   | некоторыми из устройств.                                 |
+-------------------+----------------------------------------------------------+
| `MPC860_SCC`      | Заглушка неизвестного устройства, предположительно       |
|                   | применяемо для пакетного обмена данными. В данном случае |
|                   | этот функционал не требуется.                            |
+-------------------+----------------------------------------------------------+
| `MPC860_DMA`      | Связка из двух устройств осуществляющая копирование      |
|                   | данных без участия процессора. Фактически используется   |
| `MPC860_PORT`     | для копирования данных между буферами сетевого адаптера и|
|                   | ОС.                                                      |
+-------------------+----------------------------------------------------------+
| `MPC860_WDT`      | Заглушка сторожевого таймера.                            |
+-------------------+----------------------------------------------------------+
| `C2600_IO_FPGA`   | Устройство служит аккумулятором прерываний от шины PCI,  |
|                   | на которой, фактически, размещаются только сетевые       |
|                   | адаптеры, и предоставляет доступ к EEPROM, с             |
|                   | идентификационной информацией об установленных сетевых   |
|                   | адаптерах.                                               |
+-------------------+----------------------------------------------------------+
| `CISCO_NVRAM`     | ПЗУ используемое для хранения настроек маршрутизатора.   |
+-------------------+----------------------------------------------------------+
| `CISCO_REMOTE`    | Устройство предоставляет интерфейс для получения         |
|                   | информации о системе:                                    |
|                   |                                                          |
|                   | * объём ОЗУ,                                             |
|                   | * объём ПЗУ (NVRAM),                                     |
|                   | * вариант платформы (в данном случае C2621XM);           |
|                   |                                                          |
|                   | а также позволяет хранить данные с доступом по ключу.    |
+-------------------+----------------------------------------------------------+
| `8MB_BOOTFLASH`   | ПЗУ фиксированного размера 8МиБ неизвестного             |
|                   | назначения.                                              |
+-------------------+----------------------------------------------------------+
| `NS16552`         | УАПП с двумя портами, именуемыми "con" и "aux". Через эти|
|                   | порты осуществляется настройка маршрутизатора.           |
+-------------------+----------------------------------------------------------+
| `PPC32_PIT`       | Таймер, посылающий прерывания с частотой 250 Гц.         |
+-------------------+----------------------------------------------------------+
| `C2600_PCI_HOST`  | Главный мост PCI и его конфигурационное пространство.    |
|                   | Отличительной особенностью является наличие 8 выделенных |
| `C2600_PCI`       | линий прерываний вместо стандартных 4.                   |
+-------------------+----------------------------------------------------------+
| `AM79C971`        | Сетевой адаптер PCI. В QEMU уже имеется его двойник с    |
|                   | именем `pcnet`. Но особенности реализации сильно         |
|                   | отличаются, поэтому данное устройство было реализовано   |
|                   | исключительно на основе Dynamips.                        |
+-------------------+----------------------------------------------------------+

В таблице [$](#tbl.C2621XM_statistic) приведена количественная оценка объёма
работы по реализации C2621XM с использованием инструмента. Работа протекала в 3
этапа:

* подготовка;
* генерация;
* реализация.

На этапе _подготовки_ в QEMU вносились изменения, которые могут повлиять на
работу инструмента (добавлены отсутствующие PCI идентификаторы). Кроме того
был доработан процессор MPC860, а именно:

* реализован MMU;
* реализована внутренняя коммутация прерываний;
* исправлены некоторые регистры специального назначения согласно с
документацией [[$](#ref.MPC860)].

Первые два изменения позволили использовать процессор в режиме полносистемной
эмуляции: до этого поддерживалась только эмуляция ABI ОС.

На этапе _генерации_ была изучена реализация C2621XM в Dynamips, составлен
перечень устройств и схема их логического соединения. Эти данные были внесены
в инструмент, зетам, с его помощью, были сгенерированы заготовки.

На этапе _реализации_ была перенесена индивидуальная часть устройств из
Dynamips, а также скорректирована заготовка ВМ. Корректировка ВМ, в основном,
заключалась в следующем:

* связка параметров ВМ с CLI QEMU:
    * образы ПЗУ,
    * подключение сетевых интерфейсов,
    * подключение символьных устройств;
* реализация специального кода;
* корректировка имён переменных.

Таблица <a name="tbl.C2621XM_statistic">$</a>. Оценка объёма реализации C2621XM

+------------+------------------+-----------------+---------------+
| Этап       | Затронуто файлов | Вставлено строк | Удалено строк |
+============+==================+=================+===============+
| Подготовка | 8                | 128             | 35            |
+------------+------------------+-----------------+---------------+
| Генерация  | 37               | 2186            | 0             |
+------------+------------------+-----------------+---------------+
| Реализация | 31               | 4747            | 419           |
+------------+------------------+-----------------+---------------+
| Суммарно   | 45               | 6642            | 35            |
+------------+------------------+-----------------+---------------+

Данные собраны с помощью Git. Важно учесть, что изменение строки
в данной статистике представлено как 1 удаление и 1 добавление.
Таким образом, приблизительно 1/3 кода всего маршрутизатора была
сгенерирована автоматически. Причём только 1/5 часть сгенерированного кода
потребовала модификации. Итоговая версия маршрутизатора была успешно настроена
для маршрутизации пакетов между двумя сетями (по одной на каждый интерфейс) и
обеспечивала стабильное соединение в течении тестового времени (приблизительно
12 часов). В качестве генератора трафика использовалась утилита `ping`,
настроенная на отправку ICMP запросов длиной 60кБ и 50кБ с машин из обеих
сетей. Сбоев замечено не было. Среднее время запроса 12мс.

# Заключение
# Использованные источники

$. <a name="ref.Git"></a>Система контроля версий Git. "https://git-scm.com/about",
09.03.2017.

$. <a name="ref.Tkinter"></a>Страница библиотеки для создания графического
интерфейса "Tkinter". "https://wiki.python.org/moin/TkInter", 2017.03.13.

$. <a name="ref.PyCParser"></a>Страница библиотека PyCParser на GitHub.
"https://github.com/eliben/pycparser", 20.03.2017.

$. <a name="ref.DetReplay"></a>_Что-нибудь про детерминированное воспроизведение_

$. <a name="ref.Dynamips"></a>_Что-нибудь про динамипс_

$. <a name="ref.GNS3"></a>_Что-нибудь про GNS3_

$. <a name="ref.MPC860"></a> _Ссылка на спеку MPC860_

