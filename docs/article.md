[//]: # (pandoc article.md --standalone --smart -o article.html)

# Автоматизация разработки моделей устройств и вычислительных машин для QEMU

## Обозначения и сокращения

* API Application programming interface
* BAR Base address registers
* CD Compact disc
* CLI Command line interface
* IRQ Interrupt request
* MMIO Memory mapped input/output
* MSI Message signalled interrupt
* PCI Peripheral component interconnect
* QOM QEMU object model
* ROM Read-only memory
* SHA1 Secure Hash Algorithm 1
* TAP ?
* UDP User datagram protocol
* USB Universal serial bus
* ВМ вычислительная машина
* ГИ графический интерфейс
* НЖМД накопитель на жестком магнитном диске
* ООП объектно-ориентированное программирования
* ОС операционная система
* ПЗУ постоянное запоминающее устройство
* УАПП универсальный асинхронный приёмо-передатчик

## Аннотация
## Введение

### Ручной подход

Используемый в настоящее время подход к реализации моделей для QEMU
заключается в поиске похожей функциональности в существующих моделях и
реализации требуемой по образу и подобию. При этом применяется обычное
копирование кода, с последующими его правками и дополнениями. С опытом
всё большую часть кода можно писать по памяти, но нужно следить за
изменениями в QEMU.

### Определение типа QOM
<a name=QOM_type_definition></a>

Минимальный код, который должен быт написан, чтобы встроить
новую модель в инфраструктуру QEMU включает в себя:

* инициализацию структуры `TypeInfo`, где должны быть указаны
строковые имена родительского класса и класса добавляемой модели;

* функцию-конструктор `register_types` модуля, вызывающую
`type_register_static` для всех `TypeInfo` в модуле;

* макроподстановку `type_init`, указывающую компилятору, что
`register_types` является конструктором модуля: её следует вызвать
неявно;

* правило в `Makefile`, регистрирующее модуль в системе сборки.

Добавленная таким образом модель не будет обладать никакой
функциональностью. Если класс родителя _абстрактный_, то модель даже
нельзя будет создать.

Реальный код чаще всего реализует, среди прочего, следующее.

* Структура, описывающая объекты своего класса (далее
_структура объекта_). В ней _первым_ полем обязательно присутствует
структура объекта родительского класса.

* Информация о размере структуры объекта.

* Функция инициализации структуры объекта.
При создании объекта класса модели выделяется область памяти,
указанного размера. Затем к ней в порядке наследования применяются
функции инициализации. В ООП такие функции (_методы_) называются
_конструкторами_.

* Структура, описывающая класс в целом (далее _структура класса_).
Она, аналогично, содержит _первым_ полем структуру класса родителя,
сопровождается информацией о её размере и функцией инициализации
(_конструктором класса_ в ООП).

Таким образом QEMU, на языке Си реализует объектно-ориентированную
парадигму программирования для моделирования платформ, устройств и
сопряжённых _сущностей_. Предназначение описанных контейнеров данных
и функций аналогично принятому в ООП.

Согласно принятым в QEMU правилам написания кода, все описанные выше
структуры, функции, строковые константы и т.д. имеют в своём названии
имя типа объекта. Оно принимает различные формы, в том числе, чтобы
быть синтаксически корректным. Далее по тексту, для ссылок на типы
будут использоваться имена структур классов.
<!-- Если тип не имеет собственной структуры, то будет выбран любой
доступный способ однозначной ссылки на тип. -->

### Определение модели устройства

Тип модели устройства должен быть потомком типа `DeviceClass`.
Этот тип предусматривает, что код устройства может реализовывать
следующее:

* объявление _свойств устройства_;

* объявление функции _реализации_ устройства;

* объявление _состояния устройства_.

Свойство устройства --- это поле
структуры объекта, доступное по строковому имени путём вызова
специальных функций. Свойство является константным начальным значением,
т.е. оно задается во время создания устройства и не может быть изменено
впоследствии.
Объявление свойств осуществляется следующим образом.

*  Определение массива структур типа `Property` при помощи
макросов вида `DEFINE_PROP_*`, указывающих строковое имя,
тип, поле структуры объекта и, в некоторых случаях, значение
по умолчанию (в остальных случаях значение по умолчанию
фиксировано API QEMU.

* Определение в заголовочном файле устройства макросов со
строковыми именами свойств (требование стиля программирования).

* Инициализация поля `props` структуры класса указателем на
массив свойств (т.е. на первый элемент). Данное поле предусмотрено
в типе `DeviceClass` (т.е. осуществляется его _перегрузка_).
Инициализация производится в конструкторе класса.

Функция реализации устройства выполняет "второй этап" инициализации
структуры объекта.
Наиболее яркий пример применения второго этапа --- свойства.
Причина этому следующая. Свойства не могут быть назначены, пока
не создано устройство. Устройство не может быть создано _до
конца_ пока не определены его свойства. Функция реализации
_доинициализирует_ устройство после определения его свойств.
Она регистрируется по указателю в поле `realize`, предусмотренным
в типе `DeviceClass`, конструктором класса.

Оболочка полей структуры устройства в свойства усложняет привычный
для Си способ определения начальных значений структуры, но
предоставляет следующие возможности:

* Прозрачное преобразование инвариантных строковых идентификаторов
объектов в указатели. Идентификаторы удобно использовать при
создании устройства. При написании кода ВМ это снимает с
программиста необходимость писать код, получающий указатели.
Код получается короче и понятнее.
Кроме того, только таким способом можно определить значение
свойства через CLI. Указатели же оптимизируют доступ к памяти
внутри реализации устройства.

* Контроль корректности значений.

В QEMU реализована возможность сохранения состояния ВМ в файл.
Сохранённое состояние называется _снимком_ (англ. _snapshot_).
Снимок ВМ включает в себя снимки её устройств. Поддержка данной
возможности требует, чтобы поведение модели устройства полностью
определялось значениями свойств и _состоянием_. Для объявления
своего состояния тип устройства определяет переменную типа
`VMStateDescription`, где указывает:

* перечень своих полей и их типов, которые влияют на поведение
модели (исключая свойства);

* строковое имя своего состояния;

* версию своего состояния.

Тип поля состояния определяет способ его сохранения и загрузки.
Версия используется для контроля использования сохранений,
сделанных прежними версиями модели устройства.

Для хранения указателя на описание состояния устройства в
в структуре класса типа `DeviceClass` предусмотрено поле
`vmsd`, инициализируемое конструктором класса.

### Определение модели вычислительной машины

Новая модель вычислительной машины должна быть потомком _абстрактного_
класса `MachineClass`, который наследован от `ObjectClass`. Минимальный
код, определяющий ВМ должен содержат следующее.

* Функцию инициализации ВМ. Её не следует путать с конструктором объекта.
Основная задача функции инициализации ВМ --- создание элементов ВМ.
Она может быть пустой.

* Конструктор класса, регистрирующий функцию инициализации и определяющий
строковое имя ВМ, без которого инициализировать ВМ будет проблематично.

* Регистрацию нового типа QOM, как описано [выше](#QOM_type_definition).
Важной особенностью является то, что имя QOM типа ВМ должно иметь суффикс
`-machine`.

Основную часть кода ВМ составляет функция инициализации ВМ. В ней
инициализируются процессор, память, основные мосты, периферийные
устройства и т.д.

В отличие от устройств, для ВМ не предусмотрено удобное объявление
свойств. Однако свойства являются частью базового типа `ObjectClass`.
Чтобы добавит свойства в ВМ необходимо определить конструктор объекта,
которой объявит требуемые свойства. Конструктор в типе `MachineClass`
уже имеет ряд свойств, которых достаточно для большинства ВМ:

* `kernel`, `initrd` и `append`: используются если в функции
инициализации ВМ предусмотрена загрузка ядра ОС Linux;

* `firmware`: предусматривает загрузку микропрограммного обеспечения;

* `usb`: даёт возможность включить/выключить поддержку USB в ВМ; и др.

Реальная работоспособность этих свойств зависит от реализации функции
инициализации.

Кроме того, структура объекта ВМ, `MachineState`, содержит следующие
важные поля, не оформленные как свойства:

* `cpu_model`: имя QOM типа процессора;

* `ram_size`: объём установленной оперативной памяти.

Однако, функция инициализации может игнорировать и их: реальная
ВМ может существовать с фиксированной моделью процессора и объёмом
памяти.

## Подход к автоматизации

Условно код модели можно разделить на две части _индивидуальную_ и
_интерфейсную_.
Индивидуальная часть воплощает суть устройство в его программной реализации.
Именно эта часть определяет то как именно будет эмулироваться присутствие
конкретно этого устройства в системе; делает его модель особенной,
относительно других устройств, уникальной. При этом модель устройство является
частью инфраструктуры QEMU, и индивидуальная часть должна эмулировать
поведение устройства, используя
предоставленные посредством API QEMU возможности. В модели всегда можно
выделить часть кода
взаимодействующую с этим API, она и называется _интерфейсной_. То есть,
интерфейсная часть кода
служит связкой между кодом индивидуальной части модели и окружающей средой.

Индивидуальная часть обычно сформулирована на естественном языке в документации
на устройство. При этом отсутствует единый формат _формального_ описания,
которого бы придерживались производители.
Ввиду этого автоматизация разработки этой части весьма затруднительна и
выходит за рамки этой работы.

С другой стороны, интерфейсная часть всех устройств очень похожа. Отличия
заключаются, в основном, в перечне и количестве используемых моделью внешних
интерфейсов, а также в именах собственных, которые часто формируются из
названия модели устройства путём применения к нему формализованных правил,
сформулированных или _де-факто_ (в коде существующих устройств), или в
тексте из файла `CODING_STYLE`, описывающим принятый в проекте стиль
программирования.

Опираясь на формализуемость правил написания интерфейсной части можно
разработать программу, принимающую небольшое количество понятных параметров
и возвращающую компилируемый код-шаблон, реализующий минимальный функционал
и готовый к внесению в него индивидуальной логики вручную. Таким образом,
программист, ознакомившись с техническим описанием устройства, может
формально сформулировать перечень требуемых модели устройства интерфейсов
и, применив разработанный инструмент, приступить непосредственно к
реализации индивидуальной части.

Отдельно нужно сказать о вычислительных машинах. Хотя описания вычислительных
машин, аналогично устройствам, лишены формализма и единообразия, в QEMU
присутствует развитое API для интеграции устройств в единое целое (то есть в
ВМ).
Состав ВМ определяется функцией её инициализации, которая последовательно
создаёт все устройства и соединяет их воедино. В данной работе реализован
программный интерфейс, позволяющий описать состав ВМ и сгенерировать её
функцию инициализации. Интерфейс реализован на языке Python, поэтому описание
получается несколько короче, чем соответствующий ему генерированный код. Но
основное преимущество заключается в возможности написания графического
интерфейса, значительно повышающего наглядность и скорость описания ВМ. Таким
образом, отсутствие формализованного описания ВМ смягчается удобством
компоновки ВМ по этому описанию.

С помощью этого API можно формально описать полноценную ВМ. При этом
имеются следующие ограничения.

1. Устройства, входящие в ВМ, должны иметь интерфейсную часть реализованную в
полном соответствии с текущим подходом к встраиванию устрйоств.

2. Сформулированная машина сильна ограничена в настройке.

В QEMU присутствует ряд устройств, которые были реализованы еще до того, как
был выработан текущий подход к встраиванию устройств. На данный момент
не все из них были переписаны в соответствии с этим подходом. То есть они
реализуют свою индивидуальную часть в обход новейших возможностей API для
интерфейсной части.

<!-- А вот это я вообще не понял: -->
Первое ограничение не существенно,
если преобладающая часть устройств ВМ реализуется вместе с ней по формальному
описанию. Такие устройства будут иметь совместимую интерфейсную часть. Если
же нужно использовать существующую модель устройства, то возможны следующие
варианты.

* Скорректировать реализацию устройства.

* Вписать код, выполняющий его подключение в ВМ, в функцию инициализации после
её генерации. Этот вариант существенно ограничивает возможности инструмента:

    * устройство должно будет подключаться к шине вручную;

    * если устройство --- мост, то и его шины должны будут подключаться также
вручную;

    * подключение прерываний придётся выполнять вручную;

    * в общем случае, отсутствие возможности сослаться на устройство из API
при проектировании устройства приведёт к снижению количества автоматизированной
работы.

Второе ограничение заключается в следующем.
Сгенерированная ВМ зафиксирована на уровне исходного кода. То есть, в
неё будет проблематично добавить новое устройстве и невозможно удалить
имеющееся. CLI QEMU поддерживает ряд ключей, динамически создающих
дополнительные устройства (например, можно подключить к шине PCI новую
функцию). Также часть параметров машины заведомо требуется от пользователя,
например, файл-образ ПЗУ (НЖМД, микросхема flash-памяти, CD, и т.п.),
оконечную точку УАПП (виртуальный терминал, файл, и т.п.), способ подключения
сетевого порта (TAP-адаптер, Ethernet по UDP и т.п.) и т.д.
<!-- Конеч того, что я вообще не понял -->

### Метод шаблонов

Как уже отмечалось, код интерфейсной части всех устройств достаточно
единообразен, чтобы его можно было получить из некоторого набора строк,
путём подстановки параметров.

Часто для одного интерфейса необходимо сгенерировать несколько фрагментов кода.
При этом фрагменты должны следовать в правильном порядке как относительно
друг друга, так и фрагментов других интерфейсов. Это требование следует из
синтаксиса языка Си. Например, если один из аргументов функции является
указателем на структуру, то сама структура должна быть объявлена выше.

Часть параметров одних шаблонов может быть связана с параметрами других
шаблонов. Например, функция инициализации устройства, является частью шаблона,
встраивающего устройство в иерархию типов QOM. Если же устройство имеет
регистр MMIO, то для него применяется другой шаблон. Но регистр должен быть
зарегистрирован в функции инициализации. А значит, имя переменной, описывающей
регистр, является параметром шаблона функции инициализации.

Символы API QEMU должны быть доступны в сгенерированных файлах. Для этого
нужно включить (директивой `#include`) соответствующие заголовочные файлы.
Список этих файлов может быть автоматически вычислен по перечню использованных
символов. При этом, код будет выглядеть лучше, если минимизировать список
заголовочных файлов.

Эти и другие тонкости учтены в модели, используемой системой. При этом нельзя
сказать, что она закончена, так как периодически обнаруживаются случаи,
требующие её модификацию. Здесь представлено описание модели, используемой
в текущей версии.

### Программный интерфейс модели QEMU

Значительная часть сложной системы взаимосвязей шаблонов может быть создана
автоматически. От пользователя требуется небольшое количество интуитивно
понятных параметров. Это достигается разработанным API, скрывающим от него
сложность взаимосвязи шаблонов. Пользователь настраивает генерацию кода
посредством ниже перечисленных классов.

Видимая пользователю иерархии классов построена по тому-же принципу, что и
иерархия классов QOM. Таким образом, он легко сможет сопоставить
соответствующие классы.

Реализована следующая иерархия классов.

* `QOMDescription`
    * `SysBusDeviceDescription`
    * `PCIExpressDeviceDescription`
    * `MachineNode`

`QOMDescription` является базовым классом. Он не предназначенный для
использования.

`SysBusDeviceDescription` описывает устройство на системной шине.

`PCIExpressDeviceDescription` описывает PCI устройство. PCI _устройство_
в QEMU соответствует одной _функции_ реального устройства. QEMU не моделирует
физические взаимодействия по шине. Поддержка MSI (а именно реакция на
запись сообщения в память) реализуется главным мостом, обычно являющимся
устройством на системной шине. Как следствие, и PCI, и PCI Express устройство
может быть описано через этот класс.

`MachineNode` описывает ВМ и входящие в её устройства.

Перечисленные классы выполняют роль контейнеров для параметров. При генерации
кода на основе этих параметров создаются классы внутреннего API,
непосредственно участвующего в генерации.

В то время как для описания устройств системной шины или PCI достаточно базовых
типов, для описания устройств, входящих в ВМ, требуется ещё одно дерево
классов. Причём в это дерево включает классы, описывающие то же самое, что и
перечисленные выше классы. А именно: устройства системной шины и PCI. Тем не
менее, они описывают эти устройства с разных точек зрения:

* первые содержат перечень использованных в модели устройства элементов API
  QEMU;
* вторые же описывают способ подключения устройств.

Поскольку часть элементов API QEMU способствуют единообразию подключения
устройств в машину, то вторые могут быть вычислены из первых. Однако это
является одним из направлений дальнейших исследований.

Совместно объекты этих классов образуют _проект_ (`QProject`): контейнер с
данными для генератора кода.

### Модель вычислительной машины

Содержимое ВМ описывается с использованием следующей иерархии классов.

* `Node`
    * `BusNode`
        * `SystemBusNode`
        * `PCIExpressBusNode`
        * `ISABusNode`
        * `IDEBusNode`
        * `I2CBusNode`
    * `DeviceNode`
        * `SystemBusDeviceNode`
        * `PCIExpressDeviceNode`
    * `IRQLine`
    * `IRQHub`
    * `MemoryNode`
        * `MemoryLeafNode`
            * `MemoryAliasNode`
            * `MemoryRAMNode`
            * `MemoryROMNode`

`Node` содержит уникальный идентификатор узла ВМ.

`BusNode` содержит все данные, необходимые чтобы описать шину любого типа. Все
дочерние классы конкретизируют эти данные. Они были введены для сокращения
объёма кода, необходимого для добавления шины вручную. При использовании
графического интерфейса это не актуально.

Большинство параметров шины определяют генерацию кода для шины этого типа. И
только следующие параметры определяют место шины в ВМ:

* ссылка на устройство-мост (родительское), контролирующее эту шину;
* ссылки на устройства, подключённые к шине (дочерние).

`DeviceNode` описывает параметры, присущие любому устройству:

* модель устройства (листовой тип в дереве типов QOM);
* ссылку на шину, к которой подключено это устройство (родительскую);
* ссылки на контролируемые (дочерние) шины, если устройство является мостом;
* список значений для свойств устройства, как объекта QOM.
* ссылки на привязанные прерывания с параметрами их привязки.

`IRQLine` (линия) и `IRQHub` (концентратор) описывают распространение
прерываний между устройствами (ту его часть, которая по какой-то причине не
спрятана в шину). Концентратор прерываний используется в случаях, когда одно
прерывание должно быть доставлено в несколько устройств и/или может быть
получено из нескольких устройств (так как линия прерывания соединяет строго
два узла). Линия содержит информацию об _источнике_ и _приёмнике_ прерывания.
Причём для каждого конце, являющегося устройством, определены:

* ссылка на устройство;
* индекс порта прерывания в группе прерываний;
* имя группы прерываний.

Если концом является концентратор, то достаточно только ссылки.

Большую часть адресного пространства ВМ определяют сами устройства. В адресное
пространство входят MMIO и BAR (PCI) регистры устройств, блоки памяти ROM
устройств и т.д. Однако, такие диапазоны как адресное пространство PCI, RAM
и т.п. должны быть определены отдельно. Причём в некоторых случаях адресное
пространство PCI создаётся главным мостом, а в некоторых создаётся
функцией инициализации машины и передаётся мосту как параметр.

`MemoryNode` описывает интервал-контейнер, содержащий в себе другие интервалы
со смещением, относительно своего начала.

`MemoryLeafNode` (лист) является служебным промежуточным классом, запрещающим
добавлять интервалы в интервалы, не являющимися контейнерами.

`MemoryAliasNode` (псевдоним) используется, чтобы обеспечить доступ к
интервалу (или его отрезку) из другого адреса.

`MemoryRAMNode` и `MemoryROMNode` описывают непрерывный интервал эмулируемой
физической памяти. Причём `MemoryROMNode` нельзя менять.

Каждый из перечисленных классов, описывающих интервал памяти, имеет следующие
параметры:

* отладочное строковое имя;
* размер;
* смещение в контейнере и ссылку на него;
* допустимость перекрытия в пределах одного контейнера и приоритет для его
  разрешения;

`MemoryNode` _может_ иметь непустой список ссылок на детей, а
`MemoryAliasNode` _должен_ содержать смещение в пределах интервала, на который
он перенаправляет запросы к себе, и ссылку на него.

Каждый из перечисленных классов (включая потомков `QOMDescription`)
является контейнером для параметров. Их основные функции:

* хранение настроек пользователя,
* сохранение настроек в файл и обратно,
* взаимодействие с графическим интерфейсом.

### Формат файлов

Настройки генерации устройств и ВМ собраны в единый _проект_. Проект
описывается классом `QProject` (QEMU project). При работе с ГИ используется
его подкласс `GUIProject` (GUI project), дополнительно хранящий настройки
отображения.

Проект сохраняется в файл в текстовом формате, совместимым с синтаксисом
языка Python. Сохранённый проект представляет собой _почти_ корректную
программу на языке Python, результатом выполнения которой является
определение переменой ссылающейся на объект класса `QProject` (или
`GUIProject`, в случае ГИ), _эквивалентный_ объекту, сохранённому в
файл. Программа используется имена из пользовательского API. Генератор
файлов сохранений изначально разрабатывался таким образом, чтобы файлы
выводились в удобном для человека формате. В сгенерированной
программе отсутствуют инструкции импорта необходимых имён (это
возложено на загрузчик файла), поэтому программа не является корректной.

Под _эквивалентностью_ сохранённого и восстановленного объекта понимается:

* равенство значений простых типов в соответствующих атрибутах;
* каждый ссылочный атрибут в восстановленном объекте указывает на
объект эквивалентный тому, на который этот атрибут указывал в
сохранённом объекте (ссылки на `None` восстанавливаются как ссылки на
`None`).

При сохранении не гарантируются:

* равенство _незначащих_ пробельных символов;
* синтаксически не значащий порядок фрагментов кода (порядок определения
аргументов конструкторов со значениями по умолчанию, порядок
восстановления несвязанных объектов, и т.п.);
* сохранность комментариев, если таковые были внесены вручную в файл
проекта.

Данные особенности создают сложности при ручной работе с файлами проекта,
а также при хранении файлов с использованием системы контроля версий.
Решение этой проблемы является один им направлений дальнейшего развития
инструмента.

## Графический интерфейс

Все возможности инструмента доступны пользователю посредством API. Для
описания устройств и ВМ достаточно произвольного текстового редактора.
Однако применение ГИ, спроектированного _специально_ для работы с API,
имеет следующие преимущества.

* Исключены лексические ошибки в именах элементов API и синтаксические
ошибки, т.к. пользователь водит только значения параметров.

* Для многих значений параметров в QEMU определены макросы,
использование которых предпочтительней, согласно _хорошему тону
программирования_. ГИ интерфейс, проанализировав код QEMU, может
предоставить пользователю список доступных макросов, обычно применяемых
с данным типом параметра. Например, идентификатор PCI, родительский
тип QOM, свойство QOM и т.п.

* Исключены некоторые семантические ошибки (например, в ГИ не
предусмотрена возможность соединения линией прерывания двух шин, в то
время как пользователь волен написать всё, что угодно в текстовом
редакторе). Имеется возможность дополнить ГИ средствами поиска менее
очевидных семантических ошибок.

* Все доступные параметры сосредоточены в _виджетах_ с названиями на
естественном языке. В большинстве случаев знания QEMU достаточно, чтобы
понять суть параметра, не обращаясь к справочной информации.

* Интерпретация ВМ в виде схемы.

### Обратимые операции

Современный редактор должен предоставлять средства по работе с изменениям.
Минимальный перечень возможностей: _отмена_ и _повторение_. В разработанном
ГИ контроль изменений пользователя реализован с использованием абстракции
_обратимых операций_.

Обратимая операция содержит следующую информацию:

* данные, необходимые для осуществления действия;
* данные, необходимые для возврата к состоянию до осуществления действия;
* флаг завершённости операции;
* ссылки на предшествующие и последующие операции, позволяющие перемещаться
вдоль истории изменений;
* описание действия, выполняемого операцией, на естественном языке для
пользователя.

ГИ интерфейс построен таким способом, что любые изменения в проекте должны
быть осуществлены через абстракцию "_трекер истории_" (`HistoryTracker`).
То есть, для выполнения действия ГИ создаёт операцию, добавляет её в
историю и даёт команду на выполнение трекеру. Данный процесс спрятан от
пользователя под кнопкой "_Применить_".

В памяти всегда присутствует состояние проекта, соответствующее перечню
выполненных операций. Поддержание этого соответствия --- задача трекера.
Действия по отмене и повторению операций выполняются с использованием его
методов.

<!--
Часто сделанная в прошлом операция не связана с операциями сделанными после
неё. Такая операция может быть отменена без отмены последующих операций.
Формально, в будущем не должно быть операций, _зависящих_ от отменяемой
операции. Операция называется зависящей от _предшествующей_ операции, если
предшествующая операция:
1. изменяет то, что операция потом изменяет повторно;
2. создаёт то, что операция потом использует (для выполнения своего
действия), изменяет или удаляет;
3. удаляет то, что операция потом создаёт.

Операция, изменяющая что-то перед его удалением, здесь считается
независимой относительно удаляющей с тем условием, что при отмене
изменяющей операции будут обновлены данные в удаляющей, т.к., очевидно,
что удаляющая операция содержит в себе последнюю копию утрачиваемых
данных удаляемого объекта.
-->

### Обратная связь при изменениях

Текущие значения параметров проекта влияют не только на значения,
представленные в виджетах. Они также могут влиять на:

* выбор типа виджета (тип свойства QOM объекта определяет, какой виджет
должен быть использован для представления его значения);
* существование виджета (при удалении узла ВМ должны исчезать
виджеты его редактирующие);
* перечень допустимых значений (выпадающий список выбора дочерней
шины для устройства должен отображать список всех допустимых шин,
имеющихся в ВМ, и он должен корректироваться при добавлении или
удалении очередной шины);
* формулировка допустимых значений (если был изменён индекс шины
в мосте, все списковые виджеты должны скорректировать текст в
соответствующих строках).

Это не полный перечень зависимостей. При этом, любое значение
может быть изменено _минимум_ двумя способами:

* через соответствующий виджет;
* отменой или повторением правки пользователя.

Для учёта произвольных зависимостей в ГИ применяются _события_. Каждый
виджет добавляет свой метод обратного вызова себя в список
_наблюдателей_ трекера. При выполнении операции трекер уведомляет всех
наблюдателей о выполнении операции. Наблюдатель должен выбрать
операции, относящиеся к виджету и среагировать соответствующим образом.

### Сопрограммы и фоновые вычисления

Стандартом _де-факто_ при разработке ГИ является применение событийно-
ориентированного программирования, при котором непозволительно выполнять
длительные вычисления при обработке события. Так как это приводит к
"подтормаживанию" интерфейса и снижению комфортности.

Встраивание длительных вычислений в ГИ принято производить следующими
способами:

* распараллеливание (вычисления выносятся в отдельный процесс или нить);
* фрагментация (вычисления разбиваются на малые фрагменты, которые
могут быть быстро выполнены при обработке события, и выполняются
в течение обработки специализированных событий).

Для реализации фрагментации удобно использовать "сопрограммы" --- функции
позволяющие передавать управление другой сопрограмме раньше
выхода, "замораживая" своё состояние, а затем получать его в
то же место, откуда оно было передано (при этом сохраняются все
локальные переменные).

Python, в свою очередь, имеет языковую поддержку т.н. _генераторов_ ---
сопрограмм способных дополнительно вернуть значение при очередной передаче
управления (инструкцией `yield`).

В ГИ длительные вычисления реализуются генераторами. Долго работающие
функции реализуются как сопрограммы, снабжаясь операторами `yield` через
каждый фрагмент вычислений. Управление между сопрограммами распределяется
_диспетчером_, встраиваясь между обработкой событий ГИ.

В ГИ в фоне выполняются следующие задачи:

* анализ исходного кода QEMU;
* предварительное вычисление эвристик о текущей версии QEMU;
* генерация кода;
* уведомления о событиях (т.н. _сигналы_), не требующих синхронной
обработки;
* динамическое размещение узлов ВМ на диаграмме (опция позволяющая
избегать взаимного прекрытия изображений узлов).

Выбор в пользу фрагментации, был сделан с целью упрощения разработки:

* исключено состояние гонки, не требуется синхронизация, нет параллельных
ошибок, легче отладка;
* в Python нити выполняются синхронно, причём встроенный
планировщик не различает приоритетных вычислений при обработке событий
ГИ в реальном времени от фоновых вычислений, что приводит к "подтормаживанию";
для реальной параллельности требуется использовать сторонние библиотеки;
* для реализации параллельности требуется больше кода;
* в инструменте отсутствуют _регулярные_ сложные вычисления: достаточно
одного процесса.

### Диаграмма вычислительной машины

ВМ состоит из множества элементов, которые связаны между собой
различными способами. Схема позволяет пользователю видеть основные
связи в ВМ, не прибегая к умственным усилиям по интерпретации
текстового описания в воображении.

Полезной функцией является экспорт диаграммы в векторное изображение.
Это экономит значительное количество времени пользователя при
написании сопряжённых текстов. Например, иллюстрации, представленные
в данной статье, получены автоматизированно с использованием данной
функции.

### Динамический текст, интернационализация

В ряде случаев требуется удобный механизм, позволяющий обновлять текст
в уже созданных виджетах. Библиотека Tkinter[[Tkinter](#Tkinter)]
поддерживает изменение текстовой информации в виджетах, но способы
варьируются от класса к классу. Также требуется хранить ссылки
на все виджеты, где используется переменный текст. Наконец, нужен
механизм уведомления об изменениях. В библиотеке уже реализовано дерево
классов для реализации переменных, поддерживающих уведомления.
В частности, класс `StringVar` имеет методы `set` и `get`, для доступа
к значению, и метод `trace_variable`, назначающий функцию обратного
вызова по его изменению.

Для наиболее часто используемых классов виджетов были разработаны
классы-оболочки, принимающие переменные класса `StringVar` в качестве
значений текстовых параметров. Используя `trace_variable`, они
прозрачно для остального кода выполняют обновление соответствующих
полей обёртываемых объектов. Таким образом, для изменения текста во
время выполнения достаточно вызвать метод `set`. Это также унифицирует
механизм изменения текста в виджетах.

Особый интерес представляют динамические строки, являющиеся результатом
форматирования других динамических строк с использованием динамических
значений. Когда меняется строка форматирования или любое из значений,
использованных в подстановке, требуется пересчитать производное
значение. В работе был реализован класс `FormatedStringVar` с этим
функционалом. Он используется в связке с классом `FormatVar`
реализующим оператор `%` для класса `StringVar`. Это даёт возможность
использовать динамические строки, как строки форматирования,
синтаксически так же как обычные строки Python. Данные классы совместимы
с виджетами-оболочками, так как наследованы от `StringVar`.

В проекте повсеместно используются виджеты классов-оболочек. Это
упрощает реализацию следующего функционала:

* динамическое изменение языка интерфейса, в том числе строк описания
операций редактирования проекта, полученных путём форматирования;
* обновление подсказок об ускорителях (т.н. "горячих клавишах");
* обновления текстов, зависящих от значений параметров проекта.

## Шаблоны
### Классовая иерархия QEMU
### Свойства объектов
### Состояние времени выполнения
### Таймеры
### Символьные устройства
### Блочные устройства
### Входящие прерывания
### Устройства системной шины
#### MMIO и PMIO
#### Исходящие прерывания
### PCI
#### Идентификация
#### BAR
#### MSI
### Адаптация к изменениям QEMU

QEMU является развивающимся проектом. Это приводит к тому, что в нём
периодически происходят изменения, делающие генератор кода несовместимым с
новой версией.

Для решения этой проблемы используется эвристический подход. Все _эвристики_
работы инструмента, зависящие от версии QEMU, собраны в единую базу данных.
Код инструмента получает к ним доступ по _строковому ключу_. Значением
эвристики может быть любая сущность языка Python: от целочисленной
константы до класса или модуля. Таким образом, при необходимости, можно
_подменить_ почти всю реализацию инструмента.

Каждая эвристика имеет как минимум два значения: _новое_ и _старое_.
Одна и та же эвристика может меняться многократно. Каждая пара значений
привязывается к SHA1 идентификатору изменения в Git-графе [[Git](#Git)]
истории QEMU.

При обнаружении очередного несоответствия между инструментом и QEMU,
разработчик должен сделать следующие действия.

* Определить, что изменилось.
* Определить, SHA1 соответствующего изменения.
* Дополнить базу данных эвристик новым и старым значением, придумав
эвристике осмысленное название (_ключ_).
* Изменить код инструмента таким образом, чтобы он зависел от значения,
соответствующего _ключу_ в данный момент.

В инструменте реализован алгоритм, позволяющий для заданных SHA1,
базы эвристик и Git-истории вычислить значения для всех имеющихся в базе
ключей.

## Генерация кода
### Модель языка Си и препроцессора
### Модель файла с исходным кодом
#### Взаимосвязь с существующим кодом
#### Учёт зависимостей
### Встраивание в код QEMU
## Методика испытаний
### 1440FX
### Q35
### CISCO C2600 из Dynamips
## Результаты
## Заключение
## Использованные источники

* <a name="Git"></a>Система контроля версий Git. "https://git-scm.com/about",
09.03.2017.

* <a name="Tkinter"></a>Страница библиотеки для создания графического
интерфейса "Tkinter". "https://wiki.python.org/moin/TkInter", 2017.03.13.

