# Автоматизация разработки моделей устройств и вычислительных систем для QEMU

## Обозначения и сокращения

* API Application programming interface
* CD Compact disc
* CLI Command line interface
* MMIO Memory mapped input/output
* QOM QEMU object model
* TAP ?
* UDP User datagram protocol
* ВМ вычислительная машина
* НЖМД накопитель на жестком магнитном диске
* ПЗУ постоянное запоминающее устройство
* УАПП универсальный асинхронный приёмо-передатчик

## Аннотация
## Введение
## Ручной подход

Используемый в настоящее время подход к реализации моделей для QEMU
заключается в поиске похожей функциональности в существующих моделях и
реализации требуемой по образу и подобию. При этом применяется обычное
копирование кода, с последующими его правками и дополнениями.

### Разработка модели устройства
### Разработка модели вычислительной машины
## Подход к автоматизации

Условно код модели можно разделить на две части _индивидуальную_ и
_интерфейсную_.
Индивидуальная часть есть само устройство в своей программной реализации.
Именно эта часть определяет логику работы устройства, делает его особенным,
относительно других устройств. Так как устройство является
частью системы, оно должно предоставлять функционал, используя
предоставленные ему возможности посредством фиксированного API. Часть кода,
взаимодействующая с этим API и называется _интерфейсной_. То есть, она
служит связкой между внутренней логикой модели и окружающей средой.

Индивидуальная часть обычно сформулирована на естественном языке в техническом
описании. При этом отсутствует единый формат _формального_ описания логики
устройства, которого бы придерживались производители.
Ввиду этого автоматизация разработки этой часть весьма затруднительная и
выходит за рамки этой работы.

С другой стороны, интерфейсная часть всех устройств очень похожа. Отличия
заключаются, в основном, в перечне и количестве используемых моделью внешних
интерфейсов, а также в именах собственных, которые часто формируются из
названия модели устройства путём применения к нему формализованных правил,
сформулированных или _де-факто_ (в коде существующих устройств), или в
тексте из файла `CODING_STYLE`, описывающим принятый в проекте стиль
программирования.

Опираясь на формализуемость правил написания интерфейсной части можно
разработать программу, принимающую небольшое количество понятных параметров
и возвращающую компилируемый код-шаблон, реализующий минимальный функционал
и готовый к внесению в него индивидуальной логики вручную. Таким образом,
программист, ознакомившись с техническим описанием устройства, может
формально сформулировать перечень требуемых модели устройства интерфейсов
и, применив разработанный инструмент, приступить непосредственно к
реализации индивидуальной части.

Отдельно нужно сказать о вычислительных машинах. Хотя описания вычислительных
машин, аналогично устройствам, лишены формализма и единообразия, в QEMU
присутствует развитое API для интеграции устройств в единое целое (то есть в
ВМ). С помощью этого API можно формально описать полноценную ВМ. При этом
имеются следующие ограничения.
1. Устройства, входящие в ВМ, должны иметь интерфейсную часть реализованную в
полном соответствии с моделью.
2. Сформулированная машина сильна ограничена в настройке.

В QEMU присутствует ряд старых устройств, которые написаны по-старому. То есть,
они ещё не были переписаны на новую модель. Первое ограничение не существенно,
если преобладающая часть устройств ВМ реализуется вместе с ней по формальному
описанию. Такие устройства будут иметь совместимую интерфейсную часть.

Полученная таким образом ВМ зафиксирована на уровне исходного кода. То есть, в
неё будет проблематично добавить новое устройстве и невозможно удалить
имеющееся. CLI QEMU поддерживает ряд ключей, динамически создающих
дополнительные устройства (например, можно подключить к шине PCI новую
функцию). Также часть параметров машины заведомо требуется от пользователя,
например, файл-образ ПЗУ (НЖМД, микросхема flash-памяти, CD, и т.п.),
оконечную точку УАПП (виртуальный терминал, файл, и т.п.), способ подключения
сетевого порта (TAP-адаптер, Ethernet по UDP и т.п.) и т.д.

Состав ВМ определяется функцией её инициализации, которая последовательно
создаёт все устройства и соединяет их воедино. В данной работе реализован
программный интерфейс, позволяющий описать состав ВМ и сгенерировать её
функцию инициализации. Интерфейс реализован на языке Python, поэтому описание
получается несколько короче, чем соответствующий ему генерированный код. Но
основное преимущество заключается в возможности написания графического
интерфейса, значительно повышающего наглядность и скорость описания ВМ. Таким
образом, отсутствие формализованного описания ВМ смягчается удобством
компоновки ВМ по этому описанию.

### Программный интерфейс модели QEMU
### Метод шаблонов

Как уже отмечалось, код интерфейсной части всех устройств достаточно
единообразен, чтобы его можно было получить из некоторого набора строк,
путём подстановки параметров.

Часто для одного интерфейса необходимо сгенерировать несколько фрагментов кода.
При этом фрагменты должны следовать в правильном порядке как относительно
друг друга, так и фрагментов других интерфейсов. Это требование следует из
синтаксиса языка Си. Например, если один из аргументов функции является
указателем на структуру, то сама структура должна быть объявлена выше.

Часть параметров одних шаблонов может быть связана с параметрами других
шаблонов. Например, функция инициализации устройства, является частью шаблона,
встраивающего устройство в иерархию типов QOM. Если же устройство имеет
регистр MMIO, то для него применяется другой шаблон. Но регистр должен быть
зарегистрирован в функции инициализации. А значит, имя переменной, описывающей
регистр, является параметром шаблона функции инициализации.

Символы API QEMU должны быть доступны в сгенерированных файлах. Для этого
нужно включить (директивой `#include`) соответствующие заголовочные файлы.
Список этих файлов может быть автоматически вычислен по перечню использованных
символов. При этом, код будет выглядеть лучше, если минимизировать список
заголовочных файлов.

Эти и другие тонкости учтены в модели, используемой системой. При этом нельзя
сказать, что она закончена, так как периодически обнаруживаются случаи,
требующие её модификацию. Здесь представлено описание модели, используемой
в текущей версии.

### Модель вычислительной машины
## Шаблоны
### Классовая иерархия QEMU
### Свойства объектов
### Состояние времени выполнения
### Таймеры
### Символьные устройства
### Блочные устройства
### Входящие прерывания
### Устройства системной шины
#### MMIO и PMIO
#### Исходящие прерывания
### PCI
#### Идентификация
#### BAR
#### MSI
### Адаптация к изменениям QEMU

## Генерация кода
### Модель языка Си и препроцессора
### Модель файла с исходным кодом
#### Взаимосвязь с существующим кодом
#### Учёт зависимостей
### Встраивание в код QEMU
## Методика испытаний
### 1440FX
### Q35
### CISCO C2600 из Dynamips
## Результаты
## Заключение
## Использованные источники

